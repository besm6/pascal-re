user 419900 ะทั5^
dis 67(1234-wr)^
EEB1A3
*name
*call ficmemory
*pascal
(*=p-,t-,s8,u-,y+,l3*)
program pascompl(output,child,pasinput,pasinfor);
label 9999;
const boilerplate=' PASCAL COMPILER 15.0 (15.02.82)';
ATX=1;STX=2;OP002=3;XTS=4;ADD=5;SUB=6;RSUB=7;
AMX=8;XTA=9;AAX=10;AEX=11;ARX=12;AVX=13;AOX=14;ADIVX=15;AMULX=16;
APX=17;AUX=18;ACX=19;ANX=20;EADD=21;ESUB=22;ASX=23;XTR=24;RTE=25;
YTA=26;EADDI=29;ESUBI=30;ASN=31;NTR=32;ATI=33;STI=34;ITA=35;ITS=36;
MTJ=37;JADDM=38;UTC=39;WTC=40;VTM=41;UTM=42;UZA=43;U1A=44;UJ=45;
S4=1;S5=2;S6=3;NoPtrCheck=4;DebugCode=45;DebugPrint=46;DebugEntry=47;
ASN64=360100B;
type symbol=(
(*0B*)IDENT,INTCONST,REALCONST,CHARCONST,LTSY,GTSY,NOTSY,LPAREN,
(*10B*)LBRACK,MULOP,ADDOP,RELOP,RPAREN,RBRACK,COMMA,SEMICOLON,
(*20B*)PERIOD,ARROW,COLON,BECOMES,LABELSY,CONSTSY,TYPESY,VARSY,
(*30B*)FUNCSY,PROCSY,SETSY,PACKEDSY,ARRAYSY,RECORDSY,FILESY,BEGINSY,
(*40B*)IFSY,CASESY,REPEATSY,WHILESY,FORSY,WITHSY,GOTOSY,ENDSY,
(*50B*)ELSESY,UNTILSY,OFSY,DOSY,TOSY,DOWNTOSY,THENSY,SELECTSY,
(*60B*)PROGRAMSY, OTHERSY, NOSY);
setofsys=set of ident..selectsy;
operator=(MUL, RDIVOP, AMPERS, IDIVOP, IMODOP, PLUSOP, MINUSOP,
OROP, NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP, IMULOP, IDIVROP,
SETAND, SETXOR, SETOR, XORALLONES, FIXEDPLUS, FIXEDMINUS,
badop27, badop30, badop31, badop32, badop33, op34, op35, op36,
op37, op40, op41, op42, op43, op44, ALNUM, op46,
op47, op50, op51, NOTOP, INEGOP, RNEGOP, op55, NOOP );
dummy=(ii, rr, bb, aa, pp, cc, ss,mm,yy,oo);
word=record case dummy of
ii:(i:integer); rr:(r:real); bb:(b:boolean); aa:(a:alfa);
pp:(p:@word); ss:(s:@struc); cc:(c:char);oo:(o:operator);
yy:(y:symbol);mm:(m:set of 0..47) };
struc=record f:array[0..18] of word };
charmap=packed array ['_000'..'_176'] of char;
var (* total size 4791 words *)
(*40*) octalMode:char; 
(*41-46*)bigSkipSet, statEndSys, blockBegSys, statBegSys,
skipToSet, lvalOpSet: setofsys;
(*47-49*)  glob47z,glob48z,glob49z:boolean;
(*50*)	inStringLit:boolean;
(*51*)  glob51z:word;
(*52*)  jumpTarget:word;
(*53*)  glob53z:word;
(*54*)	charClass:operator; 
(*55-56*) SY,glob56z:symbol; 
(*57*) glob57z:word;
(*58*)	FcstCnt:integer; 
(*59*)	symTabPos:integer;
(*60*)  entryPtCnt:integer;
(*61*)  fileBufSize:integer;
(*62-63*)glob62z,glob63z:@struc;
(*64*)  curInsnTemplate:word;
(*65*)	maxLineLen :integer;
(*66*)	linePos :integer;
(*67*)	prevErrPos :integer;
(*68*)	errsInLine :integer;
(*69*)	moduleOffset:integer;
(*70*)  lineStartOffset:integer;
(*71*)	curFrameRegTemplate:integer;
(*72*)  curProcNesting:integer;
(*73*)	totalErrors :integer;
(*74*)	lineCnt :integer;
(*75*)  bucket:integer;
(*76*)  glob76z:integer;
(*77*)  heapCallsCnt:integer;
(*78*)	heapSize:integer;
(*79*)  arithMode:integer;
(*80*)	stmtName:alfa;
(*81*)  keywordHashPtr:@struc;
(*82*)  curVarKind:word;
(*83*)  curExternFile:word;
(*84*)  commentModeCH:char;
(*85*)  glob85z:word;
(*86*)	CH:char; 
(*87-88*)glob87z,glob88z:word;
(*89*)	lineNesting:integer;
(*90*)  FcstCountTo500:integer;
(*91*)	objBufIdx :integer;
(*92-94*)  glob92z,glob93z,glob94z:integer;
(*95*) glob95z: word;
(*96*)	charEncoding :integer;
(*97*) glob97z:integer;
(*98*)	atEOL:boolean;
(*99*)	checkTypes:boolean; 
(*100-102*) glob100z: boolean;
(*101-102*) glob101z,glob102z: word;
(*103*)	errors :boolean;
(*104*) declExternal:boolean;
(*105*) glob105z:boolean;
(*106*)	doPMD:boolean;
(*107*)	checkBounds:boolean;
(*108*)	fuzzReals:boolean; 
(*109*)	fixMult :boolean;
(*110*) glob110z: boolean;
(*111*)	pseudoZ:boolean;
(*112*)	allowCompat:boolean; 
(*113*)	checkFortran:boolean;
(*114*) outputFile:@word;
(*115*) inputFile:@word;
(*116*) programObj:word;
(*117*) hashTravPtr:@struc;
(*118*) uProcPtr:@word;
(*119*) externFileList:@word;
(*120-121*)glob120z,glob121z:@struc;
(*122*) pointerType:@struc;
(*123*) setType:@struc;
(*124*) booleanType:@struc;
(*125*) textType:@struc;
(*126*) integerType:@struc;
(*127*) realType:@struc;
(*128*) charType:@struc;
(*129*) alfaType:@struc;
(*130*) arg1Type:@struc;
(*131*) arg2Type:@struc;
(*132-133*)glob132z,glob133z:@word;
(*134*) curToken:word;
(*135*) curVal:word;
(*136*) O77777:word;
(*137*) intZero:set of 0..47;
(*138-139*)glob138z,glob139z:word;
(*140*) halfWord:word;
(*141*)	isLeftInsn:word;
(*142*)	hashMask:word;
(*143-146*) curIdent,glob144z,glob145z,glob146z:word;
(*147-148*)dummy4:array[147..148] of word;
(*149*)	optSflags:word;
(*150*) litOct:word;
(*151*)	litExternal :word;
(*152*)	litForward :word;
(*153*)	litFortran:word;
(*154*) uVarPtr:@word;
(*155*) curExpr:@struc;
(*156*) insnList:@struc;
(*157-158*)glob157z,glob158z:word;
(*159*) someTypeArrayBase:integer;
(*160*) extSymAdornment:integer;
(*161-165*)dummy5:array[2..6]of @struc;
(*166*) symTabCnt:integer;
(*167-246*)symtabarray:array[1..80] of word;
(*247-326*)symtbidx:array[1..80]of integer;
(*327-339*)dummy6:array[327..339] of word;
(*340-379*) entryPtTableBase:array[0..39]of word;
(*380-397*) dummy7:array[380..397]of word;
(*398-531*) glob398z:array[0..133]of integer;
(*532*) absInsn:word;
(*533*) addInt0Insn:word;
(*534*) andE1Insn:word;
(*535*) orInt0Insn:word;
(*536*) andE40to1Insn:word;
(*537*) cyclAddE1Insn:word;
(*538*) subE1Insn:word;
(*539-548*)dummy8:array[539..548]of word;
(*549-594*) insnTemp:array[0..45] of integer;
(*595*) glob595z:word;
(*596*) frameRegTemplate:word;
(*597*) constRegTemplate:word;
(*598*) disNormTemplate:integer;
(*599-728*) lineBufBase:array[1..130]of char;
(*729*)	errMapBase:array[0..9]of integer; 
(*739*)	chrClassTabBase:array ['_000'..'_177']of operator;
(*867*) kwordHashTabBase:array[0..127]of @struc;
(*995*)	charSymTabBase:array['_000'..'_177']of symbol;
(*1123*) symHashTabBase:array[0..127]of @struc;
(*1251*) typeHashTabBase:array[0..127] of @struc;
(*1378*) helperMapBase:array [1..99] of integer;
(*1477*) helperNameBase:array [1..99] of word;
(*1577-2409*)symTab:array[74000B..75500B]of word;
(*2410*) systemProcNameBase:array[1..30] of word; 
(*2440*) resWordNameBase:array[1..30] of word; 
(*2470*) longSymCnt:integer; 
(*2471*) longSymTabBase:array[1..90] of integer; 
(*2560*) longSymsBase:array[1..90]of word;
(*2651*) constValsTabBase:array[1..500]of word;
(*3151*) constNumTabBase:array [1..500]of integer;
(*3651*) objBufBase:array [1..1024]of word;
(*4675*) psInfrCopy:array['_052'..'_177']of char;
(*4761*) fcst:file of word; (* last *)
pasinput:text;
child:file of word;
pasinfor:record
(*0*)    listMode:integer;
(*1*)    errors: @boolean;
(*2*)    dummy2: integer;
(*3*)    startOffset:integer;
(*4-6*)  a0,a1,a4:@charmap;
(*7-18*) dummy3: array[7..18] of integer;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(l2arg1z, l2arg2z: word);
var l2var1z,l2var2z,l2var3z,l2var4z,l2var5z,l2var6z,l2var7z,l2var8z,
l2var9z,l2var10z,l2var11z,l2var12z,l2var13z,l2var14z,l2var15z,
l2var16z,l2var17z,l2var18z,l2var19z:word;
l2var20z,l2var21z,l2var22z:integer;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno:integer);
type errtxt=packed array[0..100] of 0..63;
var errptr:@errtxt;
errtext:array [0..100] of 0..63;
i:integer;c:char;
function pasmitxt(errno:integer):@errtxt;fortran;
function pasisoxt(txtchar:0..63):char;fortran;
{
write(' ');
if errno >= 200 then 
	write('system=', errno:0)
else {
	if (errno > 88) then
		printErrMsg(86)
	else if errno in [16..18,20] then { 
		if errno = 20 then
			errno := ord(sy = ident)*2 + 1
		else write(curToken.i:0,' ');
	} else; (*workaround*)
	errptr := pasmitxt(errno);
	unpack(errptr@, errtext, 0);
	(loop) for i:=0 to 100 do {
		c := pasisoxt(errtext[i]);
		if c = '*' then exit loop;
		write(c);
	};
	write(' ');
	if errno in [17,22] then 
		if errno = 17 then
			write(glob97z:0)
		else
			write(stmtName);
};
if errno <> 86 then writeln;
}; (* printErrMsg *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val:word);
procedure PASTPR(val:word);external;
{ 
	write(' '); PASTPR(val)
}; (* printTextWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              assignType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignType(var res:struc);
var l3var1z:@struc;
{
if someTypeArrayBase >= glob76z then
	res.f[0].s := dummy5[glob76z]
else {
new(l3var1z=7); (* XTA =7; ATI 14 instead of 14, VTM, 7 *)
new(res.f[0].p=8);
with l3var1z@ do {
f[0].i := 1;
f[4].i := 0;
f[1].i := 12;
f[2].c := chr(2);
f[3].s := integerType;
f[5].i := 1;
f[6].i := glob76z;
};
with res.f[0].s@ do {
f[0].i := (glob76z + 5) div 6;
if f[0].i = 1 then
	f[1].i := glob76z * 8
else
	f[1].i := 0;
f[2].c := chr(5);
f[3].s := charType;
f[4].s := l3var1z;
f[5].c := chr(1);
f[6].i := 6;
f[7].i := 8;
}
}
}; (* assignType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(l3arg1z:@struc);
{
curVal.m := l3arg1z@.f[0].m * hashMask.m;
mapai(curval.a, curval.i);
l3arg1z@.f[2].s :=symHashTabBase[curval.i];
symHashTabBase[curval.i] := l3arg1z;
}; (* addToHashTab *)
procedure error(errno: integer); forward;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(l3arg1z:set of 0..47);
{
objBufBase[objBufIdx].m := l3arg1z;
moduleOffset := moduleOffset + 1;
if objBufIdx = 1024 then { 
	error(49);
	objBufIdx := 1
} else objBufIdx := objBufIdx + 1;
}; (* storeObjWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(l3arg1z: integer);
var l3var1z, l3var2z, l3var3z, l3var4z: word;
l3var5z: integer;
{
l3var1z.i := l3arg1z;
l3var2z.m := l3var1z.m * [0,1,3,24..32];
if l3var2z.i = insnTemp[UJ] then {
   if glob95z = l3var2z then exit;
   if glob101z.b and (glob95z.i = 1) then {
      l3var5z := objBufIdx - 1;
      if objBufBase[l3var5z].m * [0..8] = [0,1,3..5,8] then {
         glob95z := l3var2z;
         l3var3z.m := l3var1z.m * [33..47];
         besm(360050B);
         l3var3z:=;
         l3var4z.m := objBufBase[l3var5z].m * [9..23];
         besm(360130B);
         l3var4z :=;    
         objBufBase[l3var5z].m := [0,1,3,4,6,28,29] +
         l3var3z.m + l3var4z.m;
         exit;
      }
   }
};
glob95z := l3var2z;
if (glob101z.b) then {
    isLeftInsn.m := l3var1z.m * halfWord.m;
    besm(360050B);
    isLeftInsn :=;
    glob101z.b := false
} else {
    glob101z.b := true;
    storeObjWord(isLeftInsn.m + (l3var1z.m * halfWord.m))
}
}; (* form1Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: integer);
{
    form1Insn( i1 );
    form1Insn( i2 );
}; (* form2Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: integer);
{
    form2Insn(i1, i2);
    form1Insn(i3);
}; (* form3Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
{
    if arithMode <> 1 then {
        form1Insn(disNormTemplate);
        arithMode := 1;
    }
}; (* disableNorm *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus:integer;
{
   if glob101z.b then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
}; (* getObjBufIdxPlus *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJumpOnCond(var l3arg1z:integer);
var l3var1z:integer; l3var2z: word;
{
 if glob95z.i <> insnTemplateBase[UJ] then {
 l3var1z := getObjBufIdxPlus; 
 l3var2z := glob101z;
 form1Insn(glob51z.i + l3arg1z);
 if glob101z = l3var2z then
     l3var1z := l3var1z - 1;
 l3arg1z := l3var1z;
 }
}; (* formJumpOnCond *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formLabel;
{
 if not glob101z.b then
    form1Insn( insnTemplateBase[UTC] );
 glob95z.i := 0;
}; (* formLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formInsnAndLabel(l3arg1z:integer);
{
 form1Insn( l3arg1z);
 formLabel;
 glob95z.i := 1;
}; (* formInsnAndLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(l3arg1z: word);
{
 symTab[symTabPos] := l3arg1z;
 if symTabPos = 75500B then {
    error( 50 );
    symTabPos := 74000B;
 } else
    symTabPos := symTabPos + 1;
}; (* putToSymTab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z:word):integer;
var l3var1z:word; l3var2z:integer;
{
 allocExtSymbol := symTabPos;
 if (curVal.m * halfWord.m <> []) then { 
 for l3var2z to longSymCnt do
   if (curVal = longSymsBase[l3var2z]) then {
     allocExtSymbol := longSymTabBase[l3var2z];
     exit
   };
 longSymCnt := longSymCnt + 1;
 if (longSymCnt >= 90) then {
     error( 51 );
     longSymCnt := 1;
 };
 longSymTabBase[longSymCnt] := symTabPos;
 longSymsBase[longSymCnt] := curVal;
 l3arg1z.m := l3arg1z.m + [25];
 } else
     l3arg1z.m := l3arg1z.m + curVal.m;
 putToSymTab( l3arg1z );
}; (* allocExtSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z:integer):integer;
{
 if (helperMapBase[l3arg1z] = 0) then {
     curVal := helperNameBase[l3arg1z];
     helperMapBase[l3arg1z] := allocExtSymbol( glob139z ); 
 };
 getHelperProc := helperMapBase[l3arg1z] + 67100000B;
}; (*getHelperProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
{
write(FCST, curVal);
FcstCnt := FcstCnt + 1;
}; (* toFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addSomethingToFCST:integer;
var l3var1z,l3var2z, l3var3z:integer; 
{
 l3var1z := 1;
 if (FcstCountTo500 = 0) then {
     addSomethingToFCST := FcstCnt;
     FcstCountTo500 := 1;
     constValsTabBase[1] := curVal;
     constNumTabBase[1] := FcstCnt;
     toFCST;
 } else {
     l3var2z := FcstCountTo500;
     repeat
       l3var3z := (l3var1z + l3var2z) div 2;
       if (curVal = constValsTabBase[l3var3z]) then {
           addSomethingToFCST := constNumTabBase[l3var3z];
           exit
       };
       if curval.a < constValsTabBase[l3var3z].a then
           l3var2z := l3var3z - 1
       else
           l3var1z := l3var3z + 1
     until l3var2z < l3var1z;
     addSomethingToFCST := FcstCnt;
     if FcstCountTo500 <> 500 then {
         if curval.a < constValsTabBase[l3var3z].a then
             l3var2z := l3var3z
         else
             l3var2z := l3var3z + 1;
         for l3var3z := FcstCountTo500 downto l3var2z do {
             l3var1z := l3var3z + 1;
             constValsTabBase[l3var1z] := constValsTabBase[l3var3z];
             constNumTabBase[l3var1z] := constNumTabBase[l3var3z];
         };
         FcstCountTo500 := FcstCountTo500 + 1;
         constValsTabBase[l3var2z] := curVal;
         constNumTabBase[l3var2z] := FcstCnt;
     };
     toFCST;
 }
}; (* addSomethingToFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtabForAbsolute(l3arg1z:word):integer;
var l3var1z, l3var2z,l3var3z:integer;l3var4z:word;
{
    l3var1z := 1;
    l3var4z := l3arg1z;
    if symTabCnt = 0 then {
        allocSymtabForAbsolute := symTabPos;
        symTabCnt := 1;
        symTabArray[1] := l3arg1z;
        symtbidx[1] := symTabPos;
    } else {
        l3var2z := symTabCnt;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (l3var4z = symTabArray[l3var3z]) then {
                allocSymtabForAbsolute := symtbidx[l3var3z];
                exit
            };
            if  l3var4z.a < symTabArray[l3var3z].a then
                 l3var2z := l3var3z - 1
            else
                 l3var1z := l3var3z + 1;
        until l3var2z < l3var1z;
        allocSymtabForAbsolute := symTabPos;
        if symTabCnt <> 80 then {
           if l3var4z.a < symTabArray[l3var3z].a then 
              l3var2z := l3var3z
           else
              l3var2z := l3var3z + 1;
           for l3var3z := symTabCnt downto l3var2z do {
              l3var1z := l3var3z + 1;
              symTabArray[l3var1z] := symTabArray[l3var3z];
              symtbidx[l3var1z] := symtbidx[l3var3z];
           };
           symTabCnt := symTabCnt + 1;
           symTabArray[l3var2z] := l3var4z;
           symtbidx[l3var2z] := symTabPos;
        }
    };
    putToSymTab(l3var4z);
}; (* allocSymtabForAbsolute *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset:integer;
var l3var1z:word;
{
getFCSToffset := addSomethingToFCST;
l3var1z :=;
if (l3var1z.i < 2048) then { }
else if (l3var1z.i >= 4096) then
    error(204)
else {
(*=c-*)
    getFCSToffset := allocSymtabForAbsolute(l3var1z.m + [24]) - 28672;
    exit
}
(*=c+*)
}; (* getFCSToffset *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(l3arg1z:word):integer;
{
 curVal := l3arg1z;
 curVal.m := curVal.m * [7..47];
 nrOfBits := 48-minel(curval.m);
}; (* nrOfBits *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePacked(l3arg1z: @struc; l3arg2z, l3arg3z: word);
var l3var1z:@struc;dummyloc:word;
{
 new(l3var1z=7);
 with l3var1z@ do {
 f[0].i := 1;
 f[1].i := 48;
 f[3] := l3arg1z@.f[0];
 f[4].i := 0;
 f[2].c := chr(2);
 curVal := l3arg2z;
 curVal.m := curVal.m + intZero;
 f[5] := curVal;
 curVal := l3arg3z;
 curVal.m := curVal.m + intZero;
 f[6] := curVal;
 if (f[5].i >= 0) then
    f[1].i := nrOfBits( curVal ); 
 l3arg1z@.f[0].s := l3var1z
 }
}; (* definePacked *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(l3arg1z:word):integer;
{
 curVal := l3arg1z;
 curVal.m := curVal.m * [0,1,3,33..47];
 if (16384 >= curVal.i) then
     getValueOrAllocSymtab := curVal.i
 else
     getValueOrAllocSymtab :=
(*=c-*) allocSymtabForAbsolute((curVal.m + [24]) * halfWord.m);(*=c+*)
}; (* getValueOrAllocSymtab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(l3arg1z, l3arg2z: integer);
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z:word;
l3var5z:integer; l3var6z: word;
{
if l3arg1z = 0 then {
    formLabel;
    curVal.i := moduleOffset;
1:  l3var1z.m := curval.m * [33..47];
    curVal := curVal;
    besm(360050B);
    l3var3z:=;
    while l3arg2z <> 0 do {
        if 4096 < l3arg2z then {
            l3var4z.b := true;
            l3arg2z := l3arg2z - 4096;
        } else l3var4z.b := false;
        l3var2z := objBufBase[l3arg2z];
        if l3var4z.b then {
            curVal.m := l3var2z.m * [9..23];
            besm(360130B);
            curVal :=;
            curVal.m := curVal.m + intZero;
            l3var2z.m := l3var2z.m * [0..8,24..47] + l3var3z.m
        } else {
            curVal.m := intZero + l3var2z.m * [33..47];
            l3var2z.m := l3var2z.m * [0..32] + l3var1z.m;
        };
        objBufBase[l3arg2z] := l3var2z;
        l3arg2z := curVal.i;
    };
    exit;
} else if l3arg1z = 2 then {
    form1Insn(72400000B + curVal.i);
    if curVal.i = 30721 then
        form1Insn(72500000B + FcstCnt);
    form3Insn(139278, insnTemp[ESUBI] + l3arg2z, 34150001B);
    form1Insn(34000001B);
    exit;
} else if (l3arg1z = 1) or (l3arg1z < -2) then {
    l3arg2z := l3arg2z - curVal.i;
    l3var6z.i := getFCSToffset;
    if l3arg1z = 1 then
        l3var5z := getHelperProc(68) + (-64200000B)
    else
        l3var5z := -l3arg1z;
    curVal.i := l3arg2z;
    l3arg2z := getFCSToffset;
    form3Insn(74000001B, 40050000B + l3var6z.i, l3var5z);
    form3Insn( 40060000B + l3arg2z, l3var5z, 74100001B);
    exit;
} else if l3arg1z = -1 then {
    form1Insn(72400000B + lineCnt);
    formInsnAndLabel(getHelperProc(l3arg2z));
    exit;
};
curVal.i := l3arg1z;
goto 1;
}; (* P0715 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var dummy:array[1..14] of integer;
    l3var15z, l3var16z, l3var17z, l3var18z,
    l3var19z, l3var20z:integer;
procedure OBPROG(var start, fin: word); external;
{
l3var18z := pasinfor.listMode;
if (l3var18z <> 0) or (errsInLine <> 0) then
{
    write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
          lineCnt:5, lineNesting:3, commentModeCH);
    l3var19z := 13;
    if (S4 in optSflags.m)
       and (maxLineLen = 72)
       and (linePos >= 80) then {
       for l3var15z := 73 to 80 do write(lineBufBase[l3var15z]);
       write(' ');
       linePos := 73;
       l3var19z := 22;
    }; (* 1106 *)
    repeat linePos := linePos-1 
    until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
    for l3var15z to linePos do {
        output@ := lineBufBase[l3var15z];
        put(output);
    };
    writeln;
    if errsInLine <> 0 then {
        write('*****':l3var19z, ' ':errMapBase[0], '0');
        l3var20z := errsInLine - 1;
        for l3var15z to l3var20z do {
            l3var16z := errMapBase[l3var15z];
            l3var17z := errMapBase[l3var15z-1];
            if l3var16z <> l3var17z then {
                if l3var17z + 1 <> l3var16z then
                    write(' ':(l3var16z-l3var17z-1));
                write(chr(l3var15z + 48));
            }
        };
        writeln;
        errsInLine := 0;
        prevErrPos := 0;
    }
}; (* 1160 *)
if (l3var18z = 2) and (moduleOffset <> lineStartOffset) then {
    OBPROG(objBufBase[objBufIdx - moduleOffset + lineStartOffset],
           objBufBase[objBufIdx-1]);
}; (* 1174 *)
lineStartOffset := moduleOffset;
linePos := 0;
lineCnt := lineCnt + 1;
if eof (pasinput) then {
error(52);
goto 9999;
}
}; (* endOfLine *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(sym:symbol);
{
if linePos <> prevErrPos then
    error(ord(sym) + 88);
}; (* requiredSymErr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
{
while linePos < 81 do {
    linePos := linePos + 1;
    lineBufBase[linePos] := PASINPUT@;
    if linePos <> 81 then get(PASINPUT);
 };
 endOfLine
}; (* readToPos80 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol;
label 1473, 1, 2, 2175, 2233, 2320, 2334;
var l3var1z:array[0..130] of char;
l3var132z,l3var133z:integer;l3var134z:boolean;
l3var135z:@struc;
l3var136z, l3var137z:real;
l3var138z: char;
numstr:array [1..16]of word;
l3vars2:array [155..159]of word;
l3var160z,l3var161z:integer;
l3var162z:word;
chord:integer; l3var164z: integer;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
{
  repeat
    atEOL := eoln(PASINPUT);
    CH := PASINPUT@;
    get(PASINPUT);
    linePos := linePos + 1;
    lineBufBase[linePos] := CH;
  until (maxLineLen >= linePos) or atEOL;
}; (* nextCH *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment; label 1; (*workaround*)
var l4var1z, l4var2z: boolean; l4var3z: char;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var l5arg1z:integer; l5arg2z: integer);
{
    nextCH;
    l5arg1z := 0;
    while ('9' >= CH) and (CH >= '0') do {
        l5arg1z := 10 * l5arg1z + ord(CH) - ord('0');
        nextCH;
        l4var1z := false;
    };
    if l5arg2z < l5arg1z then l4var1z := true;
}; (* readOptVal *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var l5arg1z:boolean);
{
    nextCH;
    if (CH = '-') or (CH = '+') then {
        l5arg1z := CH = '+';
        l4var1z := false;
    };
    nextCH
}; (* readOptFlag *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseComment *)
    nextCH;
    if CH = '=' then {
        repeat nextCH;
        l4var1z := true;
        case CH of
        'D': {
             readOptVal(curVal.i, 15);
             optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
             };
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': {
             readOptFlag(l4var2z);
             if l4var2z then maxLineLen := 72 else maxLineLen := 120;
             };
        'S': {
             readOptVal(curVal.i, 9);
             if curVal.i = 3 then lineCnt := 1
             else if curVal.i in [4..9] then
                 optSflags.m := optSflags.m + [curVal.i-3]
             else {
                 extSymAdornment := curVal.i;
                 goto 1
             }; 1:; };
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        };
        if l4var1z then error(54);
        until CH <> ',';
    }; (* 1446 *)
    repeat while CH <> '*' do {
        l4var3z := commentModeCH;
        commentModeCH := '*';
        if atEOL then endOfLine;
        nextCH;
        commentModeCH := l4var3z;
    }; nextCH until CH = ')';
    nextCH;
}; (* parseComment *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (again) { (* inSymbol *)
    if inStringLit then {
        error(52);
        readToPos80;
        goto 9999;
    };
    1473: while (CH = ' ') and not atEOL do nextCH;
    if '_200' < CH then {
        lineBufBase[linePos] := ' ';
        chord := ord(CH);
        for l2var22z := 130 to chord do {
            linePos := linePos + 1;
            lineBufBase[linePos] := ' ';
        };
        nextCH;
        goto 1473;
    };
    if atEOL then {
        endOfLine;
        nextCH;
        if CH = '%' then while not atEOL do nextCH;
        goto 1473;
    };
    hashTravPtr := NIL;
    SY := charSymTabBase[CH];
    charClass := chrClassTabBase[CH];
    (lexer) if SY <> NOSY then {
    case SY of
        IDENT: { 1:
            curToken.m := [];
            l3var132z := 1;
            repeat
                curVal.c := psInfrCopy[CH];
                nextCH;
                if 8 >= l3var132z then {
                    l3var132z := l3var132z + 1;
                    curToken := curToken;
                    besm(360072B);
                    curToken:=;
                    curToken.m := curToken.m + curVal.m;
                };
            until chrClassTabBase[CH] <> ALNUM;
            curVal.m := curToken.m * hashMask.m;
            mapAI(curVal.a, bucket);
            curIdent := curToken;
            keywordHashPtr := kwordHashTabBase[bucket];
            while keywordHashPtr <> NIL do {
                if keywordHashPtr@.f[0] = curToken then {
                    SY := keywordHashPtr@.f[1].y;
                    charClass := keywordHashPtr@.f[2].o;
                    exit lexer;
                };
                keywordHashPtr := keywordHashPtr@.f[3].s;
                besm(2200000B);(*workaround*)
            };
            glob100z := false;
            SY := IDENT;
            case glob93z of
            0: {
               hashTravPtr := symHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                  if hashTravPtr@.f[1].i = curFrameRegTemplate then
                  {
                      if hashTravPtr@.f[0] <> curIdent then
                         hashTravPtr := hashTravPtr@.f[2].s
                      else {
                         glob100z := true;
                         exit lexer;
                      }
                  } else exit lexer; 
               };
            };
            1: { 2:
                hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    if hashTravPtr@.f[0] <> curIdent then
                      hashTravPtr := hashTravPtr@.f[2].s
                    else
                      exit lexer;
                };
            };
            2: {
                if glob63z = NIL then goto 2;
                glob62z := glob63z;
                l3var135z := typeHashTabBase[bucket];
                if l3var135z <> NIL then {
                  while glob62z <> NIL do {
                    l3var162z := glob62z@.f[3].p@;
                    hashTravPtr := l3var135z;
                    while hashTravPtr <> NIL do {
                        if (hashTravPtr@.f[0] = curIdent)
                        and (hashTravPtr@.f[6] = l3var162z) then
                            exit lexer;
                        hashTravPtr := hashTravPtr@.f[2].s;
                        besm(2200000B);
                    };
                    glob62z := glob62z@.f[2].s;
                  };
                }; goto 2; besm(3041704B); (* workaround *)
            };
            3: {
               hashTravPtr := typeHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                   with hashTravPtr@ do {
                       if (f[0] = curIdent) and
                          (glob121z = f[6].s) then exit lexer;
                       hashTravPtr := f[2].s;
                   }
               }
            };
            end;
        }; (* IDENT *)
        REALCONST: {
            nextCH;
            if charSymTabBase[CH] = IDENT then goto 1;
            if CH = '(' then SY := BEGINSY
            else if CH = ')' then SY := ENDSY
            else { SY := NOSY; exit };
            nextCH;
        }; (* REALCONST *)
        INTCONST: { (*=m-*)
            SY := INTCONST;
            l3var132z := 0;
            repeat
                l3var132z := l3var132z + 1;
                if (16 >= l3var132z) then
                    numstr[l3var132z].i := ord(CH)-ord('0')
                else {
                    error (55);
                    l3var132z := 1;
                };
                nextCH;
            until charSymTabBase[CH] <> INTCONST;
            (octdec) { if CH = 'B' then octalMode := chr(1)
            else if CH = 'C' then octalMode := chr(3)
            else if CH = 'T' then octalMode := chr(2)
            else { octalMode := chr(0); exit octdec; };
            nextCH;
            curToken.c := chr(0);
            for l3var133z to l3var132z do {
                if 7 < numstr[l3var133z].i then
                    error(20);
                curToken := curToken;
                besm(360075B);
                curToken:=;
                curToken.m := numstr[l3var133z].m * [45..47] +
                curToken.m;
            };
            if octalMode = chr(1) then {
                if curToken.m * [0..6] <> [] then {
                    error(43);
                    curToken.i := 1;
                } else curToken.m := curToken.m + intZero;
            } else if octalMode = chr(2) then {
                l3var164z := 16 - l3var132z;
                for l3var161z to l3var164z do {
                    curToken := curToken;
                    besm(360075B);
                    curToken :=;
                };
            } else; (* workaround *)
            exit lexer;    
            }; (* octdec *)
            curToken.i := 0;
            for l3var133z to l3var132z do {
                if 109951162777 >= curToken.i then 
                    curToken.i := 10 * curToken.i +
                        numstr[l3var133z].i
                else {
                    error(43);
                    curToken.i := 1;
                };
            };
            l3var161z := 0;
            if CH = '.' then {
                nextCH;
                if CH = '.' then { CH := ':'; exit lexer };
                curToken.r := curToken.i;
                SY := REALCONST;
                if charSymTabBase[CH] <> INTCONST then
                    error (56)
                else repeat
                    curToken.r := 10.0*curToken.r + ord(CH)-48;
                    l3var161z := l3var161z-1;
                    nextCH;
                    until charSymTabBase[CH] <> INTCONST;
            }; (*2062*)
            if CH = 'E' then {
                if l3var161z = 0 then {
                    curToken.r := curToken.i;
                    SY := REALCONST;
                };
                l3var134z := false;
                nextCH;
                if CH = '+' then nextCH else
                if CH = '-' then { l3var134z := true; nextCH }
                else; (* workaround *)
                l3var160z := 0;
                if charSymTabBase[CH] <> INTCONST then
                    error(57)
                else repeat
                    l3var160z := 10 * l3var160z + ord(CH) - 48;
                    nextCH
                until charSymTabBase[CH] <> INTCONST;
                if l3var134z then l3var161z := l3var161z-l3var160z
                else l3var161z := l3var161z+l3var160z;
            }; (* 2122 *)
            if l3var161z <> 0 then {
                l3var137z := 1.0;
                l3var134z := l3var161z < 0;
                l3var161z := abs(l3var161z);
                l3var136z := 10.0;
                if 18 < l3var161z then {
                    l3var161z := 1;
                    error(58);
                };
                repeat
                  if odd(l3var161) then
                    l3var137z := l3var137z * l3var136z;
                  l3var161z := l3var161z div 2;
                  if l3var161z <> 0 then
                     l3var136z := l3var136z*l3var136z;
                until l3var161z = 0;
                if l3var134z then curToken.r := curToken.r / l3var137z
                   else curToken.r := curToken.r * l3var137z;
            };
            exit lexer
        }; (* INTCONST *) (*=m+*)
        CHARCONST: {
            (loop) { for l3var133z := 6 to 130 do {
                nextCH;
                if charSymTabBase[CH] = CHARCONST then {
                    nextCH;
                    if charSymTabBase[CH] <> CHARCONST then
                        exit loop
                    else
                        goto 2233;
                };
                if atEOL then {
                    2175: error(59);
                    exit loop
                } else
                if ((CH = chr(35B)) or (charSymTabBase[CH] = REALCONST))
                   and (charSymTabBase[PASINPUT@] = INTCONST) then {
                    l3var160z := 0;
                    for l3var132z to 3 do {
                        nextCH;
                        if '7' < CH then error(60);
                        l3var160z := 8*l3var160z + ord(CH) - 48;
                    };
                    if 255 < l3var160z then error(60);
                    l3var1z[l3var133z] := chr(l3var160z);
                } else 2233: with PASINFOR do {
                    if charEncoding = 3 then {
                        if (ch < '*') or ('_176' < CH) then
                            l3var138z := chr(0)
                        else {
                            l3var138z := psInfrCopy[CH];
                            besm(3042246B); (*workaround*)
                            }
                    } else if '_176' < CH then {
                        l3var138z := CH;
                    } else if charEncoding = 0 then {
                        l3var138z := a0@[CH];
                    } else if charEncoding = 1 then {
                        l3var138z := a1@[CH];
                    } else if charEncoding = 4 then {
                        l3var138z := a4@[CH];
                    } else {
                        l3var138z := CH;
                        besm(3042273B) (* workaround*)
                    };
                    l3var1z[l3var133z] := l3var138z;
                };
            }; goto 2175 };
            glob76z := l3var133z - 6;
            if glob76z = 0 then {
               error(61); glob76z := 1; goto 2320 }
            else if glob76z = 1 then {
                SY := CHARCONST;
                l3var132z := 1;
                curToken.c := chr(0);
                unpck(l3var1z[0], curToken.a);
                pck(l3var1z[l3var132z], curToken.a);
                exit lexer;
            } else 2320: {
               curVal.a := '      ';
               SY := LTSY;
               unpck(l3var1z[l3var133z], curVal.a);
               pck(l3var1z[6], curToken.a);
               curVal :=;
               if 6 >= glob76z then exit lexer else {
                   curToken.i := FcstCnt;
                   l3var132z := 6;
                   2334: {
                     toFCST;
                     l3var132z := l3var132z + 6;
                     if l3var133z < l3var132z then exit lexer;
                     pck(l3var1z[l3var132z], curVal.a);
                     goto 2334;
                   }
               }
            };
%            goto 2334; (* doesn't help here as a workaround *)
        }; (* CHARCONST *)
        LTSY: {
            SY := RELOP;
            nextCH;
            if CH = '>' then { charClass := NEOP; nextCH }
            else if CH = '=' then { charClass := LEOP; nextCH }
        }; (* LTOP *)
        GTSY: {
            SY := RELOP;
            nextCH;
            if CH = '=' then { charClass := GEOP; nextCH }
        }; (* GTOP *)
        LPAREN: {
            nextCH;
            if CH = '*' then { parseComment; goto 1473 } 
        };
        COLON: {
            nextCH;
            if CH = '=' then {
                nextCH; SY := BECOMES; charClass := NOOP
            }
        };
        NOTSY, LBRACK, MULOP, ADDOP, RELOP, RPAREN, RBRACK,
        COMMA, SEMICOLON, ARROW: {
            nextCH;
        };
        PERIOD: {
            nextCH;
            if CH = '.' then {
                nextCH;
                SY := COLON;
                charClass := NOOP
            } else {
                if glob56z = ENDSY then inStringLit := true;
            }
        };
    end (* case *)
    } else { (* 2444 *)
        nextCH;
    };
    glob56z := SY;
    if not pseudoZ and not (DebugCode in optSflags.m) then {
        commentModeCH := '=';
        goto again;
    };
    commentModeCH := ' ';
    glob93z := glob92z;
} }; (* inSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skipToEnd;
var l4var1z:symbol;
{
   l4var1z := SY;
   while (l4var1z <> ENDSY) or (SY <> PERIOD) do {
       l4var1z := SY;
       inSymbol
   };
   if CH = 'D' then while SY <> ENDSY do inSymbol;
   goto 9999;
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* error *)
    errors := true;
    glob110z :=;
    if ((linePos <> prevErrPos) and (9 >= errsInLine))
    or (errno = 52) then {
        write(' '); totalErrors := totalErrors + 1;
        errMapBase[errsInLine] := linePos;
        errsInLine := errsInLine + 1;
        prevErrPos := linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if 60 < totalErrors then {
            writeln; endOfLine;
            printErrMsg(53);
            skipToEnd
        }
    }
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skip(toset:setofsys);
{
while not (SY IN toset) do inSymbol;
}; (* skip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure test1(sym:symbol; toset: setofsys);
{
   if (SY <> sym) then {
     requiredSymErr( sym );
     skip( toset )
   } else inSymbol;
}; (* test1 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure errAndSkip(errno:integer; toset:setofsys);
{
   error( errno );  skip( toset )
}; (* errAndSkip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLiteral(var l3arg1z:struc; var l3arg2z:word;
    l3arg3z:boolean);
label 99;
var l3var1z:operator;
{
 l3arg2z := curToken;
 if (GTSY < SY) then {
     if l3arg3z and (charClass IN [PLUSOP,MINUSOP]) then {
        l3var1z := charClass;
        inSymbol;
        parseLiteral( l3arg1z, l3arg2z, false );
        if (l3arg1z.f[0].s <> integerType) then {
           error( 62 );
           l3arg1z.f[0].s := integerType;
           l3arg2z.i := 1;
        } else {
           if (l3var1z = MINUSOP) then l3arg2z.i := -l3arg2z.i;
        };
    } else 99: {
       l3arg1z.f[0].p := NIL;
       error( 6 );
    }
  } else  case SY of
 IDENT: {
 if (hashTravPtr = NIL) or
    (hashTravPtr@.f[4].y <> INTCONST) then goto 99;
  l3arg1z.f[0] := hashTravPtr@.f[3];
  l3arg2z := hashTravPtr@.f[6];
  };
INTCONST:
 l3arg1z.f[0].s := integerType;
 REALCONST:
 l3arg1z.f[0].s := realType;
 CHARCONST:
 l3arg1z.f[0].s := charType;
 LTSY:
     assignType( l3arg1z );
 GTSY: {
     l3arg1z.f[0].s := pointerType;
     l3arg2z.p := NIL;
 };
 end (* case *)
}; (* parseLiteral *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P2672(var l3arg1z: struc; l3arg2z: @struc);
var l3var1z: boolean; l3var2z: integer;
l3var3z,l3var4z:@struc;
{
 if l3arg1z.f[0].p = NIL then {
 curVal.m := l3arg2z@.f[0].m * hashMask.m;
 mapAI(curVal.a, l3var2z);
 l3var1z := true;
 l3arg1z.f[0].s := symHashTabBase[l3var2z];
 } else {
 l3var1z := false;
 };
 if (l3arg1z.f[0].s = l3arg2z) then {
   if (l3var1z) then {
     symHashTabBase[l3var2z] :=
         symHashTabBase[l3var2z]@.f[2].s;
   } else {
     l3arg1z.f[0] := l3arg2z@.f[2];
   };
 } else {
   l3var3z := l3arg1z.f[0].s;
   while (l3var3z <> l3arg2z) do {
     l3var4z := l3var3z;
     if (l3var3z <> NIL) then {
        l3var3z := l3var3z@.f[2].s;
     } else {
        exit
     }
   };
   l3var4z@.f[2] := l3arg2z@.f[2];
 }
}; (* P2672 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr:@struc):boolean;
{ isFileType := (typtr@.f[2].c = chr(7)) or
    (typtr@.f[2].c = chr(6)) and
    typtr@.f[5].b;
}; (* isFileType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F2751(var l3arg1z:struc):boolean;
{
 if (l2var2z.s <> NIL) then {
  l3arg1z.f[0].s := l2var2z.s;
  while (l3arg1z.f[0].s <> NIL) do {
    if (l3arg1z.f[0].p@ = curIdent) then {
        F2751 := true;
        exit
    };
    l3arg1z.f[0] := l3arg1z.f[0].s@.f[2];
    besm(2200000B); (* workaround *)
  }
 };
 F2751 := false;
}; (* F2751 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkSymAndRead(sym: symbol);
{
 if (SY <> sym) then requiredSymErr( sym )
 else inSymbol
}; (* checkSymAndRead *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function typeCheck(l3arg1z, l3arg2z: @struc):boolean;
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z, l3var5z,
    l3var6z, l3var7z, l3var8z, l3var9z, l3var10z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure allocWithTypeCheck;
{
 new(l3var4z.p=3);
 with l3var4z.s@ do {
     f[0].p := glob133z;
     f[1] := l3var5z;
     f[2] := l3var6z;
 };
 glob133z := l3var4z.p;
 typeCheck :=  typeCheck    ( l3var5z.s, l3var6z.s );
 }; (* allocWithTypeCheck *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3020(l4arg1z, l4arg2z: @struc):boolean;
var l4var1z: boolean;
{
 l4var1z := (l4arg1z = NIL) or (l4arg2z = NIL);
 if (l4var1z) then {
     F3020 := l4arg1z = l4arg2z;
 } else {
 F3020 := typeCheck(l4arg1z@.f[3].s, l4arg2z@.f[3].s) and
          F3020(l4arg1z@.f[5].s, l4arg2z@.f[5].s);
 };
 }; (* F3020 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* typeCheck *)
 glob105z := false;
 if (l3arg1z@.f[2].c = chr(2)) then {
 glob120z := l3arg1z@.f[3].s;
 } else {
 glob120z := l3arg1z;
 };
 if not checkTypes or (l3arg1z = l3arg2z) then
    1: typeCheck := true
 else with l3arg1z@ do {
 l3var2z := f[2];
 l3var3z := l3arg2z@.f[2];
 if (l3var2z = l3var3z) then {
 case l3var2z.c of
  '_000':;
  '_001': {
  (chain) if (l3arg1z@.f[4] = l3arg2z@.f[4]) then {
     l3var7z := l3arg1z@.f[3];
     l3var8z := l3arg2z@.f[3];
     while (l3var7z.p <> NIL) and (l3var8z.p <> NIL) do {
         if (l3var7z.s@.f[0] <> l3var8z.s@.f[0]) then
             exit chain;
         l3var7z := l3var7z.s@.f[5];
         l3var8z := l3var8z.s@.f[5];
     };
     if (l3var7z.p = NIL) and (l3var8z.p = NIL) then goto 1;
  }
 };
 '_002': {
  l3var1z.b := (l3arg1z@.f[3] = l3arg2z@.f[3]);
 glob120z := l3arg1z@.f[3].s;
 glob105z := (l3arg1z@.f[5] <> l3arg2z@.f[5]) or
             (l3arg1z@.f[6] <> l3arg2z@.f[6]);
 typeCheck := l3var1z.b;
 exit
 };
 '_003': {
     if (l3arg1z = pointerType) or (l3arg2z = pointerType) then
         goto 1;
     l3var5z := l3arg1z@.f[3];
     l3var6z := l3arg2z@.f[3];
     if (glob133z <> NIL) then {
         l3var4z.p := glob133z;
         while (l3var4z.p <> NIL) do with l3var4z.s@ do {
             if (f[1] = l3var5z) and
                (f[2] = l3var6z) or
                (f[2] = l3var5z) and
                (f[1] = l3var6z) then goto 1;
             l3var4z := f[0];
         };
         allocWithTypeCheck;
     } else {
         setup(l3arg1z);
         allocWithTypeCheck;
         glob133z := NIL;
         rollup(l3arg1z);
         exit
     }
 };
 '_004': goto 1;
 '_005': {
     with l3arg1z@.f[4].s@ do l3var9z.i := f[6].i - f[5].i;
     with l3arg2z@.f[4].s@ do l3var10z.i := f[6].i - f[5].i;

 if typeCheck( l3arg1z@.f[3].s, l3arg2z@.f[3].s) and
    (l3var9z = l3var10z) and
    (l3arg1z@.f[5] = l3arg2z@.f[5]) and not glob105z then {
       if l3arg1z@.f[5].b then {
           if (l3arg1z@.f[7] = l3arg2z@.f[7]) then goto 1
       } else goto 1
 } 

 };
 '_007': {
    if typeCheck( l3arg1z@.f[3].s, l3arg2z@.f[3].s ) then
        goto 1;
 };
 '_006': {
     if F3020( l3arg1z@.f[4].s, l3arg2z@.f[4].s ) then
         goto 1;
 }
 end (* case *)
 } else {
     if (l3var2z.c = chr(2)) then {
         glob105z := true;
         glob120z := l3arg2z;
         if (l3arg1z@.f[3].s = l3arg2z) then goto 1;
     } else if (l3var3z.c = chr(2)) and
               (l3arg1z = l3arg2z@.f[3].s) then goto 1;
     
     };
     typeCheck := false;
 }
}; (* typeCheck *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3307(l3arg1z: @struc):integer;
var l3var1z:integer; l3var2z:@struc;
{
 l3var2z := l3arg1z@.f[7].s;
 l3var1z := 0;
 if (l3var2z <> NIL) then while (l3var2z <> l3arg1z) do {
     l3var1z := l3var1z + 1;
     l3var2z := l3var2z@.f[5].s;
 };
 F3307 := l3var1z;
 }; (* F3307 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeNameWithStars(l3arg1z:boolean):word;
var l3var1z: boolean;
{
 l3var1z := not l3arg1z and (extSymAdornment = 0);

 if curVal.m * [0..5] = [] then {
     curVal := curVal; besm(360072B); curVal := ;
     if l3var1z or (extSymAdornment = 1) then
         curVal.m := curVal.m + [44,46];
     while curVal.m * [0..11] = [] do {
         curVal := curVal; besm(360072B); curVal := ;
     };

     if curVal.m * [0..5] = [] then {
         if l3var1z then 
             curVal.m := [2,4] + curVal.m
         else {
           curVal := curVal; besm(360072B); curVal := ;
        }
     }
 };
 makeNameWithStars := curVal;
 }; (* makeNameWithStars *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formOperator(l3arg1z: word);
var l3var1z, l3var2z: word;
l3var3z, l3var4z, l3var5z,
l3var6z, l3var7z, l3var8z, l3var9z, l3var10z,
l3var11z: word; l3var12z: @struc; l3var13z, l3var14z:word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  genOneOp;
label 3556;
var l4var1z:integer;
l4var2z,l4var3z,l4var4z:integer;l4var5z:word;
l4var6z, l4var7z, l4var8z: @struc;  l4var9z: integer;
insnBuf: array[1..200] of word;
l4var210z:word; l4var211z:word; l4var212z: @struc;
l4var213z: boolean;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3363;
{
 if l4var213z then
    form1Insn    ( insnTemp[AMX] )
 else
    form1Insn    (04100010B )
 }; (* P3363 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  addInsnToBuf(l5arg1z:integer);
{
 insnBuf[l4var1z].i := l5arg1z;
 l4var1z := l4var1z + 1;
 }; (* addInsnToBuf *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure add2InsnsToBuf(l5arg1z, l5arg2z: integer);
{
 insnBuf[l4var1z].i := l5arg1z;
 insnBuf[l4var1z+1].i := l5arg2z;
 l4var1z := l4var1z + 2;
}; (* add2InsnsToBuf *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3413:boolean;
{
 l4var7z := l4var6z;
 while l4var7z <> NIL do {
     if (l4var7z@.f[1].i = l4var210z.i) then {
         F3413 := true;
         while (l4var7z@.f[2].i = 100000000B) do {
             l4var7z := ptr(l4var7z@.f[3].i);
         };
         exit
     } else {
         l4var7z := l4var7z@.f[0].s;
     }
 };
 F3413 := false;
}; (* F3413 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3436(l5arg1z:integer);
{
 if not F3413 then {
     new(l4var7z=4);
     l4var7z@.f[0].s := l4var6z;
     l4var7z@.f[1].i := l4var210z.i;
     l4var7z@.f[2].i := 0;
     l4var7z@.f[3].i := 0;
     l4var6z := l4var7z;
 };
 addInsnToBuf( (100000000B + l5arg1z) + ord(l4var7z) )
 }; (* P3436 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genOneOp *)
    if insnList = NIL then exit;
    glob145z.m := glob145z.m + insnList@.f[3].m;
    l4var212z := insnList@.f[1].s;
    l4var9z := 370007B;
    l4var1z := 1;
    if l4var212z = NIL then exit;
    l4var6z := NIL;
    while l4var212z <> NIL do {
        l4var211z.i := l4var212z@.f[2].i;
        l4var4z := l4var211z.i - 100000000B;
        l4var210z.i := l4var212z@.f[3].i;
        case l4var212z@.f[1].i of
        0:;
        1: if arithMode <> 1 then {
               addInsnToBuf(370007B);
               arithMode := 1
           };
        2: arithMode := 1;
        3: if arithMode <> 2 then {
              addInsnToBuf(insnTemp[ASN]);
              arithMode := 2;
           }; 
        4: arithMode := 2;
        end; (* case *)
        l4var212z := l4var212z@.f[0].s;
        if l4var4z >= 0 then {
            case l4var4z of
            23: add2InsnsToBuf(00220000B, 04120011B);
            21: goto 3556;
            0: P3436(insnTemp[UZA]);
            1: P3436(insnTemp[U1A]);
            2: {
                l4var211z.i := l4var210z.i mod 4096;
                l4var210z.i := l4var210z.i div 4096;
                P3436(insnTemp[UJ]);
                l4var210z.i := l4var211z.i;
                3556:
                    if F3413 then
                        addInsnToBuf(ord(l4var7z) + 200000000B)
                    else error(206);
            };
            3: {
                 l4var211z.i := l4var210z.i mod 4096;
                 l4var210z.i := l4var210z.i div 4096;
                 l4var213z :=  F3413;
                 l4var8z := l4var7z;
                 l4var210z.i := l4var211z.i;
                 l4var213z := l4var213z & F3413;
                 if l4var213z then with l4var7z@ do {
                     f[2].i := 100000000B;
                     f[3].i := ord(l4var8z);
                 } else error(207);
             };
            20: addInsnToBuf(300000000B + l4var210z.i);
            4: {
             if insnBuf[l4var1z-1].m * [21:23,28:35] = []  then 
                 insnBuf[l4var1z-1].m := insnBuf[l4var1z-1].m + [35]
             else 
                 addInsnToBuf(74100000B)
            };
            5: (blk) {
                if l4var212z <> NIL then { 
                   l4var211z := l4var212z@.f[2];
                   if l4var211z.m * [21:23,28:35] = [32] then {
                       l4var212z@.f[2].i :=
                        l4var211z.i - insnTemp[AMX] + insnTemp[OP002];
                        exit blk
                    }
                };
                addInsnToBuf(74000000B);
           };
           6: add2InsnsToBuf(400016B, 72200000B );
           7: addInsnToBuf( getHelperProc(12)); (* P/MI *)
           8: add2InsnsToBuf(76300000B, 02500000B+
                             glob398z[l4var210z.i]);
           9: add2InsnsToBuf(400016B, 70450000B + l4var210z.i);
           10:add2InsnsToBuf(04110010B, 04120011B);
           11:{addInsnToBuf(04040023B);(*round*)
                add2InsnsToBuf(370007B, 04040011B)};
           12:add2InsnsToBuf(74000000B,74170000B);(*sqr*)
           13:{add2InsnsToBuf(74000000B, 04120012B);(*sqrint*)
                add2InsnsToBuf(74170000B, 0310100B)};
           14:add2InsnsToBuf(glob398z[l4var210z.i] + 02400000B,
                              0420000B + l4var210z.i);
           15:add2InsnsToBuf(04230011B, 04050021B); (* minel *)
           16:add2InsnsToBuf(insnTemp[AMX], 74000000B + l4var210z.i);
           17:{addInsnToBuf( 0030000B);
                add2InsnsToBuf(74000001B, 76500000B + l4var210z.i)};
           18:add2InsnsToBuf(52400000B,getHelperProc(65)); (*P/B7*)
           19:{addInsnToBuf(72400000B);
                add2InsnsToBuf(74100000B, 70000000B)};
           22:{add2InsnsToBuf(72400000B, 70100000B);
                curVal.i := 40077777C;
                add2InsnsToBuf(allocSymtabForAbsolute(curVal)+74030000B,
                               40110000B + l4var210z.i);
                add2InsnsToBuf(74120000B, 70000000B)};
            end; (* case *)
        } else { (* 4003 *)
            if 28 in l4var211z.m then {
              addInsnToBuf(getValueOrAllocSymtab(l4var210z)+l4var211z.i);
            } else {
              curval.i := l4var210z.i mod 32768;
              if curVal.i < 2048 then
                  addInsnToBuf(l4var211z.i + l4var210z.i)
              else if (curVal.i >= 28672) or (curVal.i < 4096) then {
              (*=c-*)
                 addInsnToBuf(
                   allocSymtabForAbsolute((curVal.m + [24])*halfWord.m)
                              + l4var211z.i - 28672);
              (*=c+*)
              } else {
                 add2InsnsToBuf(getValueOrAllocSymtab(curVal)
                                + insnTemp[UTC], l4var211z.i );
                 besm(3044036B); (*workaround*)
              }
            }
        }
    }; (* 4037 *)
    l4var1z := l4var1z-1;
    for l4var4z := l4var1z downto 1 do {
        l4var210z := insnBuf[l4var4z];
        if (l4var210z.i = insnTemp[ASN]) or
           (l4var210z.i = 370007B) then {
            l4var3z := l4var4z - 1;
            l4var213z := false;
            (loop) while l4var3z >= 1 do {
                l4var211z.m := insnBuf[l4var3z].m * [28:32];
                if (l4var211z.m # [28,31])and(l4var211z.m # [28,31,32])
                then exit loop else l4var3z := l4var3z-1;
            };
            l4var3z := l4var3z + 1;
            if (l4var3z <> l4var4z) then {
                for l4var2z := l4var4z-1 downto l4var3z do {
                    insnBuf[l4var2z+1] := insnBuf[l4var2z]
                };
            };
            insnBuf[l4var3z] := l4var210z;
        }; (* 4103 *)
    };
    for l4var4z to l4var1z do (iter) {
        l4var210z := insnBuf[l4var4z];
        l4var211z.m := l4var210z.m * [0,1,3,23:32];
        if l4var211z.i = 74000000B then {
            l4var2z := l4var4z + 1;
            while l4var1z + 1 <> l4var2z do {
                curVal.m := insnBuf[l4var2z].m * [0,1,3,23,28:35];
                l4var211z.m := curVal.m * [0,1,3,23,28:32];
                if curVal.i = insnTemp[AMX] then {
                   insnBuf[l4var2z].m :=
                       insnBuf[l4var2z].m mod [32,34,35];
                   exit iter;
                } else if curVal.i = insnTemp[STI] then {
                    insnBuf[l4var2z].m := insnBuf[l4var2z].m + [35];
                    exit iter;
                } else if (curVal.i = insnTemp[ASN]) or
                    (l4var211z.i = insnTemp[UTC]) or
                    (l4var211z.i = insnTemp[WTC]) or
                    (l4var211z.i = insnTemp[VTM]) then
                        l4var2z := l4var2z + 1
                    else
                        l4var2z := l4var1z + 1;
                    
            };
        }; (* 4150 *)
        if l4var210z.i = insnTemp[UTC] then exit iter;
        if l4var210z.i < 100000000B then {
             form1Insn( l4var210z.i );
             l4var211z.m := l4var210z.m * [28:32];
              if (l4var211z.m = [28,29,32]) or
              (l4var211z.m = [30,32]) then {
                  formLabel;
                  glob95z.i := 1;
              };
              exit iter;
        };
        if (l4var210z.i >= 300000000B) then {
            l4var210z.i := l4var210z.i - 300000000B;
             if l4var210z.i >= 4096 then {
                 l4var213z := true;
                 l4var210z.i := l4var210z.i - 4096;
             } else {
                 l4var213z := false;
             };
             if (l4var210z.i = 0) then
                 form1Insn(insnTemp[UZA] + moduleOffset + 2);
             P3363;
             form1Insn(insnTemp[UJ] + 2 + moduleOffset);
             formLabel;
 if (l4var210z.i <> 0) then {
     if (not F3413) then error(211);
     P0715(0, l4var7z@.f[2].i);
 };
 l4var213z := not l4var213z;
 P3363;
 formLabel;
 exit iter
     }; (* 4230 *)
 if (l4var210z.i >= 200000000B) then {
    l4var7z := ptr(l4var210z.i - 200000000B);
    P0715(0, l4var7z@.f[2].i );
    l4var7z@.f[3].i := moduleOffset;
  } else {
 l4var210z.i := l4var210z.i - 100000000B;
 curVal.m := l4var210z.m * [0,1,3,28:32];
 glob51z := curVal;
 curVal.m := [0,1,3,33:47] * l4var210z.m;
 l4var7z := ptr(curVal.i);
 formJumpOnCond(l4var7z@.f[2].i );
 glob51z.i := insnTemp[UJ];
 exit iter
}
    }; (* loop *)
    insnList := NIL;

 while (l4var6z <> NIL) do { 
    with l4var6z@ do 
    if (f[3].i = 0) then {
    jumpTarget := f[2];
    exit;
 } else 
   l4var6z := f[0].s;
 };
 glob146z.m := glob146z.m - glob145z.m;
}; (* genOneOp *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToInsnList(l4arg1z:integer);
var l4var1z:@struc;
{
 new(l4var1z=4);
 with l4var1z@ do {
     f[0].s := NIL; f[1].i := 0;
     f[2].i := l4arg1z; f[3].i := 0;
 };
 with insnList@ do {
     if f[0].s = NIL then f[1].s := l4var1z
     else f[0].s@.f[0].s := l4var1z;
     f[0].s := l4var1z
 }
}; (* addToInsnList *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addInsnAndModify(l4arg1z,l4arg2z:integer);
{
 addToInsnList(l4arg1z);
 insnlist@.f[0].s@.f[3].i := l4arg2z
}; (* addInsnAndModify *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addxToInsnList(l4arg1z: integer);
var l4var1z:@struc;
{
 new(l4var1z=4);
 with l4var1z@ do {
 f[0] := insnList@.f[1];
 f[1].i := 0;
 f[2].i := l4arg1z;
 f[3].i := 0;
 };
 if (insnList@.f[1].s = NIL) then {
     insnList@.f[0].s := l4var1z;
 };
 insnList@.f[1].s := l4var1z;
}; (* addxToInsnList *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4343;
label 4545,4602;
var l4var1z,l4var2z,l4var3z,l4var4z,l4var5z,
l4var6z,l4var7z,l4var8z,l4var9z:word;
{
l4var4z := insnList@.f[2];
with insnList@ do {
 case f[4].c of
 '_000':{
     curVal := f[5];
     if (l4var4z.s@.f[0].i = 1) then
         curVal.i := getFCSToffset;
     addToInsnList(constRegTemplate.i + curInsnTemplate.i + curVal.i);
 };
 '_001':{
     l4var1z := insnList@.f[7];
     l4var2z := insnList@.f[5];
     l4var3z := insnList@.f[6];
     if (15 < l4var1z.i) then { } else {
       if (l4var1z.i = 15) then {
              addToInsnList(100000006B );
       } else {
          l4var1z.i := glob398z[insnList@.f[7].i];
          if (l4var2z.i = 0) and (insnList@.f[8].c = '_000') then {
             addInsnAndModify(l4var1z.i+curInsnTemplate.i, l4var3z.i);
             goto 4602;
          } else {
             addToInsnList(l4var1z.i + insnTemp[UTC]);
             (a) besm(3044411B);
          }
       }
     };
     l4var6z := insnList@.f[8];
     if l4var6z.c = '_000' then {
         addInsnAndModify(l4var2z.i + curInsnTemplate.i, l4var3z.i);
     } else {
         l4var5z := l4var4z.s@.f[2];
         if (l4var5z.c < '_004') or 
         (l4var5z.c = '_006') and (s6 in optSflags.m) then {
         l4var7z.b := true;
         l4var8z.b :=  typeCheck( l4var4z.s, integerType );
         } else {
            l4var7z.b := false;
            l4var8z.b := false;
         };
         if l4var6z.c = '_001' then {
            if (l4var3z <> l4var2z) or
               (l4var1z.i <> 18) or
               (l4var2z.i <> 0) then
               addInsnAndModify(l4var2z.i + insnTemp[AMX], l4var3z.i);
            l4var3z := insnList@.f[10];
            l4var2z := insnList@.f[9];
            l4var9z.b := true;
            l4var1z.i := (l4var3z.i + l4var2z.i);
            if l4var7z.b then { 
                if (30 < l4var3z.i) then {
               addToInsnList( 360020B + l4var3z.i );
               addToInsnList( insnTemp[RTE] );
               if (l4var1z.i = 48) then l4var9z.b := false;
             } else {
              if (l4var3z.i <> 0) then
                 addToInsnList( ASN64 + l4var3z.i);
             }; (* 4477 *)
             if l4var9z.b then {
             curVal.m := [(48 - l4var2z.i)..47];
             addToInsnList(40110000B + getFCSToffset);
             }
        } else { (* 4511 *)
          if (l4var1z.i <> 48) then
              addToInsnList(360020B + l4var1z.i);
          curVal.m := [0..(l4var2z.i-1)];
          addToInsnList(40110000B + getFCSToffset);
        }; (* 4525 *)
        if l4var8z.b then addToInsnList(04120011B);
        } else { (* 4531 *)
            if l4var7z.b then
             l4var1z.i := ord(l4var8z.b)+74
             else l4var1z.i := 56;
             addToInsnList( getHelperProc ( l4var1z.i )  );
             insnList@.f[0].s@.f[1].i := 1;
        }
     };
     goto 4545;
 };
 '_002': { 4545:
     if glob49z and (l4var4z.s = booleanType) and
     (16 in insnList@.f[3].m) then addToInsnList(04120010B);
 };
 '_003': { (* 4555 *)
 if glob49z then 
  addInsnAndModify (100000024B,
     ord(16 in insnList@.f[3].m)*10000B+insnList@.f[5].i);
 };
 end; (* case *) 4602:
}; (* with*)
with insnList@ do {
 f[4].c := '_002';
 f[3].m := f[3].m + [0];
};
}; (* P4343 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4606;
{ P4343;
addToInsnList(100000005B)
}; (* P4606 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4621(l4arg1z:integer);
label 4650, 4654;
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
l4var6z, l4var7z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4613;
{
 l4var1z := insnList@.f[6];
 l4var1z.i := l4var1z.i mod 32768;
 l4var6z := l4var1z
}; (* P4613 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P4621 *)
with insnList@ do {
 l4var2z := f[7];
 l4var3z.i := insnTemp[VTM];
 l4var7z.i := glob398z[l4arg1z];
 l4var4z := f[5];
 f[3].m := f[3].m + [l4arg1z];
 if (f[4].c = '_000') then {
 curVal := f[5];
 if (f[2].s@.f[0].i = 1) then curVal.i := addSomethingToFCST;
 l4var6z := curVal;
 l4var5z.i := 30721;
 goto 4654;
 } else if (l4var2z.i = 18) then {
     4650: P4613;
     if (l4var4z.i = glob398z[1]) then {
     l4var5z.i := 30723;
     4654: l4var1z.i := 100000000B * l4var5z.i + l4var6z.i;
     l4var6z := (*=c-*)allocSymtabForAbsolute
     (l4var1z.m * [12:47]); (*=c+*)
     addToInsnList(l4var7z.i + l4var3z.i + l4var6z.i);
     } else if (l4var4z.i <> 0) then {
       addInsnAndModify(l4var4z.i + insnTemp[UTC], l4var6z.i );
       addToInsnList(l4var7z.i + l4var3z.i);
     } else {
       addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i );
     }
 } else if (l4var2z.i = 17) then {
     P4613;
     l4var4z := insnList@.f[6];
     l4var5z.i := insnList@.f[0].s@.f[2].i - insnTemp[UTC];
     if (l4var4z.i <> 0) then {
       l4var1z.i := 100000000B * l4var5z.i + l4var4z.i;
       l4var5z.i :=
         (*=c-*)allocSymtabForAbsolute(l4var1z.m * [12:47]);
         (*=c+*)
 };
 insnList@.f[0].s@.f[2].i := l4var7z.i + l4var5z.i + l4var3z.i;
 } else  if (l4var2z.i = 16) then {
    P4613;
    if (l4var4z.i <> 0) then
       addToInsnList(l4var4z.i + insnTemp[UTC]);
    addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i);
 } else if (l4var2z.i = 15) then {
    addToInsnList(insnTemp[NTR] + l4arg1z );
    l4var3z.i := insnTemp[UTM];
    goto 4650;
 } else {
    addToInsnList(glob398z[l4var2z.i] + insnTemp[UTC]);
    goto 4650;
 }
 }; (* with *)
 insnList@.f[4].b := true;
 insnList@.f[7].i := l4arg1z;
 insnList@.f[6].i := 0;
 insnList@.f[5].i := 0;
}; (* P4621 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4755; 
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z, l4var6z, l4var7z: word;
{
with insnList@ do l4var1z := f[7];
if (15 < l4var1z.i) then {
 (* nothing? *)
 } else if (l4var1z.i = 15) then {
   addToInsnList( 100000006B )
 } else {
   addToInsnList(glob398z[l4var1z.i] + insnTemp[UTC]);
};
 l4var4z.b := 0 in insnList@.f[3].m;
 l4var6z := insnList@.f[8];
 if (l4var6z.c <> '_000') or l4var4z.b then 
     addxToInsnList(100000005B );
 if (l4var6z.c = '_000') then {
 if (l4var4z.b) then { 
    addInsnAndModify(insnList@.f[5].i + insnTemp[UTC], insnList@.f[6].i);
    addToInsnList( 100000023B );
 } else {
    addInsnAndModify( insnList@.f[5].i, insnList@.f[6].i );
 }
 } else {
     l4var7z := insnList@.f[2].s@.f[2];
     l4var1z := insnList@.f[2].s@.f[1];
     l4var5z.b := (l4var7z.c < '_004') or
         (l4var7z.c = '_006') and (S6 in optSflags.m);
     if (l4var6z.c = '_001') then {
       l4var2z := insnList@.f[10];
       l4var3z.i := (l4var2z.i + insnList@.f[9].i);
       if l4var5z.b then {
         if (l4var2z.i <> 0) then addxToInsnList(ASN64 - l4var2z.i);
       } else {
         if (l4var3z.i <> 48) then addxToInsnList(360160B - l4var3z.i);
       };
       addInsnAndModify(insnTemp[UTC] + insnList@.f[5].i, insnList@.f[6].i );
       curVal.m := [0..47]-[(48-l4var3z.i)..(47 -l4var2z.i)];
       addInsnAndModify(100000026B, getFCSToffset  );
     }  else {
        if not l4var5z.b then {
          l4var2z.i := (insnList@.f[9].i - l4var1z.i);
          if (l4var2z.i <> 0) then addxToInsnList(ASN64 - l4var2z.i);
          addxToInsnList( insnTemp[RTE] );
          addxToInsnList(ASN64 - l4var1z.i);
        };
        addToInsnList(getHelperProc (77)); (* "P/STAR" *)
        insnList@.f[0].s@.f[1].i := 1;
     }
   }
}; (* P4755 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 procedure P5117(l4arg1z: word);
 {
     addInsnAndModify( curFrameRegTemplate, l2var20z );
     new(curExpr=4);
     with curExpr@ do f[0] := insnList@.f[2];
     genOneOp;
     curExpr@.f[1] := l4arg1z;
     curExpr@.f[2].i := l2var20z;
     l2var20z := l2var20z + 1;
     if (l2var21z < l2var20z) then l2var21z := l2var20z;
 }; (* P5117 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F5142: integer;
var l4var1z:integer; l4var2z:@struc;
{
 l4var1z := 0;
 l4var2z := insnList@.f[1].s;
 while (l4var2z <> NIL) do {
     l4var2z := l4var2z@.f[0].s;
     l4var1z := l4var1z + 1;
 };
  F5142 := l4var1z;
}; (* F5142 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genFullExpr(l4arg1z:word);
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
    l4var6z, l4var7z,l4var8z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5155;
{
  P4343;
 insnList@.f[4].b := true;
 insnList@.f[8].b := false;
 insnList@.f[6].i := 0;
 insnList@.f[5].i := 0;
 insnList@.f[7].i := 18;
}; (* P5155 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5170;
label 5220;
var l5var1z, l5var2z:word; l5var3z: boolean;
{
l5var3z := checkBounds and not (NoPtrCheck in optSflags.m)
   and ( l4var6z.c = '_042');
 if not l5var3z and (
  (insnList@.f[8].c = '_000') or
    (insnList@.f[8].c = '_001') and
    (insnList@.f[10].i = 0)) then {
     l5var1z := insnList@.f[7];
     l5var2z := insnList@.f[6];
     if (l5var1z.i = (18)) or (l5var1z.i = (16)) then {
     5220: addInsnAndModify ( (insnList@.f[5].i + insnTemp[WTC]), l5var2z.i );
  } else {
   if (l5var1z.i = (17)) then {
     if (l5var2z.i = (0)) then {
       insnList@.f[0].s@.f[2].i := insnList@.f[0].s@.f[2].i + insnTemp[AMX];
     } else goto 5220;
   } else if (l5var1z.i = (15)) then {
     addToInsnList    ( 100000006B );
     goto 5220;
   } else
   addInsnAndModify    ( (glob398z[l5var1z.i] + insnTemp[WTC]), l5var2z.i );
   }
 } else {
    P5155;
    if (l5var3z) then {
       addToInsnList    ( (72400000B + lineCnt) );
       addToInsnList    (   getHelperProc (7)   (* "P/CA"*)  );
       insnList@.f[0].s@.f[1].i := (1);
    };
    addToInsnList    (100000006B );
 };
 
 insnList@.f[6].i := (0);
 insnList@.f[5].i := (0);
 insnList@.f[7].i := (16);
}; (* P5170 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5270;
{
 P4606;
 l3var12z := insnList;
 insnList := l4var3z.s;
 P4343    ;
 addToInsnList    (   getHelperProc    ( l3var4z.i )  );
 insnList@.f[3].m := insnList@.f[3].m + l3var12z@.f[3].m + [11:14];
 l3var12z@.f[0].s@.f[0] := insnList@.f[1];
 insnList@.f[1] := l3var12z@.f[1];
}; (* P5270 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5314;
var l5var1z:boolean; l5var2z: @struc;
{
 l5var1z := 12 in l4var3z.s@.f[3].m;
 P4621 (12);
 if (l5var1z) then {
 addToInsnList    ( 00420014B );
 addToInsnList    ( 100000005B );
 };
 l5var2z := insnList;
 insnList := l4var3z.s;
 P4621   ( (14) );
 if (l5var1z) then {
 addToInsnList    ( 100000004B );
 addToInsnList    ( 00400014B );
 };
 l5var2z@.f[3].m := (insnList@.f[3].m + l5var2z@.f[3].m);
 l5var2z@.f[0].s@.f[0] := insnList@.f[1];
 l5var2z@.f[0] := insnList@.f[0];
 insnList := l5var2z;
}; (* P5314 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genFullExpr *);
}; (* genFullExpr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* formOperator *)
}; (* formOperator *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{ (* programme *)
};
procedure initOptions;
{
    pasinfor.startOffset := pasinfor.startOffset-16384;
    commentModeCH := ' ';
    lineNesting := 0;
    maxLineLen := 72;
    CH := ' ';
    linePos := 0;
    prevErrPos := 0;
    errsInLine := 0;
    lineCnt := 1;
    checkFortran := false;
    glob110z := false;
    glob93z := 1;
    glob92z := 1;
    moduleOffset := 16384;
    lineStartOffset := ;
    glob94z := 1;
    glob47z := false;
    inStringLit := ;
    heapSize := 100;
    glob49z := true;
    atEOL := false;
    curVal.i := pasinfor.dummy3[18];
    besm(360031B); besm(360155B);
    optSflags := ;
    doPMD := not (42 in curVal.m);
    checkTypes := true;
    fixMult := true;
    fuzzReals := true;
    pseudoZ := ;
    checkBounds := not (44 in curVal.m);
    declExternal := false;
    errors := false;
    allowCompat := false;
    litExternal.i := 4570644562564154C;
    litForward.i := 46576267416244C; 
    litFortran.i := 46576264624156C; 
    fileBufSize := 1;
    charEncoding := 2;
    glob133z := NIL;
    litOct.i := 574364C;
    longSymCnt := 0;
    pasinfor.errors@ := true;
    extSymAdornment := 0;
    symTabCnt := 0;
}; (* initOptions *)
{ (* main *)
if PASINFOR.listMode <> 0 then
 writeln(boilerplate);
initOptions; 
if errors then {
    9999:
    writeln(' IN ', (lineCnt-1):0, ' LINES ', 
        totalErrors:0, ' ERRORS');
} else {
   PASINFOR.errors@ := false;
}
}.data hashMask:=203407C end
*to perso:670000
*end file
``````
ะะะะะะฆ
