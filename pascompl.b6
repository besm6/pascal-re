user 419900 зс5^
dis 67(1234-wr)^
EEB1A3
*name
*call ficmemory
*pascal
(*=p-,t-,s8,u+,y+*)
program pascompl(output,child,pasinput,pasinfor);
label 9999;
const boilerplate=' PASCAL COMPILER 15.0 (15.02.82)';
type symbol=(
(*0B*)IDENT,INTCONST,REALCONST,CHARCONST,LTSY,GTSY,NOTSY,LPAREN,
(*10B*)LBRACK,MULOP,ADDOP,RELOP,RPAREN,RBRACK,COMMA,SEMICOLON,
(*20B*)PERIOD,ARROW,COLON,BECOMES,LABELSY,CONSTSY,TYPESY,VARSY,
(*30B*)FUNCSY,PROCSY,SETSY,PACKEDSY,ARRAYSY,RECORDSY,FILESY,BEGINSY,
(*40B*)IFSY,CASESY,REPEATSY,WHILESY,FORSY,WITHSY,GOTOSY,ENDSY,
(*50B*)ELSESY,UNTILSY,OFSY,DOSY,TOSY,DOWNTOSY,THENSY,SELECTSY,
(*60B*)PROGRAMSY, OTHERSY, NOSY);
setofsys=set of ident..selectsy;
operator=(MUL, RDIVOP, AMPERS, IDIVOP, IMODOP, PLUSOP, MINUSOP,
OROP, NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP, IMULOP, IDIVROP,
SETAND, SETXOR, SETOR, XORALLONES, FIXEDPLUS, FIXEDMINUS,
badop27, badop30, badop31, badop32, badop33, op34, op35, op36,
op37, op40, op41, op42, op43, op44, ALNUM, op46,
op47, op50, op51, NOTOP, INEGOP, RNEGOP, op55, NOOP );
dummy=(ii, rr, bb, aa, pp, cc, ss,mm,yy,oo);
word=record case dummy of
ii:(i:integer); rr:(r:real); bb:(b:boolean); aa:(a:alfa);
pp:(p:@word); ss:(s:@struc); cc:(c:char);oo:(o:operator);
yy:(y:symbol);mm:(m:set of 0..47) };
struc=record fields:array[0..18] of word };
charmap=packed array ['_000'..'_176'] of char;
var (* total size 4791 words *)
(*40*) octalMode:char; 
(*41-46*)bigSkipSet, statEndSys, blockBegSys, statBegSys,
skipToSet, lvalOpSet: setofsys;
(*47-49*)  glob47z,glob48z,glob49z:boolean;
(*50*)	inStringLit:boolean;
(*51*)  glob51z:word;
(*52*)  jumpTarget:word;
(*53*)  glob53z:word;
(*54*)	charClass:operator; 
(*55-56*) SY,glob56z:symbol; 
(*57*) glob57z:word;
(*58*)	FcstCnt:integer; 
(*59*)	symTabPos:integer;
(*60*)  entryPtCnt:integer;
(*61*)  fileBufSize:integer;
(*62-63*)glob62z,glob63z:@struc;
(*64*)  curInsnTemplate:word;
(*65*)	maxLineLen :integer;
(*66*)	linePos :integer;
(*67*)	prevErrPos :integer;
(*68*)	errsInLine :integer;
(*69*)	moduleOffset:integer;
(*70*)  lineStartOffset:integer;
(*71*)	curFrameRegTemplate:integer;
(*72*)  curProcNesting:integer;
(*73*)	totalErrors :integer;
(*74*)	lineCnt :integer;
(*75*)  bucket:integer;
(*76*)  glob76z:integer;
(*77*)  heapCallsCnt:integer;
(*78*)	heapSize:integer;
(*79*)  arithMode:integer;
(*80*)	stmtName:alfa;
(*81*)  keywordHashPtr:@struc;
(*82*)  curVarKind:word;
(*83*)  curExternFile:word;
(*84*)  commentModeCH:char;
(*85*)  glob85z:word;
(*86*)	CH:char; 
(*87-88*)glob87z,glob88z:word;
(*89*)	lineNesting:integer;
(*90*)  FcstCountTo500:integer;
(*91*)	objBufIdx :integer;
(*92-94*)  glob92z,glob93z,glob94z:integer;
(*95*) glob95z: word;
(*96*)	charEncoding :integer;
(*97*) glob97z:integer;
(*98*)	atEOL:boolean;
(*99*)	checkTypes:boolean; 
(*100-102*) glob100z: boolean;
(*101-102*) glob101z,glob102z: word;
(*103*)	errors :boolean;
(*104*) declExternal:boolean;
(*105*) glob105z:boolean;
(*106*)	doPMD:boolean;
(*107*)	checkBounds:boolean;
(*108*)	fuzzReals:boolean; 
(*109*)	fixMult :boolean;
(*110*) glob110z: boolean;
(*111*)	pseudoZ:boolean;
(*112*)	allowCompat:boolean; 
(*113*)	checkFortran:boolean;
(*114*) outputFile:@word;
(*115*) inputFile:@word;
(*116*) programObj:word;
(*117*) hashTravPtr:@struc;
(*118*) uProcPtr:@word;
(*119*) externFileList:@word;
(*120-121*)glob120z,glob121z:word;
(*122*) pointerType:@word;
(*123*) setType:@word;
(*124*) booleanType:@word;
(*125*) textType:@word;
(*126*) integerType:@word;
(*127*) realType:@word;
(*128*) charType:@word;
(*129*) alfaType:@word;
(*130*) arg1Type:@word;
(*131*) arg2Type:@word;
(*132-133*)glob132z,glob133z:@word;
(*134*) curToken:word;
(*135*) curVal:word;
(*136*) O77777:word;
(*137*) intZero:set of 0..47;
(*138-139*)glob138z,glob139z:word;
(*140*) halfWord:word;
(*141*)	isLeftInsn:word;
(*142*)	hashMask:word;
(*143*) curIdent:word;
(*144-148*)dummy4:array[144..148] of word;
(*149*)	optSflags:word;
(*150*) litOct:word;
(*151*)	litExternal :word;
(*152*)	litForward :word;
(*153*)	litFortran:word;
(*154*) uVarPtr:@word;
(*155*) curExpr:@word;
(*156*) insnList:@word;
(*157-158*)glob157z,glob158z:word;
(*159*) someTypeArrayBase:integer;
(*160*) extSymAdornment:integer;
(*161-165*)dummy5:array[2..6]of @struc;
(*166*) symTabCnt:integer;
(*167-246*)symtabarray:array[1..80] of word;
(*247-326*)symtbidx:array[1..80]of integer;
(*327-339*)dummy6:array[327..339] of word;
(*340-379*) entryPtTableBase:array[0..39]of word;
(*380-531*) dummy7:array[380..531]of word;
(*532*) absInsn:word;
(*533*) addInt0Insn:word;
(*534*) andE1Insn:word;
(*535*) orInt0Insn:word;
(*536*) andE40to1Insn:word;
(*537*) cyclAddE1Insn:word;
(*538*) subE1Insn:word;
(*539-548*)dummy8:array[539..548]of word;
(*549-594*) insnTemplateBase:array[0..45] of word;
(*595*) glob595z:word;
(*596*) frameRegTemplate:word;
(*597*) constRegTemplate:word;
(*598*) disNormTemplate:word;
(*599-728*) lineBufBase:array[1..130]of char;
(*729*)	errMapBase:array[0..9]of integer; 
(*739*)	chrClassTabBase:array ['_000'..'_177']of operator;
(*867*) kwordHashTabBase:array[0..127]of @struc;
(*995*)	charSymTabBase:array['_000'..'_177']of symbol;
(*1123*) symHashTabBase:array[0..127]of @struc;
(*1251*) typeHashTabBase:array[0..127] of @struc;
(*1378*) helperMapBase:array [1..99] of integer;
(*1477*) helperNameBase:array [1..99] of word;
(*1577-2409*)symTab:array[74000B..75500B]of word;
(*2410*) systemProcNameBase:array[1..30] of word; 
(*2440*) resWordNameBase:array[1..30] of word; 
(*2470*) longSymCnt:integer; 
(*2471*) longSymTabBase:array[1..90] of integer; 
(*2560*) longSymsBase:array[1..90]of word;
(*2651*) constValsTabBase:array[1..500]of word;
(*3151*) constNumTabBase:array [1..500]of integer;
(*3651*) objBufBase:array [1..1024]of word;
(*4675*) psInfrCopy:array['_052'..'_177']of char;
(*4761*) fcst:file of word; (* last *)
pasinput:text;
child:file of word;
pasinfor:record
(*0*)    listMode:integer;
(*1*)    dummy1: @boolean;
(*2*)    dummy2: integer;
(*3*)    startOffset:integer;
(*4-6*)  a0,a1,a4:@charmap;
(*7-18*) dummy3: array[7..18] of integer;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(l2arg1z, l2arg2z: word);
var l2var1z,l2var2z,l2var3z,l2var4z,l2var5z,l2var6z,l2var7z,l2var8z,
l2var9z,l2var10z,l2var11z,l2var12z,l2var13z,l2var14z,l2var15z,
l2var16z,l2var17z,l2var18z,l2var19z:word;
l2var20z,l2var21z,l2var22z:integer;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno:integer);
type errtxt=packed array[0..100] of 0..63;
var errptr:@errtxt;
errtext:array [0..100] of 0..63;
i:integer;c:char;
function pasmitxt(errno:integer):@errtxt;fortran;
function pasisoxt(txtchar:0..63):char;fortran;
{
write(' ');
if errno >= 200 then 
	write('system=', errno:0)
else {
	if (errno > 88) then
		printErrMsg(86)
	else if errno in [16..18,20] then { 
		if errno = 20 then
			errno := ord(sy = ident)*2 + 1
		else write(curToken.i:0,' ');
	} else; (*workaround*)
	errptr := pasmitxt(errno);
	unpack(errptr@, errtext, 0);
	(loop) for i:=0 to 100 do {
		c := pasisoxt(errtext[i]);
		if c = '*' then exit loop;
		write(c);
	};
	write(' ');
	if errno in [17,22] then 
		if errno = 17 then
			write(glob97z:0)
		else
			write(stmtName);
};
if errno <> 86 then writeln;
}; (* printErrMsg *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val:word);
procedure PASTPR(val:word);external;
{ 
	write(' '); PASTPR(val)
}; (* printTextWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              assignType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignType(var res:struc);
var l3var1z:@struc;
{
if someTypeArrayBase >= glob76z then
	res.fields[0].s := dummy5[glob76z]
else {
new(l3var1z=7); (* XTA =7; ATI 14 instead of 14, VTM, 7 *)
new(res.fields[0].p=8);
with l3var1z@ do {
fields[0].i := 1;
fields[4].i := 0;
fields[1].i := 12;
fields[2].c := chr(2);
fields[3].p := integerType;
fields[5].i := 1;
fields[6].i := glob76z;
};
with res.fields[0].s@ do {
fields[0].i := (glob76z + 5) div 6;
if fields[0].i = 1 then
	fields[1].i := glob76z * 8
else
	fields[1].i := 0;
fields[2].c := chr(5);
fields[3].p := charType;
fields[4].s := l3var1z;
fields[5].c := chr(1);
fields[6].i := 6;
fields[7].i := 8;
}
}
}; (* assignType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(l3arg1z:@struc);
{
curVal.m := l3arg1z@.fields[0].m * hashMask.m;
mapai(curval.a, curval.i);
l3arg1z@.fields[2].s :=symHashTabBase[curval.i];
symHashTabBase[curval.i] := l3arg1z;
}; (* addToHashTab *)
procedure error(errno: integer); forward;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(l3arg1z:set of 0..47);
{
objBufBase[objBufIdx].m := l3arg1z;
moduleOffset := moduleOffset + 1;
if objBufIdx = 1024 then { 
	error(49);
	objBufIdx := 1
} else objBufIdx := objBufIdx + 1;
}; (* storeObjWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(l3arg1z: word);
var l3var1z, l3var2z, l3var3z, l3var4z: word;
l3var5z: integer;
{
l3var1z := l3arg1z;
l3var2z.m := l3var1z.m * [0,1,3,24..32];
if l3var2z = insnTemplateBase[45] then {
   if glob95z = l3var2z then exit;
   if glob101z.b and (glob95z.i = 1) then {
      l3var5z := objBufIdx - 1;
      if objBufBase[l3var5z].m * [0..8] = [0,1,3..5,8] then {
         glob95z := l3var2z;
         l3var3z.m := l3var1z.m * [33..47];
         besm(360050B);
         l3var3z:=;
         l3var4z.m := objBufBase[l3var5z].m * [9..23];
         besm(360130B);
         l3var4z :=;    
         objBufBase[l3var5z].m := [0,1,3,4,6,28,29] +
         l3var3z.m + l3var4z.m;
         exit;
      }
   }
};
glob95z := l3var2z;
if (glob101z.b) then {
    isLeftInsn.m := l3var1z.m * halfWord.m;
    besm(360050B);
    isLeftInsn :=;
    glob101z.b := false
} else {
    glob101z.b := true;
    storeObjWord(isLeftInsn.m + (l3var1z.m * halfWord.m))
}
}; (* form1Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: word);
{
    form1Insn( i1 );
    form1Insn( i2 );
}; (* form2Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: word);
{
    form2Insn(i1, i2);
    form1Insn(i3);
}; (* form3Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
{
    if arithMode <> 1 then {
        form1Insn(disNormTemplate);
        arithMode := 1;
    }
}; (* disableNorm *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus:integer;
{
   if glob101z.b then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
}; (* getObjBufIdxPlus *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJumpOnCond(var l3arg1z:integer);
var l3var1z:integer; l3var2z: word;
{
 if glob95z <> insnTemplateBase[45] then {
 l3var1z := getObjBufIdxPlus; 
 l3var2z := glob101z;
 (*=c-*)form1Insn(glob51z.i + l3arg1z);(*=c+*)
 if glob101z = l3var2z then
     l3var1z := l3var1z - 1;
 l3arg1z := l3var1z;
 }
}; (* formJumpOnCond *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formLabel;
{
 if not glob101z.b then
    form1Insn( insnTemplateBase[39] );
 glob95z.i := 0;
}; (* formLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formInsnAndLabel(l3arg1z:word);
{
 form1Insn( l3arg1z);
 formLabel;
 glob95z.i := 1;
}; (* formInsnAndLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(l3arg1z: word);
{
 symTab[symTabPos] := l3arg1z;
 if symTabPos = 75500B then {
    error( 50 );
    symTabPos := 74000B;
 } else
    symTabPos := symTabPos + 1;
}; (* putToSymTab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z:word):integer;
var l3var1z:word; l3var2z:integer;
{
 allocExtSymbol := symTabPos;
 if (curVal.m * halfWord.m <> []) then { 
 for l3var2z := 1 to longSymCnt do
   if (curVal = longSymsBase[l3var2z]) then {
     allocExtSymbol := longSymTabBase[l3var2z];
     exit
   };
 longSymCnt := longSymCnt + 1;
 if (longSymCnt >= 90) then {
     error( 51 );
     longSymCnt := 1;
 };
 longSymTabBase[longSymCnt] := symTabPos;
 longSymsBase[longSymCnt] := curVal;
 l3arg1z.m := l3arg1z.m + [25];
 } else
     l3arg1z.m := l3arg1z.m + curVal.m;
 putToSymTab( l3arg1z );
}; (* allocExtSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z:integer):integer;
{
 if (helperMapBase[l3arg1z] = 0) then {
     curVal := helperNameBase[l3arg1z];
     helperMapBase[l3arg1z] := allocExtSymbol( glob139z ); 
 };
 getHelperProc := helperMapBase[l3arg1z] + 67100000B;
}; (*getHelperProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
{
write(FCST, curVal);
FcstCnt := FcstCnt + 1;
}; (* toFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addSomethingToFCST:integer;
var l3var1z,l3var2z, l3var3z:integer; 
{
 l3var1z := 1;
 if (FcstCountTo500 = 0) then {
     addSomethingToFCST := FcstCnt;
     FcstCountTo500 := 1;
     constValsTabBase[1] := curVal;
     constNumTabBase[1] := FcstCnt;
     toFCST;
 } else {
     l3var2z := FcstCountTo500;
     repeat
       l3var3z := (l3var1z + l3var2z) div 2;
       if (curVal = constValsTabBase[l3var3z]) then {
           addSomethingToFCST := constNumTabBase[l3var3z];
           exit
       };
       if curval.a < constValsTabBase[l3var3z].a then
           l3var2z := l3var3z - 1
       else
           l3var1z := l3var3z + 1
     until l3var2z < l3var1z;
     addSomethingToFCST := FcstCnt;
     if FcstCountTo500 <> 500 then {
         if curval.a < constValsTabBase[l3var3z].a then
             l3var2z := l3var3z
         else
             l3var2z := l3var3z + 1;
         for l3var3z := FcstCountTo500 downto l3var2z do {
             l3var1z := l3var3z + 1;
             constValsTabBase[l3var1z] := constValsTabBase[l3var3z];
             constNumTabBase[l3var1z] := constNumTabBase[l3var3z];
         };
         FcstCountTo500 := FcstCountTo500 + 1;
         constValsTabBase[l3var2z] := curVal;
         constNumTabBase[l3var2z] := FcstCnt;
     };
     toFCST;
 }
}; (* addSomethingToFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtabForAbsolute(l3arg1z:word):integer;
var l3var1z, l3var2z,l3var3z:integer;l3var4z:word;
{
    l3var1z := 1;
    l3var4z := l3arg1z;
    if symTabCnt = 0 then {
        allocSymtabForAbsolute := symTabPos;
        symTabCnt := 1;
        symTabArray[1] := l3arg1z;
        symtbidx[1] := symTabPos;
    } else {
        l3var2z := symTabCnt;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (l3var4z = symTabArray[l3var3z]) then {
                allocSymtabForAbsolute := symtbidx[l3var3z];
                exit
            };
            if  l3var4z.a < symTabArray[l3var3z].a then
                 l3var2z := l3var3z - 1
            else
                 l3var1z := l3var3z + 1;
        until l3var2z < l3var1z;
        allocSymtabForAbsolute := symTabPos;
        if symTabCnt <> 80 then {
           if l3var4z.a < symTabArray[l3var3z].a then 
              l3var2z := l3var3z
           else
              l3var2z := l3var3z + 1;
           for l3var3z := symTabCnt downto l3var2z do {
              l3var1z := l3var3z + 1;
              symTabArray[l3var1z] := symTabArray[l3var3z];
              symtbidx[l3var1z] := symtbidx[l3var3z];
           };
           symTabCnt := symTabCnt + 1;
           symTabArray[l3var2z] := l3var4z;
           symtbidx[l3var2z] := symTabPos;
        }
    };
    putToSymTab(l3var4z);
}; (* allocSymtabForAbsolute *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset:integer;
var l3var1z:word;
{
getFCSToffset := addSomethingToFCST;
l3var1z :=;
if (l3var1z.i < 2048) then { }
else if (l3var1z.i >= 4096) then
    error(204)
else {
(*=c-*)
    getFCSToffset := allocSymtabForAbsolute(l3var1z.m + [24]) - 28672;
    exit
}
(*=c+*)
}; (* getFCSToffset *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(l3arg1z:word):integer;
{
 curVal := l3arg1z;
 curVal.m := curVal.m * [7..47];
 nrOfBits := 48-minel(curval.m);
}; (* nrOfBits *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePacked(l3arg1z: @struc; l3arg2z, l3arg3z: word);
var l3var1z:@struc;dummyloc:word;
{
 new(l3var1z=7);
 with l3var1z@ do {
 fields[0].i := 1;
 fields[1].i := 48;
 fields[3] := l3arg1z@.fields[0];
 fields[4].i := 0;
 fields[2].c := chr(2);
 curVal := l3arg2z;
 curVal.m := curVal.m + intZero;
 fields[5] := curVal;
 curVal := l3arg3z;
 curVal.m := curVal.m + intZero;
 fields[6] := curVal;
 if (fields[5].i >= 0) then
    fields[1].i := nrOfBits( curVal ); 
 l3arg1z@.fields[0].s := l3var1z
 }
}; (* definePacked *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(l3arg1z:word):integer;
{
 curVal := l3arg1z;
 curVal.m := curVal.m * [0,1,3,33..47];
 if (16384 >= curVal.i) then
     getValueOrAllocSymtab := curVal.i
 else
     getValueOrAllocSymtab :=
(*=c-*) allocSymtabForAbsolute((curVal.m + [24]) * halfWord.m);(*=c+*)
}; (* getValueOrAllocSymtab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(l3arg1z, l3arg2z: integer);
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z, l3var5z, l3var6z: word;
{
if l3arg1z = 0 then {
    formLabel;
    curVal.i := moduleOffset;
1:  l3var1z.m := curval.m * [33..47];
    curVal := curVal;
    besm(360050B);
    l3var3z:=;
    while l3arg2z <> 0 do {
        if 4096 < l3arg2z then {
            l3var4z.b := true;
            l3arg2z := l3arg2z - 4096;
        } else l3var4z.b := false;
        l3var2z := objBufBase[l3arg2z];
        if l3var4z.b then {
            curVal.m := l3var2z.m * [9..23];
            besm(360130B);
            curVal :=;
            curVal.m := curVal.m + intZero;
            l3var2z.m := l3var2z.m * [0..8,24..47] + l3var3z.m
        } else {
            curVal.m := intZero + l3var2z.m * [33..47];
            l3var2z.m := l3var2z.m * [0..32] + l3var1z.m;
        };
        objBufBase[l3arg2z] := l3var2z;
        l3arg2z := curVal.i;
    };
    exit;
} else if l3arg1z = 2 then {
    (*=c-*)form1Insn(72400000B + curVal.i);(*=c+*)
    if curVal.i = 30721 then
        (*=c-*)form1Insn(72500000B + FcstCnt);(*=c+*)
    (*=c-*)
        form3Insn(139278, insnTemplateBase[30].i + l3arg2z, 34150001B);
        form1Insn(34000001B);
    (*=c+*)
    exit;
} else if (l3arg1z = 1) or (l3arg1z < -2) then {
    l3arg2z := l3arg2z - curVal.i;
    l3var6z.i := getFCSToffset;
    if l3arg1z = 1 then
        l3var5z.i := getHelperProc(68) + (-64200000B)
    else
        l3var5z.i := -l3arg1z;
    curVal.i := l3arg2z;
    l3arg2z := getFCSToffset;
    (*=c-*)
    form3Insn(74000001B, 40050000B + l3var6z.i, l3var5z);
    form3Insn( 40060000B + l3arg2z, l3var5z, 74100001B);
    (*=c+*)
    exit;
} else if l3arg1z = -1 then { (*=c-*)
    form1Insn(72400000B + lineCnt);
    formInsnAndLabel(getHelperProc(l3arg2z));
    exit; (*=c+*)
};
curVal.i := l3arg1z;
goto 1;
}; (* P0715 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var dummy:array[1..14] of integer;
    l3var15z, l3var16z, l3var17z, l3var18z,
    l3var19z, l3var20z:integer;
procedure OBPROG(var start, fin: word); external;
{
l3var18z := pasinfor.listMode;
if (l3var18z <> 0) or (errsInLine <> 0) then
{
    write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
          lineCnt:5, lineNesting:3, commentModeCH);
    l3var19z := 13;
    if (1 in optSflags.m)
       and (maxLineLen = 72)
       and (linePos >= 80) then {
       for l3var15z := 73 to 80 do write(lineBufBase[l3var15z]);
       write(' ');
       linePos := 73;
       l3var19z := 22;
    }; (* 1106 *)
    repeat linePos := linePos-1 
    until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
    for l3var15z := 1 to linePos do {
        output@ := lineBufBase[l3var15z];
        put(output);
    };
    writeln;
    if errsInLine <> 0 then {
        write('*****':l3var19z, ' ':errMapBase[0], '0');
        l3var20z := errsInLine - 1;
        for l3var15z := 1 to l3var20z do {
            l3var16z := errMapBase[l3var15z];
            l3var17z := errMapBase[l3var15z-1];
            if l3var16z <> l3var17z then {
                if l3var17z + 1 <> l3var16z then
                    write(' ':(l3var16z-l3var17z-1));
                write(chr(l3var15z + 48));
            }
        };
        writeln;
        errsInLine := 0;
        prevErrPos := 0;
    }
}; (* 1160 *)
if (l3var18z = 2) and (moduleOffset <> lineStartOffset) then {
    OBPROG(objBufBase[objBufIdx - moduleOffset + lineStartOffset],
           objBufBase[objBufIdx-1]);
}; (* 1174 *)
lineStartOffset := moduleOffset;
linePos := 0;
lineCnt := lineCnt + 1;
if eof (pasinput) then {
error(52);
goto 9999;
}
}; (* endOfLine *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(sym:symbol);
{
if linePos <> prevErrPos then
    error(ord(sym) + 88);
}; (* requiredSymErr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
{
while linePos < 81 do {
    linePos := linePos + 1;
    lineBufBase[linePos] := PASINPUT@;
    if linePos <> 81 then get(PASINPUT);
 };
 endOfLine
}; (* readToPos80 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol;
label 1473, 1, 2, 2175, 2233, 2320, 2334;
var l3var1z:array[0..130] of char;
l3var132z,l3var133z:integer;l3var134z:boolean;
l3var135z:@struc;
l3var136z, l3var137z:real;
l3var138z: char;
numstr:array [1..16]of word;
l3vars2:array [155..159]of word;
l3var160z,l3var161z:integer;
l3var162z:word;
chord:integer; l3var164z: integer;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
{
  repeat
    atEOL := eoln(PASINPUT);
    CH := PASINPUT@;
    get(PASINPUT);
    linePos := linePos + 1;
    lineBufBase[linePos] := CH;
  until (maxLineLen >= linePos) or atEOL;
}; (* nextCH *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment; label 1; (*workaround*)
var l4var1z, l4var2z: boolean; l4var3z: char;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var l5arg1z:integer; l5arg2z: integer);
{
    nextCH;
    l5arg1z := 0;
    while ('9' >= CH) and (CH >= '0') do {
        l5arg1z := 10 * l5arg1z + ord(CH) - ord('0');
        nextCH;
        l4var1z := false;
    };
    if l5arg2z < l5arg1z then l4var1z := true;
}; (* readOptVal *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var l5arg1z:boolean);
{
    nextCH;
    if (CH = '-') or (CH = '+') then {
        l5arg1z := CH = '+';
        l4var1z := false;
    };
    nextCH
}; (* readOptFlag *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseComment *)
    nextCH;
    if CH = '=' then {
        repeat nextCH;
        l4var1z := true;
        case CH of
        'D': {
             readOptVal(curVal.i, 15);
             optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
             };
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': {
             readOptFlag(l4var2z);
             if l4var2z then maxLineLen := 72 else maxLineLen := 120;
             };
        'S': {
             readOptVal(curVal.i, 9);
             if curVal.i = 3 then lineCnt := 1
             else if curVal.i in [4..9] then
                 optSflags.m := optSflags.m + [curVal.i-3]
             else {
                 extSymAdornment := curVal.i;
                 goto 1
             }; 1:; };
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        };
        if l4var1z then error(54);
        until CH <> ',';
    }; (* 1446 *)
    repeat while CH <> '*' do {
        l4var3z := commentModeCH;
        commentModeCH := '*';
        if atEOL then endOfLine;
        nextCH;
        commentModeCH := l4var3z;
    }; nextCH until CH = ')';
    nextCH;
}; (* parseComment *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (again) { (* inSymbol *)
    if inStringLit then {
        error(52);
        readToPos80;
        goto 9999;
    };
    1473: while (CH = ' ') and not atEOL do nextCH;
    if '_200' < CH then {
        lineBufBase[linePos] := ' ';
        chord := ord(CH);
        for l2var22z := 130 to chord do {
            linePos := linePos + 1;
            lineBufBase[linePos] := ' ';
        };
        nextCH;
        goto 1473;
    };
    if atEOL then {
        endOfLine;
        nextCH;
        if CH = '%' then while not atEOL do nextCH;
        goto 1473;
    };
    hashTravPtr := NIL;
    SY := charSymTabBase[CH];
    charClass := chrClassTabBase[CH];
    (lexer) if SY <> NOSY then {
    case SY of
        IDENT: { 1:
            curToken.m := [];
            l3var132z := 1;
            repeat
                curVal.c := psInfrCopy[CH];
                nextCH;
                if 8 >= l3var132z then {
                    l3var132z := l3var132z + 1;
                    curToken := curToken;
                    besm(360072B);
                    curToken:=;
                    curToken.m := curToken.m + curVal.m;
                };
            until chrClassTabBase[CH] <> ALNUM;
            curVal.m := curToken.m * hashMask.m;
            mapAI(curVal.a, bucket);
            curIdent := curToken;
            keywordHashPtr := kwordHashTabBase[bucket];
            while keywordHashPtr <> NIL do {
                if keywordHashPtr@.fields[0] = curToken then {
                    SY := keywordHashPtr@.fields[1].y;
                    charClass := keywordHashPtr@.fields[2].o;
                    exit lexer;
                };
                keywordHashPtr := keywordHashPtr@.fields[3].s;
                besm(2200000B);(*workaround*)
            };
            glob100z := false;
            SY := IDENT;
            case glob93z of
            0: {
               hashTravPtr := symHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                  if hashTravPtr@.fields[1].i = curFrameRegTemplate then
                  {
                      if hashTravPtr@.fields[0] <> curIdent then
                         hashTravPtr := hashTravPtr@.fields[2].s
                      else {
                         glob100z := true;
                         exit lexer;
                      }
                  } else exit lexer; 
               };
            };
            1: { 2:
                hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    if hashTravPtr@.fields[0] <> curIdent then
                      hashTravPtr := hashTravPtr@.fields[2].s
                    else
                      exit lexer;
                };
            };
            2: {
                if glob63z = NIL then goto 2;
                glob62z := glob63z;
                l3var135z := typeHashTabBase[bucket];
                if l3var135z <> NIL then {
                  while glob62z <> NIL do {
                    l3var162z := glob62z@.fields[3].p@;
                    hashTravPtr := l3var135z;
                    while hashTravPtr <> NIL do {
                        if (hashTravPtr@.fields[0] = curIdent)
                        and (hashTravPtr@.fields[6] = l3var162z) then
                            exit lexer;
                        hashTravPtr := hashTravPtr@.fields[2].s;
                        besm(2200000B);
                    };
                    glob62z := glob62z@.fields[2].s;
                  };
                }; goto 2; besm(3041704B); (* workaround *)
            };
            3: {
               hashTravPtr := typeHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                   with hashTravPtr@ do {
                       if (fields[0] = curIdent) and
                          (glob121z = fields[6]) then exit lexer;
                       hashTravPtr := fields[2].s;
                   }
               }
            };
            end;
        }; (* IDENT *)
        REALCONST: {
            nextCH;
            if charSymTabBase[CH] = IDENT then goto 1;
            if CH = '(' then SY := BEGINSY
            else if CH = ')' then SY := ENDSY
            else { SY := NOSY; exit };
            nextCH;
        }; (* REALCONST *)
        INTCONST: { (*=m-*)
            SY := INTCONST;
            l3var132z := 0;
            repeat
                l3var132z := l3var132z + 1;
                if (16 >= l3var132z) then
                    numstr[l3var132z].i := ord(CH)-ord('0')
                else {
                    error (55);
                    l3var132z := 1;
                };
                nextCH;
            until charSymTabBase[CH] <> INTCONST;
            (octdec) { if CH = 'B' then octalMode := chr(1)
            else if CH = 'C' then octalMode := chr(3)
            else if CH = 'T' then octalMode := chr(2)
            else { octalMode := chr(0); exit octdec; };
            nextCH;
            curToken.c := chr(0);
            for l3var133z := 1 to l3var132z do {
                if 7 < numstr[l3var133z].i then
                    error(20);
                curToken := curToken;
                besm(360075B);
                curToken:=;
                curToken.m := numstr[l3var133z].m * [45..47] +
                curToken.m;
            };
            if octalMode = chr(1) then {
                if curToken.m * [0..6] <> [] then {
                    error(43);
                    curToken.i := 1;
                } else curToken.m := curToken.m + intZero;
            } else if octalMode = chr(2) then {
                l3var164z := 16 - l3var132z;
                for l3var161z := 1 to l3var164z do {
                    curToken := curToken;
                    besm(360075B);
                    curToken :=;
                };
            } else; (* workaround *)
            exit lexer;    
            }; (* octdec *)
            curToken.i := 0;
            for l3var133z := 1 to l3var132z do {
                if 109951162777 >= curToken.i then 
                    curToken.i := 10 * curToken.i +
                        numstr[l3var133z].i
                else {
                    error(43);
                    curToken.i := 1;
                };
            };
            l3var161z := 0;
            if CH = '.' then {
                nextCH;
                if CH = '.' then { CH := ':'; exit lexer };
                curToken.r := curToken.i;
                SY := REALCONST;
                if charSymTabBase[CH] <> INTCONST then
                    error (56)
                else repeat
                    curToken.r := 10.0*curToken.r + ord(CH)-48;
                    l3var161z := l3var161z-1;
                    nextCH;
                    until charSymTabBase[CH] <> INTCONST;
            }; (*2062*)
            if CH = 'E' then {
                if l3var161z = 0 then {
                    curToken.r := curToken.i;
                    SY := REALCONST;
                };
                l3var134z := false;
                nextCH;
                if CH = '+' then nextCH else
                if CH = '-' then { l3var134z := true; nextCH }
                else; (* workaround *)
                l3var160z := 0;
                if charSymTabBase[CH] <> INTCONST then
                    error(57)
                else repeat
                    l3var160z := 10 * l3var160z + ord(CH) - 48;
                    nextCH
                until charSymTabBase[CH] <> INTCONST;
                if l3var134z then l3var161z := l3var161z-l3var160z
                else l3var161z := l3var161z+l3var160z;
            }; (* 2122 *)
            if l3var161z <> 0 then {
                l3var137z := 1.0;
                l3var134z := l3var161z < 0;
                l3var161z := abs(l3var161z);
                l3var136z := 10.0;
                if 18 < l3var161z then {
                    l3var161z := 1;
                    error(58);
                };
                repeat
                  if odd(l3var161) then
                    l3var137z := l3var137z * l3var136z;
                  l3var161z := l3var161z div 2;
                  if l3var161z <> 0 then
                     l3var136z := l3var136z*l3var136z;
                until l3var161z = 0;
                if l3var134z then curToken.r := curToken.r / l3var137z
                   else curToken.r := curToken.r * l3var137z;
            };
            exit lexer
        }; (* INTCONST *) (*=m+*)
        CHARCONST: {
            (loop) { for l3var133z := 6 to 130 do {
                nextCH;
                if charSymTabBase[CH] = CHARCONST then {
                    nextCH;
                    if charSymTabBase[CH] <> CHARCONST then
                        exit loop
                    else
                        goto 2233;
                };
                if atEOL then {
                    2175: error(59);
                    exit loop
                } else
                if ((CH = chr(35B)) or (charSymTabBase[CH] = REALCONST))
                   and (charSymTabBase[PASINPUT@] = INTCONST) then {
                    l3var160z := 0;
                    for l3var132z := 1 to 3 do {
                        nextCH;
                        if '7' < CH then error(60);
                        l3var160z := 8*l3var160z + ord(CH) - 48;
                    };
                    if 255 < l3var160z then error(60);
                    l3var1z[l3var133z] := chr(l3var160z);
                } else 2233: with PASINFOR do {
                    if charEncoding = 3 then {
                        if (ch < '*') or ('_176' < CH) then
                            l3var138z := chr(0)
                        else {
                            l3var138z := psInfrCopy[CH];
                            besm(3042246B); (*workaround*)
                            }
                    } else if '_176' < CH then {
                        l3var138z := CH;
                    } else if charEncoding = 0 then {
                        l3var138z := a0@[CH];
                    } else if charEncoding = 1 then {
                        l3var138z := a1@[CH];
                    } else if charEncoding = 4 then {
                        l3var138z := a4@[CH];
                    } else {
                        l3var138z := CH;
                        besm(3042273B) (* workaround*)
                    };
                    l3var1z[l3var133z] := l3var138z;
                };
            }; goto 2175 };
            glob76z := l3var133z - 6;
            if glob76z = 0 then {
               error(61); glob76z := 1; goto 2320 }
            else if glob76z = 1 then {
                SY := CHARCONST;
                l3var132z := 1;
                curToken.c := chr(0);
                unpck(l3var1z[0], curToken.a);
                pck(l3var1z[l3var132z], curToken.a);
                exit lexer;
            } else 2320: {
               curVal.a := '      ';
               SY := LTSY;
               unpck(l3var1z[l3var133z], curVal.a);
               pck(l3var1z[6], curToken.a);
               curVal :=;
               if 6 >= glob76z then exit lexer else {
                   curToken.i := FcstCnt;
                   l3var132z := 6;
                   2334: {
                     toFCST;
                     l3var132z := l3var132z + 6;
                     if l3var133z < l3var132z then exit lexer;
                     pck(l3var1z[l3var132z], curVal.a);
                     goto 2334;
                   }
               }
            };
%            goto 2334; (* doesn't help here as a workaround *)
        }; (* CHARCONST *)
        LTSY: {
            SY := RELOP;
            nextCH;
            if CH = '>' then { charClass := NEOP; nextCH }
            else if CH = '=' then { charClass := LEOP; nextCH }
        }; (* LTOP *)
        GTSY: {
            SY := RELOP;
            nextCH;
            if CH = '=' then { charClass := GEOP; nextCH }
        }; (* GTOP *)
        LPAREN: {
            nextCH;
            if CH = '*' then { parseComment; goto 1473 } 
        };
        COLON: {
            nextCH;
            if CH = '=' then {
                nextCH; SY := BECOMES; charClass := NOOP
            }
        };
        NOTSY, LBRACK, MULOP, ADDOP, RELOP, RPAREN, RBRACK,
        COMMA, SEMICOLON, ARROW: {
            nextCH;
        };
        PERIOD: {
            nextCH;
            if CH = '.' then {
                nextCH;
                SY := COLON;
                charClass := NOOP
            } else {
                if glob56z = ENDSY then inStringLit := true;
            }
        };
    end (* case *)
    } else { (* 2444 *)
        nextCH;
    };
    glob56z := SY;
    if not pseudoZ and not (45 in optSflags.m) then {
        commentModeCH := '=';
        goto again;
    };
    commentModeCH := ' ';
    glob93z := glob92z;
} }; (* inSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skipToEnd;
var l4var1z:symbol;
{
   l4var1z := SY;
   while (l4var1z <> ENDSY) or (SY <> PERIOD) do {
       l4var1z := SY;
       inSymbol
   };
   if CH = 'D' then while SY <> ENDSY do inSymbol;
   goto 9999;
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* error *)
    errors := true;
    glob110z :=;
    if ((linePos <> prevErrPos) and (9 >= errsInLine))
    or (errno = 52) then {
        write(' '); totalErrors := totalErrors + 1;
        errMapBase[errsInLine] := linePos;
        errsInLine := errsInLine + 1;
        prevErrPos := linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if 60 < totalErrors then {
            writeln; endOfLine;
            printErrMsg(53);
            skipToEnd
        }
    }
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skip(toset:setofsys);
{
while not (SY IN toset) do inSymbol;
}; (* skip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure test1(sym:symbol; toset: setofsys);
{
   if (SY <> sym) then {
     requiredSymErr( sym );
     skip( toset )
   } else inSymbol;
}; (* test1 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure errAndSkip(errno:integer; toset:setofsys);
{
   error( errno );  skip( toset )
}; (* errAndSkip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLiteral(var l3arg1z:struc; var l3arg2z:word;
    l3arg3z:boolean);
label 99;
var l3var1z:operator;
{
 l3arg2z := curToken;
 if (GTSY < SY) then {
     if l3arg3z and (charClass IN [PLUSOP,MINUSOP]) then {
        l3var1z := charClass;
        inSymbol;
        parseLiteral( l3arg1z, l3arg2z, false );
        if (l3arg1z.fields[0].p <> integerType) then {
           error( 62 );
           l3arg1z.fields[0].p := integerType;
           l3arg2z.i := 1;
        } else {
           if (l3var1z = MINUSOP) then l3arg2z.i := -l3arg2z.i;
        };
    } else 99: {
       l3arg1z.fields[0].p := NIL;
       error( 6 );
    }
  } else  case SY of
 IDENT: {
 if (hashTravPtr = NIL) or
    (hashTravPtr@.fields[4].y <> INTCONST) then goto 99;
  l3arg1z.fields[0] := hashTravPtr@.fields[3];
  l3arg2z := hashTravPtr@.fields[6];
  };
INTCONST:
 l3arg1z.fields[0].p := integerType;
 REALCONST:
 l3arg1z.fields[0].p := realType;
 CHARCONST:
 l3arg1z.fields[0].p := charType;
 LTSY:
     assignType( l3arg1z );
 GTSY: {
     l3arg1z.fields[0].p := pointerType;
     l3arg2z.p := NIL;
 };
 end (* case *)
}; (* parseLiteral *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P2672(var l3arg1z: struc; l3arg2z: @struc);
var l3var1z: boolean; l3var2z: integer;
l3var3z,l3var4z:@struc;
{
 if l3arg1z.fields[0].p = NIL then {
 curVal.m := l3arg2z@.fields[0].m * hashMask.m;
 mapAI(curVal.a, l3var2z);
 l3var1z := true;
 l3arg1z.fields[0].s := symHashTabBase[l3var2z];
 } else {
 l3var1z := false;
 };
 if (l3arg1z.fields[0].s = l3arg2z) then {
   if (l3var1z) then {
     symHashTabBase[l3var2z] :=
         symHashTabBase[l3var2z]@.fields[2].s;
   } else {
     l3arg1z.fields[0] := l3arg2z@.fields[2];
   };
 } else {
   l3var3z := l3arg1z.fields[0].s;
   while (l3var3z <> l3arg2z) do {
     l3var4z := l3var3z;
     if (l3var3z <> NIL) then {
        l3var3z := l3var3z@.fields[2].s;
     } else {
        exit
     }
   };
   l3var4z@.fields[2] := l3arg2z@.fields[2];
 }
}; (* P2672 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr:@struc):boolean;
{ isFileType := (typtr@.fields[2].c = chr(7)) or
    (typtr@.fields[2].c = chr(6)) and
    typtr@.fields[5].b;
}; (* isFileType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F2751(var l3arg1z:struc):boolean;
{
 if (l2var2z.s <> NIL) then {
  l3arg1z.fields[0].s := l2var2z.s;
  while (l3arg1z.fields[0].s <> NIL) do {
    if (l3arg1z.fields[0].p@ = curIdent) then {
        F2751 := true;
        exit
    };
    l3arg1z.fields[0] := l3arg1z.fields[0].s@.fields[2];
    besm(2200000B); (* workaround *)
  }
 };
 F2751 := false;
}; (* F2751 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkSymAndRead(sym: symbol);
{
 if (SY <> sym) then requiredSymErr( sym )
 else inSymbol
}; (* checkSymAndRead *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* programme *)
};
procedure initOptions;
{
    pasinfor.startOffset := pasinfor.startOffset-16384;
    commentModeCH := ' ';
    lineNesting := 0;
    maxLineLen := 72;
    CH := ' ';
    linePos := 0;
    prevErrPos := 0;
    errsInLine := 0;
    lineCnt := 1;
    checkFortran := false;
    glob110z := false;
    glob93z := 1;
    glob92z := 1;
    moduleOffset := 16384;
    lineStartOffset := ;
    glob94z := 1;
    glob47z := false;
    inStringLit := ;
    heapSize := 100;
    glob49z := true;
    atEOL := false;
    curVal.i := pasinfor.dummy3[18];
    besm(360031B); besm(360155B);
    optSflags := ;
    doPMD := not (42 in curVal.m);
    checkTypes := true;
    fixMult := true;
    fuzzReals := true;
    pseudoZ := ;
    checkBounds := not (44 in curVal.m);
    declExternal := false;
    errors := false;
    allowCompat := false;
    litExternal.a := 'EXTERN';
    litForward.a := 'FORWAR';
    litFortran.a := 'FORTRA';
    fileBufSize := 1;
    charEncoding := 2;
    glob133z := NIL;
    litOct.a := '   OCT';
    longSymCnt := 0;
    pasinfor.dummy1@ := true;
    extSymAdornment := 0;
    symTabCnt := 0;
}; (* initOptions *)
{ (* main *)
if PASINFOR.listMode <> 0 then
 writeln(boilerplate);
initOptions; 
if errors then {
    9999:
    writeln(' IN ', (lineCnt-1):0, ' LINES ', 
        totalErrors:0, ' ERRORS');
}
}.data hashMask:=203407C end
*to perso:670000
*end file
``````
ЕКОНЕЦ
