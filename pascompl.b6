user 419900 зс5^
dis 67(1234-wr)^
EEB1A3
*name
*call ficmemory
*pascal
(*=p-,t-,s8,u+,l3,y+*)
program pascompl(output,child,pasinput,pasinfor);
label 9999;
const boilerplate=' PASCAL COMPILER 15.0 (15.02.82)';
type symbol=(IDENT, INTCONST, REALCONST, CHARCONST,
LTSY, GTSY, NOTSY, LPAREN, LBRACK, MULOP, ADDOP, RELOP,
RPAREN, RBRACK, COMMA, SEMICOLON, PERIOD, ARROW, COLON,
BECOMES, LABELSY, CONSTSY, TYPESY, VARSY, FUNCSY, PROCSY,
SETSY, PACKEDSY, ARRAYSY, RECORDSY, FILESY, BEGINSY,
IFSY, CASESY, REPEATSY, WHILESY, FORSY, WITHSY, GOTOSY, 
ENDSY, ELSESY, UNTILSY, OFSY, DOSY, TOSY, DOWNTOSY, THENSY,
SELECTSY, PROGRAMSY, OTHERSY, NOSY);
setofsys=set of ident..selectsy;
operator=(MUL, RDIVOP, AMPERS, IDIVOP, IMODOP, PLUSOP, MINUSOP,
OROP, NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP, IMULOP, IDIVROP,
SETAND, SETXOR, SETOR, XORALLONES, FIXEDPLUS, FIXEDMINUS,
badop27, badop30, badop31, badop32, badop33, op34, op35, op36,
op37, op40, op41, op42, op43, op44, ALNUM, op46,
op47, op50, op51, NOTOP, INEGOP, RNEGOP, op55, NOOP );
dummy=(ii, rr, bb, aa, pp, cc, ss,mm,yy,oo);
word=record case dummy of
ii:(i:integer); rr:(r:real); bb:(b:boolean); aa:(a:alfa);
pp:(p:@word); ss:(s:@struc); cc:(c:char);oo:(o:operator);
yy:(y:symbol);mm:(m:set of 0..47) end;
struc=record fields:array[0..100] of word end;
var (* total size 4791 words *)
(*40*) octalMode:integer; 
(*41-46*)bigSkipSet, statEndSys, blockBegSys, statBegSys,
skipToSet, lvalOpSet: setofsys;
(*47-49*)dummy1:array[47..49] of word;
(*50*)	inStringLit:boolean;
(*51*)  glob51z:word;
(*52*)  jumpTarget:word;
(*53*)  glob53z:word;
(*54*)	charClass:operator; 
(*55-56*) SY,glob56z:symbol; 
(*57*) glob57z:word;
(*58*)	FcstCnt:integer; 
(*59*)	symTabPos:integer;
(*60*)  entryPtCnt:integer;
(*61*)  fileBufSize:integer;
(*62-63*)glob62z,glob63z:@struc;
(*64*)  curInsnTemplate:word;
(*65*)	maxLineLen :integer;
(*66*)	linePos :integer;
(*67*)	prevErrPos :integer;
(*68*)	errsInLine :integer;
(*69*)	moduleOffset:integer;
(*70*)  lineStartOffset:integer;
(*71*)	curFrameRegTemplate:integer;
(*72*)  curProcNesting:integer;
(*73*)	totalErrors :integer;
(*74*)	lineCnt :integer;
(*75*)  bucket:integer;
(*76*)  glob76z:integer;
(*77*)  heapCallsCnt:integer;
(*78*)	heapSize:integer;
(*79*)  arithMode:integer;
(*80*)	stmtName:alfa;
(*81*)  keywordHashPtr:@struc;
(*82*)  curVarKind:word;
(*83*)  curExternFile:word;
(*84*)  commentModeCH:char;
(*85*)  glob85z:word;
(*86*)	CH:char; 
(*87-88*)glob87z,glob88z:word;
(*89*)	lineNesting:integer;
(*90*)  FcstCountTo500:integer;
(*91*)	objBufIdx :integer;
(*92-93*)  glob92z,glob93z:integer;
(*94-95*) glob94z,glob95z: word;
(*96*)	charEncoding :integer;
(*97*) glob97z:integer;
(*98*)	atEOL:boolean;
(*99*)	checkTypes:boolean; 
(*100-102*) glob100z: boolean;
(*101-102*) glob101z,glob102z: word;
(*103*)	errors :boolean;
(*104*) declExternal:boolean;
(*105*) glob105z:boolean;
(*106*)	doPMD:boolean;
(*107*)	checkBounds:boolean;
(*108*)	fuzzReals:boolean; 
(*109*)	fixMult :boolean;
(*110*) glob110z: boolean;
(*111*)	pseudoZ:boolean;
(*112*)	allowCompat:boolean; 
(*113*)	checkFortran:boolean;
(*114*) outputFile:@word;
(*115*) inputFile:@word;
(*116*) programObj:word;
(*117*) hashTravPtr:@struc;
(*118*) uProcPtr:@word;
(*119*) externFileList:@word;
(*120-121*)glob120z,glob121z:word;
(*122*) pointerType:@word;
(*123*) setType:@word;
(*124*) booleanType:@word;
(*125*) textType:@word;
(*126*) integerType:@word;
(*127*) realType:@word;
(*128*) charType:@word;
(*129*) alfaType:@word;
(*130*) arg1Type:@word;
(*131*) arg2Type:@word;
(*132-133*)glob132z,glob133z:word;
(*134*) curToken:word;
(*135*) curVal:word;
(*136*) O77777:word;
(*137*) intZero:set of 0..47;
(*138-139*)glob138z,glob139z:word;
(*140*) halfWord:word;
(*141*)	isLeftInsn:word;
(*142*)	hashMask:word;
(*143*) curIdent:word;
(*144-148*)dummy4:array[144..148] of word;
(*149*)	optSflags:word;
(*150*) litOct:word;
(*151*)	litExternal :word;
(*152*)	litForward :word;
(*153*)	litFortran:word;
(*154*) uVarPtr:@word;
(*155*) curExpr:@word;
(*156*) insnList:@word;
(*157-158*)glob157z,glob158z:word;
(*159*) someTypeArrayBase:integer;
(*160*) extSymAdornment:integer;
(*161-165*)dummy5:array[2..6]of @struc;
(*166*) symTabCnt:integer;
(*167-246*)symtabarray:array[1..80] of word;
(*247-326*)symtbidx:array[1..80]of integer;
(*327-339*)dummy6:array[327..339] of word;
(*340-379*) entryPtTableBase:array[0..39]of word;
(*380-531*) dummy7:array[380..531]of word;
(*532*) absInsn:word;
(*533*) addInt0Insn:word;
(*534*) andE1Insn:word;
(*535*) orInt0Insn:word;
(*536*) andE40to1Insn:word;
(*537*) cyclAddE1Insn:word;
(*538*) subE1Insn:word;
(*539-548*)dummy8:array[539..548]of word;
(*549-594*) insnTemplateBase:array[0..45] of word;
(*595*) glob595z:word;
(*596*) frameRegTemplate:word;
(*597*) constRegTemplate:word;
(*598*) disNormTemplate:word;
(*599-728*) lineBufBase:array[1..130]of char;
(*729*)	errMapBase:array[0..9]of integer; 
(*739*)	chrClassTabBase:array ['_000'..'_177']of operator;
(*867*) kwordHashTabBase:array[0..127]of @struc;
(*995*)	charSymTabBase:array['_000'..'_177']of symbol;
(*1123*) symHashTabBase:array[0..127]of @struc;
(*1251*) typeHashTabBase:array[0..127] of @struc;
(*1378*) helperMapBase:array [1..99] of integer;
(*1477*) helperNameBase:array [1..99] of word;
(*1577-2409*)symTab:array[74000B..75500B]of word;
(*2410*) systemProcNameBase:array[1..30] of word; 
(*2440*) resWordNameBase:array[1..30] of word; 
(*2470*) longSymCnt:integer; 
(*2471*) longSymTabBase:array[1..90] of integer; 
(*2560*) longSymsBase:array[1..90]of word;
(*2651*) constValsTabBase:array[1..500]of word;
(*3151*) constNumTabBase:array [1..500]of integer;
(*3651*) objBufBase:array [1..1024]of word;
(*4675*) psInfrCopy:array['_052'..'_177']of word;
(*4761*) fcst:file of word; (* last *)
pasinput:text;
child:file of word;
pasinfor:array[1..19]of word;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(l2arg1z, l2arg2z: word);
var l2var1z,l2var2z,l2var3z,l2var4z,l2var5z,l2var6z,l2var7z,l2var8z,
l2var9z,l2var10z,l2var11z,l2var12z,l2var13z,l2var14z,l2var15z,
l2var16z,l2var17z,l2var18z,l2var19z:word;
l2var20z,l2var21z,l2var22z:integer;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno:integer);
type errtxt=packed array[0..100] of 0..63;
var errptr:@errtxt;
errtext:array [0..100] of 0..63;
i:integer;c:char;
function pasmitxt(errno:integer):@errtxt;fortran;
function pasisoxt(txtchar:0..63):char;fortran;
begin
write(' ');
if errno >= 200 then 
	write('system=', errno:0)
else begin
	if (errno > 88) then
		printErrMsg(86)
	else if errno in [16..18,20] then begin 
		if errno = 20 then
			errno := ord(sy = ident)*2 + 1
		else write(curToken.i:0,' ');
	end else; (*workaround*)
	errptr := pasmitxt(errno);
	unpack(errptr@, errtext, 0);
	(loop) for i:=0 to 100 do begin
		c := pasisoxt(errtext[i]);
		if c = '*' then exit loop;
		write(c);
	end;
	write(' ');
	if errno in [17,22] then 
		if errno = 17 then
			write(glob97z:0)
		else
			write(stmtName);
end;
if errno <> 86 then writeln;
end; (* printErrMsg *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val:word);
procedure PASTPR(val:word);external;
begin 
	write(' '); PASTPR(val)
end; (* printTextWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              assignType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignType(res:@struc);
var l3var1z:@struc;
begin
if someTypeArrayBase >= glob76z then
	res@.fields[0].s := dummy5[glob76z]
else begin
new(l3var1z=7); (* XTA =7; ATI 14 instead of 14, VTM, 7 *)
new(res@.fields[0].p=8);
with l3var1z@ do begin
fields[0].i := 1;
fields[4].i := 0;
fields[1].i := 12;
fields[2].c := chr(2);
fields[3].p := integerType;
fields[5].i := 1;
fields[6].i := glob76z;
end;
with res@.fields[0].s@ do begin
fields[0].i := (glob76z + 5) div 6;
if fields[0].i = 1 then
	fields[1].i := glob76z * 8
else
	fields[1].i := 0;
fields[2].c := chr(5);
fields[3].p := charType;
fields[4].s := l3var1z;
fields[5].c := chr(1);
fields[6].i := 6;
fields[7].i := 8;
end
end
end; (* assignType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(l3arg1z:@struc);
begin
curVal.m := l3arg1z@.fields[0].m * hashMask.m;
mapai(curval.a, curval.i);
l3arg1z@.fields[2].s :=symHashTabBase[curval.i];
symHashTabBase[curval.i] := l3arg1z;
end; (* addToHashTab *)
procedure error(errno: integer); forward;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(l3arg1z:set of 0..47);
begin
objBufBase[objBufIdx].m := l3arg1z;
moduleOffset := moduleOffset + 1;
if objBufIdx = 1024 then begin 
	error(49);
	objBufIdx := 1
end else objBufIdx := objBufIdx + 1;
end; (* storeObjWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(l3arg1z: word);
var l3var1z, l3var2z, l3var3z, l3var4z: word;
l3var5z: integer;
begin
l3var1z := l3arg1z;
l3var2z.m := l3var1z.m * [0,1,3,24..32];
if l3var2z = insnTemplateBase[45] then begin
   if glob95z = l3var2z then exit;
   if glob101z.b and (glob95z.i = 1) then begin
      l3var5z := objBufIdx - 1;
      if objBufBase[l3var5z].m * [0..8] = [0,1,3..5,8] then begin
         glob95z := l3var2z;
         l3var3z.m := l3var1z.m * [33..47];
         besm(360050B);
         l3var3z:=;
         l3var4z.m := objBufBase[l3var5z].m * [9..23];
         besm(360130B);
         l3var4z :=;    
         objBufBase[l3var5z].m := [0,1,3,4,6,28,29] +
         l3var3z.m + l3var4z.m;
         exit;
      end
   end
end;
glob95z := l3var2z;
if (glob101z.b) then begin
    isLeftInsn.m := l3var1z.m * halfWord.m;
    besm(360050B);
    isLeftInsn :=;
    glob101z.b := false
end else begin
    glob101z.b := true;
    storeObjWord(isLeftInsn.m + (l3var1z.m * halfWord.m))
end
end; (* form1Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: word);
begin
    form1Insn( i1 );
    form1Insn( i2 );
end; (* form2Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: word);
begin
    form2Insn(i1, i2);
    form1Insn(i3);
end; (* form3Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
begin
    if arithMode <> 1 then begin
        form1Insn(disNormTemplate);
        arithMode := 1;
    end
end; (* disableNorm *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus:integer;
begin
   if glob101z.b then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
end; (* getObjBufIdxPlus *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJumpOnCond(var l3arg1z:integer);
var l3var1z:integer; l3var2z: word;
begin
 if glob95z <> insnTemplateBase[45] then begin
 l3var1z := getObjBufIdxPlus; 
 l3var2z := glob101z;
 (*=c-*)form1Insn(glob51z.i + l3arg1z);(*=c+*)
 if glob101z = l3var2z then
     l3var1z := l3var1z - 1;
 l3arg1z := l3var1z;
 end
end; (* formJumpOnCond *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formLabel;
begin
 if not glob101z.b then
    form1Insn( insnTemplateBase[39] );
 glob95z.i := 0;
end; (* formLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formInsnAndLabel(l3arg1z:word);
begin
 form1Insn( l3arg1z);
 formLabel;
 glob95z.i := 1;
end; (* formInsnAndLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(l3arg1z: word);
begin
 symTab[symTabPos] := l3arg1z;
 if symTabPos = 75500B then begin
    error( 50 );
    symTabPos := 74000B;
 end else
    symTabPos := symTabPos + 1;
end; (* putToSymTab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z:word):integer;
var l3var1z:word; l3var2z:integer;
begin
 allocExtSymbol := symTabPos;
 if (curVal.m * halfWord.m <> []) then begin 
 for l3var2z := 1 to longSymCnt do
   if (curVal = longSymsBase[l3var2z]) then begin
     allocExtSymbol := longSymTabBase[l3var2z];
     exit
   end;
 longSymCnt := longSymCnt + 1;
 if (longSymCnt >= 90) then begin
     error( 51 );
     longSymCnt := 1;
 end;
 longSymTabBase[longSymCnt] := symTabPos;
 longSymsBase[longSymCnt] := curVal;
 l3arg1z.m := l3arg1z.m + [25];
 end else
     l3arg1z.m := l3arg1z.m + curVal.m;
 putToSymTab( l3arg1z );
end; (* allocExtSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z:integer):integer;
begin
 if (helperMapBase[l3arg1z] = 0) then begin
     curVal := helperNameBase[l3arg1z];
     helperMapBase[l3arg1z] := allocExtSymbol( glob139z ); 
 end;
 getHelperProc := helperMapBase[l3arg1z] + 67100000B;
end; (*getHelperProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
begin
write(FCST, curVal);
FcstCnt := FcstCnt + 1;
end; (* toFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addSomethingToFCST:integer;
var l3var1z,l3var2z, l3var3z:integer; 
begin
 l3var1z := 1;
 if (FcstCountTo500 = 0) then begin
     addSomethingToFCST := FcstCnt;
     FcstCountTo500 := 1;
     constValsTabBase[1] := curVal;
     constNumTabBase[1] := FcstCnt;
     toFCST;
 end else begin
     l3var2z := FcstCountTo500;
     repeat
       l3var3z := (l3var1z + l3var2z) div 2;
       if (curVal = constValsTabBase[l3var3z]) then begin
           addSomethingToFCST := constNumTabBase[l3var3z];
           exit
       end;
       if curval.a < constValsTabBase[l3var3z].a then
           l3var2z := l3var3z - 1
       else
           l3var1z := l3var3z + 1
     until l3var2z < l3var1z;
     addSomethingToFCST := FcstCnt;
     if FcstCountTo500 <> 500 then begin
         if curval.a < constValsTabBase[l3var3z].a then
             l3var2z := l3var3z
         else
             l3var2z := l3var3z + 1;
         for l3var3z := FcstCountTo500 downto l3var2z do begin
             l3var1z := l3var3z + 1;
             constValsTabBase[l3var1z] := constValsTabBase[l3var3z];
             constNumTabBase[l3var1z] := constNumTabBase[l3var3z];
         end;
         FcstCountTo500 := FcstCountTo500 + 1;
         constValsTabBase[l3var2z] := curVal;
         constNumTabBase[l3var2z] := FcstCnt;
     end;
     toFCST;
 end
end; (* addSomethingToFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtabForAbsolute(l3arg1z:word):integer;
var l3var1z, l3var2z,l3var3z:integer;l3var4z:word;
begin
    l3var1z := 1;
    l3var4z := l3arg1z;
    if symTabCnt = 0 then begin
        allocSymtabForAbsolute := symTabPos;
        symTabCnt := 1;
        symTabArray[1] := l3arg1z;
        symtbidx[1] := symTabPos;
    end else begin
        l3var2z := symTabCnt;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (l3var4z = symTabArray[l3var3z]) then begin
                allocSymtabForAbsolute := symtbidx[l3var3z];
                exit
            end;
            if  l3var4z.a < symTabArray[l3var3z].a then
                 l3var2z := l3var3z - 1
            else
                 l3var1z := l3var3z + 1;
        until l3var2z < l3var1z;
        allocSymtabForAbsolute := symTabPos;
        if symTabCnt <> 80 then begin
           if l3var4z.a < symTabArray[l3var3z].a then 
              l3var2z := l3var3z
           else
              l3var2z := l3var3z + 1;
           for l3var3z := symTabCnt downto l3var2z do begin
              l3var1z := l3var3z + 1;
              symTabArray[l3var1z] := symTabArray[l3var3z];
              symtbidx[l3var1z] := symtbidx[l3var3z];
           end;
           symTabCnt := symTabCnt + 1;
           symTabArray[l3var2z] := l3var4z;
           symtbidx[l3var2z] := symTabPos;
        end
    end;
    putToSymTab(l3var4z);
end; (* allocSymtabForAbsolute *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset:integer;
var l3var1z:word;
begin
getFCSToffset := addSomethingToFCST;
l3var1z :=;
if (l3var1z.i < 2048) then begin end
else if (l3var1z.i >= 4096) then
    error(204)
else begin
(*=c-*)
    getFCSToffset := allocSymtabForAbsolute(l3var1z.m + [24]) - 28672;
    exit
end
(*=c+*)
end; (* getFCSToffset *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(l3arg1z:word):integer;
begin
 curVal := l3arg1z;
 curVal.m := curVal.m * [7..47];
 nrOfBits := 48-minel(curval.m);
end; (* nrOfBits *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePacked(l3arg1z: @struc; l3arg2z, l3arg3z: word);
var l3var1z:@struc;dummyloc:word;
begin
 new(l3var1z=7);
 with l3var1z@ do begin
 fields[0].i := 1;
 fields[1].i := 48;
 fields[3] := l3arg1z@.fields[0];
 fields[4].i := 0;
 fields[2].c := chr(2);
 curVal := l3arg2z;
 curVal.m := curVal.m + intZero;
 fields[5] := curVal;
 curVal := l3arg3z;
 curVal.m := curVal.m + intZero;
 fields[6] := curVal;
 if (fields[5].i >= 0) then
    fields[1].i := nrOfBits( curVal ); 
 l3arg1z@.fields[0].s := l3var1z
 end
end; (* definePacked *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(l3arg1z:word):integer;
begin
 curVal := l3arg1z;
 curVal.m := curVal.m * [0,1,3,33..47];
 if (16384 >= curVal.i) then
     getValueOrAllocSymtab := curVal.i
 else
     getValueOrAllocSymtab :=
(*=c-*) allocSymtabForAbsolute((curVal.m + [24]) * halfWord.m);(*=c+*)
end; (* getValueOrAllocSymtab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(l3arg1z, l3arg2z: integer);
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z, l3var5z, l3var6z: word;
begin
if l3arg1z = 0 then begin
    formLabel;
    curVal.i := moduleOffset;
1:  l3var1z.m := curval.m * [33..47];
    curVal := curVal;
    besm(360050B);
    l3var3z:=;
    while l3arg2z <> 0 do begin
        if 4096 < l3arg2z then begin
            l3var4z.b := true;
            l3arg2z := l3arg2z - 4096;
        end else l3var4z.b := false;
        l3var2z := objBufBase[l3arg2z];
        if l3var4z.b then begin
            curVal.m := l3var2z.m * [9..23];
            besm(360130B);
            curVal :=;
            curVal.m := curVal.m + intZero;
            l3var2z.m := l3var2z.m * [0..8,24..47] + l3var3z.m
        end else begin
            curVal.m := intZero + l3var2z.m * [33..47];
            l3var2z.m := l3var2z.m * [0..32] + l3var1z.m;
        end;
        objBufBase[l3arg2z] := l3var2z;
        l3arg2z := curVal.i;
    end;
    exit;
end else if l3arg1z = 2 then begin
    (*=c-*)form1Insn(72400000B + curVal.i);(*=c+*)
    if curVal.i = 30721 then
        (*=c-*)form1Insn(72500000B + FcstCnt);(*=c+*)
    (*=c-*)
        form3Insn(139278, insnTemplateBase[30].i + l3arg2z, 34150001B);
        form1Insn(34000001B);
    (*=c+*)
    exit;
end else if (l3arg1z = 1) or (l3arg1z < -2) then begin
    l3arg2z := l3arg2z - curVal.i;
    l3var6z.i := getFCSToffset;
    if l3arg1z = 1 then
        l3var5z.i := getHelperProc(68) + (-64200000B)
    else
        l3var5z.i := -l3arg1z;
    curVal.i := l3arg2z;
    l3arg2z := getFCSToffset;
    (*=c-*)
    form3Insn(74000001B, 40050000B + l3var6z.i, l3var5z);
    form3Insn( 40060000B + l3arg2z, l3var5z, 74100001B);
    (*=c+*)
    exit;
end else if l3arg1z = -1 then begin (*=c-*)
    form1Insn(72400000B + lineCnt);
    formInsnAndLabel(getHelperProc(l3arg2z));
    exit; (*=c+*)
end;
curVal.i := l3arg1z;
goto 1;
end; (* P0715 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var dummy:array[1..14] of integer;
    l3var15z, l3var16z, l3var17z, l3var18z,
    l3var19z, l3var20z:integer;
procedure OBPROG(var start, fin: word); external;
begin
l3var18z := pasinfor[1].i;
if (l3var18z <> 0) or (errsInLine <> 0) then
begin
    write(' ', (lineStartOffset + PASINFOR[4].i):5 oct,
          lineCnt:5, lineNesting:3, commentModeCH);
    l3var19z := 13;
    if (1 in optSflags.m)
       and (maxLineLen = 72)
       and (linePos >= 80) then begin
       for l3var15z := 73 to 80 do write(lineBufBase[l3var15z]);
       write(' ');
       linePos := 73;
       l3var19z := 22;
    end; (* 1106 *)
    repeat linePos := linePos-1 
    until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
    for l3var15z := 1 to linePos do begin
        output@ := lineBufBase[l3var15z];
        put(output);
    end;
    writeln;
    if errsInLine <> 0 then begin
        write('*****':l3var19z, ' ':errMapBase[0], '0');
        l3var20z := errsInLine - 1;
        for l3var15z := 1 to l3var20z do begin
            l3var16z := errMapBase[l3var15z];
            l3var17z := errMapBase[l3var15z-1];
            if l3var16z <> l3var17z then begin
                if l3var17z + 1 <> l3var16z then
                    write(' ':(l3var16z-l3var17z-1));
                write(chr(l3var15z + 48));
            end
        end;
        writeln;
        errsInLine := 0;
        prevErrPos := 0;
    end
end; (* 1160 *)
if (l3var18z = 2) and (moduleOffset <> lineStartOffset) then begin
    OBPROG(objBufBase[objBufIdx - moduleOffset + lineStartOffset],
           objBufBase[objBufIdx-1]);
end; (* 1174 *)
lineStartOffset := moduleOffset;
linePos := 0;
lineCnt := lineCnt + 1;
if eof (pasinput) then begin
error(52);
goto 9999;
end
end; (* endOfLine *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(l3arg1z:word);
begin
if linePos <> prevErrPos then
    error(ord(l3arg1z.c) + 88);
end; (* requiredSymErr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
begin
while linePos < 81 do begin
    linePos := linePos + 1;
    lineBufBase[linePos] := PASINPUT@;
    if linePos <> 81 then get(PASINPUT);
 end;
 endOfLine
end; (* readToPos80 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol; label 0525, 1, 2;
var l3vars:array[1..131] of word;
l3var132z,l3var133z,l3var134z:integer;
l3var135z:@struc;
l3vars1:array [136..161]of word;
l3var162z:word;
chord:integer; l3var164z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
begin
  repeat
    atEOL := eoln(PASINPUT);
    CH := PASINPUT@;
    get(PASINPUT);
    linePos := linePos + 1;
    lineBufBase[linePos] := CH;
  until (maxLineLen >= linePos) or atEOL;
end; (* nextCH *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment; label 1; (*workaround*)
var l4var1z, l4var2z: boolean; l4var3z: char;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var l5arg1z:integer; l5arg2z: integer);
begin
    nextCH;
    l5arg1z := 0;
    while ('9' >= CH) and (CH >= '0') do begin
        l5arg1z := 10 * l5arg1z + ord(CH) - ord('0');
        nextCH;
        l4var1z := false;
    end;
    if l5arg2z < l5arg1z then l4var1z := true;
end; (* readOptVal *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var l5arg1z:boolean);
begin
    nextCH;
    if (CH = '-') or (CH = '+') then begin
        l5arg1z := CH = '+';
        l4var1z := false;
    end;
    nextCH
end; (* readOptFlag *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
begin (* parseComment *)
    nextCH;
    if CH = '=' then begin
        repeat nextCH;
        l4var1z := true;
        case CH of
        'D': begin
             readOptVal(curVal.i, 15);
             optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
             end;
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': begin
             readOptFlag(l4var2z);
             if l4var2z then maxLineLen := 72 else maxLineLen := 120;
             end;
        'S': begin
             readOptVal(curVal.i, 9);
             if curVal.i = 3 then lineCnt := 1
             else if curVal.i in [4..9] then
                 optSflags.m := optSflags.m + [curVal.i-3]
             else begin
                 extSymAdornment := curVal.i;
                 goto 1
             end; 1:; end;
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR[1].i, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        end;
        if l4var1z then error(54);
        until CH <> ',';
    end; (* 1446 *)
    repeat while CH <> '*' do begin
        l4var3z := commentModeCH;
        commentModeCH := '*';
        if atEOL then endOfLine;
        nextCH;
        commentModeCH := l4var3z;
    end; nextCH until CH = ')';
    nextCH;
end; (* parseComment *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
begin (again) begin (* inSymbol *)
    if inStringLit then begin
        error(52);
        readToPos80;
        goto 9999;
    end;
    0525: while (CH = ' ') and not atEOL do nextCH;
    if '_200' < CH then begin
        lineBufBase[linePos] := ' ';
        chord := ord(CH);
        for l2var22z := 130 to chord do begin
            linePos := linePos + 1;
            lineBufBase[linePos] := ' ';
        end;
        nextCH;
        goto 0525;
    end;
    if atEOL then begin
        endOfLine;
        nextCH;
        if CH = '%' then while not atEOL do nextCH;
        goto 0525;
    end;
    hashTravPtr := NIL;
    SY := charSymTabBase[CH];
    charClass := chrClassTabBase[CH];
    (lexer) if SY <> NOSY then begin
    case SY of
        IDENT: begin 1:
            curToken.m := [];
            l3var132z := 1;
            repeat
                curVal := psInfrCopy[CH];
                nextCH;
                if 8 >= l3var132z then begin
                    l3var132z := l3var132z + 1;
                    curToken := curToken;
                    besm(360072B);
                    curToken:=;
                    curToken.m := curToken.m + curVal.m;
                end;
            until chrClassTabBase[CH] <> ALNUM;
            curVal.m := curToken.m * hashMask.m;
            mapAI(curVal.a, bucket);
            curIdent := curToken;
            keywordHashPtr := kwordHashTabBase[bucket];
            while keywordHashPtr <> NIL do begin
                if keywordHashPtr@.fields[0] = curToken then begin
                    SY := keywordHashPtr@.fields[1].y;
                    charClass := keywordHashPtr@.fields[2].o;
                    exit lexer;
                end;
                keywordHashPtr := keywordHashPtr@.fields[3].s;
                besm(2200000B);(*workaround*)
            end;
            glob100z := false;
            SY := IDENT;
            case glob93z of
            0: begin
               hashTravPtr := symHashTabBase[bucket];
               while hashTravPtr <> NIL do begin
                  if hashTravPtr@.fields[1].i = curFrameRegTemplate then
                  begin
                      if hashTravPtr@.fields[0] <> curIdent then
                         hashTravPtr := hashTravPtr@.fields[2].s
                      else begin
                         glob100z := true;
                         exit lexer;
                      end
                  end else exit lexer; 
               end;
            end;
            1: begin 2:
                hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do begin
                    if hashTravPtr@.fields[0] <> curIdent then
                      hashTravPtr := hashTravPtr@.fields[2].s
                    else
                      exit lexer;
                end;
            end;
            2: begin
                if glob63z = NIL then goto 2;
                glob62z := glob63z;
                l3var135z := typeHashTabBase[bucket];
                if l3var135z <> NIL then begin
                  while glob62z <> NIL do begin
                    l3var162z := glob62z@.fields[3].p@;
                    hashTravPtr := l3var135z;
                    while hashTravPtr <> NIL do begin
                        if (hashTravPtr@.fields[0] = curIdent)
                        and (hashTravPtr@.fields[6] = l3var162z) then
                            exit lexer;
                        hashTravPtr := hashTravPtr@.fields[2].s;
                        besm(2200000B);
                    end;
                    glob62z := glob62z@.fields[2].s;
                  end;
                end; goto 2; besm(3041704B); (* workaround *)
            end;
            3: begin
               hashTravPtr := typeHashTabBase[bucket];
               while hashTravPtr <> NIL do begin
                   with hashTravPtr@ do begin
                       if (fields[0] = curIdent) and
                          (glob121z = fields[6]) then exit lexer;
                       hashTravPtr := fields[2].s;
                   end
               end
            end;
            end;
        end; (* IDENT *)
        REALCONST: begin
            nextCH;
            if charSymTabBase[CH] = IDENT then goto 1;
        end; (* REALCONST *)
    end (* case *)
    end else begin (* 2444 *)
        nextCH;
    end;
    glob56z := SY;
    if not pseudoZ and not (4 in optSflags.m) then begin
        commentModeCH := '=';
        goto again;
    end;
    commentModeCH := ' ';
    glob93z := glob92z;
end end; (* inSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
begin end;
begin (* programme *)
end;
begin (* main *)
if PASINFOR[1].i <> 0 then
 writeln(boilerplate);
if errors then begin
    9999:
    writeln(' IN ', (lineCnt-1):0, ' LINES ', 
        totalErrors:0, ' ERRORS');
end
end.
*to perso:670000
*end file
``````
ЕКОНЕЦ
