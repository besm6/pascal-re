user 419900 ะทั5^
dis 67(1234-wr)^
EEB1A3
*name
*call yesmemory
*pascal
(*=p-,t-,s8,u-,y+,k9,l0*)
program pascompl(output, child, pasinput, pasinfor);
%
label 9999;
%
const
     boilerplate = ' PASCAL COMPILER 15.0 (15.02.82)';
%    boilerplate = ' PASCAL BACK TO LIFE (15.08.2017)';
%
    fnSQRT  = 0;  fnSIN  = 1;  fnCOS  = 2;  fnATAN  = 3;  fnASIN = 4;
    fnLN    = 5;  fnEXP  = 6;  fnABSR = 7;  fnTRUNC = 8;  fnODD  = 9;
    fnORD   = 10; fnCHR  = 11; fnSUCC = 12; fnPRED  = 13; fnEOF  = 14;
    fnREF   = 15; fnEOLN = 16; fnSQRR = 17; fnROUND = 18; fnCARD = 19;
    fnMINEL = 20; fnPTR  = 21; fnABSI = 22; fnSQRI  = 23;
%
    S3 = 0;
    S4 = 1;
    S5 = 2;
    S6 = 3;
    NoPtrCheck = 4;
    NoStackCheck = 5;
%
    DebugCode  = 45;
    DebugPrint = 46;
    DebugEntry = 47;
%
    ASN64 = 360100B;
%
    errBooleanNeeded = 0;
    errIdentAlreadyDefined = 2;
    errNoIdent = 3;
    errNotAType = 4;
    errNoConstant = 6;
    errConstOfOtherTypeNeeded = 7;
    errTypeMustNotBeFile = 9;
    errNotDefined = 11;
    errBadSymbol = 12;
    errNeedOtherTypesOfOperands = 21;
    errWrongVarTypeBefore = 22;
    errUsingVarAfterIndexingPackedArray = 28;
    errNoSimpleVarForLoop = 30;
    errTooManyArguments = 38;
    errNoCommaOrParenOrTooFewArgs = 41;
    errNumberTooLarge = 43;
    errVarTooComplex = 48;
    errEOFEncountered = 52;
    errFirstDigitInCharLiteralGreaterThan3 = 60;
%
    macro = 100000000B;
    mcMULTI = 7;
    mcSQRR = 12;
    mcROUND = 11;
    mcMINEL = 15;
    mcSQRI = 13;
    mcCARD = 23;
type
    symbol = (
(*0B*)  IDENT,      INTCONST,   REALCONST,  CHARCONST,
        LTSY,       GTSY,       NOTSY,      LPAREN,
(*10B*) LBRACK,     MULOP,      ADDOP,      RELOP,
        RPAREN,     RBRACK,     COMMA,      SEMICOLON,
(*20B*) PERIOD,     ARROW,      COLON,      BECOMES,
        LABELSY,    CONSTSY,    TYPESY,     VARSY,
(*30B*) FUNCSY,     PROCSY,     SETSY,      PACKEDSY,
        ARRAYSY,    RECORDSY,   FILESY,     BEGINSY,
(*40B*) IFSY,       CASESY,     REPEATSY,   WHILESY,
        FORSY,      WITHSY,     GOTOSY,     ENDSY,
(*50B*) ELSESY,     UNTILSY,    OFSY,       DOSY,
        TOSY,       DOWNTOSY,   THENSY,     SELECTSY,
(*60B*) PROGRAMSY,  OTHERSY,    NOSY
);
%
insn = (
(*000*) ATX,   STX,   OP2,   XTS,   ADD,   SUB,   RSUB,  AMX,
(*010*) XTA,   AAX,   AEX,   ARX,   AVX,   AOX,   ADIVX, AMULX,
(*020*) APX,   AUX,   ACX,   ANX,   EADD,  ESUB,  ASX,   XTR,
(*030*) RTE,   YTA,   OP32,  OP33,  EADDI, ESUBI, ASN,   NTR,
(*040*) ATI,   STI,   ITA,   ITS,   MTJ,   JADDM,
(*046*) UTC,   WTC,   VTM,   UTM,   UZA,   U1A,   UJ,    VJM 
);
%
setofsys = set of ident .. selectsy;
%
operator = (
    MUL,        RDIVOP,     AMPERS,     IDIVOP,     IMODOP,
    PLUSOP,     MINUSOP,    OROP,       NEOP,       EQOP,
    LTOP,       GEOP,       GTOP,       LEOP,       INOP,
    IMULOP,     IDIVROP,    SETAND,     SETXOR,     SETOR,
    XORALLONES, INTPLUS,    INTMINUS,   badop27,    badop30,
    badop31,    MKRANGE,    badop33,    op34,       op35,
    op36,       op37,       op40,       op41,       op42,
    op43,       op44,       ALNUM,      op46,       op47,
    op50,       TOREAL,     NOTOP,      INEGOP,     RNEGOP,
    op55,       NOOP
);
%
opgen = (
    gen0,  STORE, LOAD,  gen3,  SETREG,
    gen5,  gen6,  gen7,  gen8,  gen9,
    gen10, gen11, gen12, FILEACCESS, gen14,
    gen15, gen16, LITINSN
);
%
opflg = (
    opf0, opf1, opf2, opf3, opf4, opf5, opf6, opf7, opf8
);
%
kind = (
    kindReal, kindScalar, kindRange, kindPtr,
    kindSet, kindArray, kindRecord, kindFile
);
%
dummy = (ii, rr, bb, aa, pp, cc, ss, mm, yy, tt, ee,
         oo, qq, ss8, kk);
%
bitset = set of 0..47;
%
word = record case dummy of
    ii: (i: integer);
    rr: (r: real);
    bb: (b: boolean);
    aa: (a: alfa);
    tt: (t: @types);
    ee: (e: @expr);
    ss8: (s8: @struc8);
    ss: (s: @struc);
    cc: (c: char);
    oo: (o: operator);
    yy: (y: symbol);
    kk: (k: kind);
    qq: (q: @identrec);
    mm: (m: bitset)
    end;
%
struc     = record f: array[0..10] of word end;
struc8    = record g: array[0..7] of word end;
%
types = record
    size, bits: integer;
    k: kind;
    case kind of
    kindReal:            (s8: record f: array[3..7] of word end);
    kindRange:           (base: @types; r4, left, right: integer);
    kindArray:           (base, range: @types; pck: boolean;
                          perword, pcksize: integer);
    kindScalar:          (enums: @identrec; numen, start: integer);
    kindSet, kindPtr:    (base: @types);
    kindFile:            (base: @types; elsize: integer);
    kindRecord:          (ptr1, ptr2: @identrec; flag, pckrec: boolean);
    end;
%
typechain = record
    next:   @typechain;
    type1, type2: @types;
end;

charmap   = packed array ['_000'..'_176'] of char;
textmap   = packed array ['_052'..'_177'] of '_000'..'_077';
%
fourwords = array[1..4] of word;
entries = array[1..42] of word;
%
expr = record
    case boolean of
    false:      (f: array[0..3] of word);
    true:       (typ: @types; op: operator; arg1, arg2: word);
end;
%
kword = record
    w:      word;
    sym:    symbol;
    op:     operator;
    next:   @kword;
end;
%
strLabel = record
    next:       @strLabel;
    ident:      word;
    offset:     integer;
    exitTarget: integer;
end;
%
numLabel = record
    id:         word;
    line:       integer;
    frame:      integer;
    offset:     integer;
    next:       @numLabel;
    defined:    boolean;
end;
%
identrec = record
    id:     word;
    offset: integer;
    next:   @identrec;
    case integer of
    5:      (typ: @types; def: boolean);
    7:      (s7: array [3..6] of word);
    12:     (f: array [3..11] of word);
end;
%
var (* total size 4791 words *)
%
(*40*)      octalMode: char;
(*41-46*)   bigSkipSet, statEndSys, blockBegSys, statBegSys,
            skipToSet, lvalOpSet: setofsys;
(*47-49*)   bool47z, bool48z, bool49z: boolean;
(*50*)      dataCheck: boolean;
(*51*)      int51z: integer;
(*52*)      jumpTarget: word;
(*53*)      int53z: integer;
(*54*)      charClass: operator;
(*55-56*)   SY, prevSY: symbol;
(*57*)      glob57z: word;
(*58*)      FcstCnt: integer;
(*59*)      symTabPos: integer;
(*60*)      entryPtCnt: integer;
(*61*)      fileBufSize: integer;
(*62-63*)   strp62z, strp63z: @expr;
(*64*)      curInsnTemplate: word;
(*65*)      maxLineLen: integer;
(*66*)      linePos: integer;
(*67*)      prevErrPos: integer;
(*68*)      errsInLine: integer;
(*69*)      moduleOffset: integer;
(*70*)      lineStartOffset: integer;
(*71*)      curFrameRegTemplate: integer;
(*72*)      curProcNesting: integer;
(*73*)      totalErrors: integer;
(*74*)      lineCnt: integer;
(*75*)      bucket: integer;
(*76*)      strLen: integer;
(*77*)      heapCallsCnt: integer;
(*78*)      heapSize: integer;
(*79*)      arithMode: integer;
(*80*)      stmtName: alfa;
(*81*)      keywordHashPtr: @kword;
(*82*)      curVarKind: kind;
(*83*)      curExternFile: @identrec;
(*84*)      commentModeCH: char;
(*85*)      glob85z: word;
(*86*)      CH: char;
(*87-88*)   glob87z, glob88z: word;
(*89*)      lineNesting: integer;
(*90*)      FcstCountTo500: integer;
(*91*)      objBufIdx: integer;
(*92-94*)   int92z, int93z, int94z: integer;
(*95*)      glob95z: word;
(*96*)      charEncoding: integer;
(*97*)      int97z: integer;
(*98*)      atEOL: boolean;
(*99*)      checkTypes: boolean;
(*100-102*) bool100z, putLeft, bool102z: boolean;
(*103*)     errors: boolean;
(*104*)     declExternal: boolean;
(*105*)     rangeMismatch: boolean;
(*106*)     doPMD: boolean;
(*107*)     checkBounds: boolean;
(*108*)     fuzzReals: boolean;
(*109*)     fixMult: boolean;
(*110*)     bool110z: boolean;
(*111*)     pseudoZ: boolean;
(*112*)     allowCompat: boolean;
(*113*)     checkFortran: boolean;
(*114*)     outputFile: @identrec;
(*115*)     inputFile: @identrec;
(*116*)     programObj: @identrec;
(*117*)     hashTravPtr: @identrec;
(*118*)     uProcPtr: @identrec;
(*119*)     externFileList: @identrec;
(*120-121*) strp120z, strp121z: @types;
(*122*)     pointerType: @types;
(*123*)     setType: @types;
(*124*)     booleanType: @types;
(*125*)     textType: @types;
(*126*)     integerType: @types;
(*127*)     realType: @types;
(*128*)     charType: @types;
(*129*)     alfaType: @types;
(*130*)     arg1Type: @types;
(*131*)     arg2Type: @types;
(*132*)     numLabList: @numLabel;
(*133*)     chain: @typechain;
(*134*)     curToken: word;
(*135*)     curVal: word;
(*136*)     O77777: word;
(*137*)     intZero: bitset;
(*138-139*) glob138z, glob139z: word;
(*140*)     halfWord: bitset;
(*141*)     isLeftInsn: word;
(*142*)     hashMask: word;
(*143-144*) curIdent, glob144z: word;
(*147-148*) set145z, set146z, set147z, set148z: bitset;
(*149*)     optSflags: word;
(*150*)     litOct: word;
(*151*)     litExternal: word;
(*152*)     litForward: word;
(*153*)     litFortran: word;
(*154*)     uVarPtr: @expr;
(*155*)     curExpr: @expr;
(*156*)     insnList: @struc;
(*157-158*) glob157z, glob158z: @identrec;
(*159*)     maxSmallString: integer;
(*160*)     extSymAdornment: integer;
(*161-165*) smallStringType: array [2..6] of @types;
(*166*)     symTabCnt: integer;
(*167-246*) symtabarray: array [1..80] of word;
(*247-326*) symtbidx: array [1..80] of integer;
(*327-331*) glob327z: array [0..4] of word;
(*332-333*) glob332z: array [0..1] of word;
(*334-340*) glob334z: array [0..6] of word;
(*341-369*) entryPtTableBase: entries;
(*370-397*) frameRestore: array [3..6] of fourwords;
(*398-413*) indexreg: array [1..15] of integer;
(*414-450*) opToInsn: array [MUL..op44] of integer;
(*451-487*) opToMode: array [MUL..op44] of integer;
(*488-524*) opFlags: array [MUL..op44] of opflg;
(*525-548*) funcInsn: array [0..23] of integer;
(*549-594*) insnTemp: array [insn] of integer;
(*595*)     glob595z: word;
(*596*)     frameRegTemplate: integer;
(*597*)     constRegTemplate: word;
(*598*)     disNormTemplate: integer;
(*599-728*) lineBufBase: array [1..130] of char;
(*729*)     errMapBase: array [0..9] of integer;
(*739*)     chrClassTabBase: array ['_000'..'_177'] of operator;
(*867*)     kwordHashTabBase: array [0..127] of @kword;
(*995*)     charSymTabBase: array ['_000'..'_177'] of symbol;
(*1123*)    symHashTabBase: array [0..127] of @identrec;
(*1251*)    typeHashTabBase: array [0..127] of @identrec;
(*1378*)    helperMapBase: array [1..99] of integer;
(*1477*)    helperNameBase: array [1..99] of word;
(*1577-
  2409*)    symTab: array [74000B..75500B] of word;
(*2410*)    systemProcNameBase: array [0..29] of integer;
(*2440*)    resWordNameBase: array [0..29] of integer;
(*2470*)    longSymCnt: integer;
(*2471*)    longSymTabBase: array [1..90] of integer;
(*2560*)    longSymsBase: array [1..90] of word;
(*2651*)    constValsTabBase: array [1..500] of word;
(*3151*)    constNumTabBase: array [1..500] of integer;
(*3651*)    objBufBase: array [1..1024] of word;
(*4675*)    iso2text: array ['_052'..'_177'] of '_000'..'_077';
(*4761*)    fcst: file of word; (* last *)
%
    pasinput: text;
%
    child: file of word;
%
    pasinfor: record
        (*0*) listMode:     integer;
        (*1*) errors:       @boolean;
        (*2*) entryptr:     @entries;
        (*3*) startOffset:  integer;
      (*4-6*) a0, a1, a4:   @charmap;
        (*7*) a3:           @textmap;
     (*8-17*) sizes:        array[1..10] of word;
       (*18*) flags:        bitset;
        end;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(var l2arg1z: integer; l2arg2z: @identrec);
label 22420, 22421, 23301;
var
    l2var1z: word;
    typelist: @identrec;
    l2var3z, l2var4z: word; l2var5z: @identrec;
    l2var6z: word;
    l2var7z, l2var8z, l2var9z: boolean;
    l2var10z: @expr;
    l2var11z, l2var12z: word;
    l2var13z: @types;
    l2var14z: word;
    l2var15z, l2var16z: @numLabel;
    strLabList: @strLabel;
%
    l2var18z, l2var19z, l2var20z, l2var21z, l2var22z: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno: integer);
type
    errtxt = packed array [0..100] of '_000'..'_077';
var
    errptr: @errtxt;
    errtext: array [0..100] of '_000'..'_077';
    i: integer;
    c: char;
%
    function pasmitxt(errno: integer): @errtxt;
        fortran;
%
    function pasisoxt(txtchar: '_000'..'_077'): char;
        fortran;
%
{ (* PrintErrMsg *)
    write(' ');
    if errno >= 200 then
        write('system=', errno:0)
    else {
        if (errno > 88) then
            printErrMsg(86)
        else if errno in [16..18, 20] then {
            if errno = 20 then
                errno := ord(sy = ident)*2 + 1
            else
                write(curToken.i:0,' ');
        } else; (*workaround*)
%
        errptr := pasmitxt(errno);
        unpack(errptr@, errtext, 0);
(loop)  for i:=0 to 100 do {
            c := pasisoxt(errtext[i]);
            if c = '*' then
                exit loop;
            write(c);
        };
        write(' ');
        if errno in [17, 22] then
            if errno = 17 then
                write(int97z:0)
            else
                write(stmtName);
    };
    if errno <> 86 then
        writeln;
}; (* PrintErrMsg *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val: word);
%
    procedure PASTPR(val: word);
        external;
%
{ (* printTextWord *)
    write(' ');
    PASTPR(val)
}; (* printTextWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              assignType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignType(var res: @types);
var span: @types;
{
    if maxSmallString >= strLen then
        res := smallStringType[strLen]
    else {
        new(span = 7);
        new(res, kindArray);
        with span@ do {
            size := 1;
            r4 := 0;
            bits := 12;
            k := kindRange;
            base := integerType;
            left := 1;
            right := strLen;
        };
        with res@ do {
            size := (strLen + 5) div 6;
            if size = 1 then
                bits := strLen * 8
            else
                bits := 0;
            k := kindArray;
            base := charType;
            range := span;
            pck := true;
            perword := 6;
            pcksize := 8;
        }
    }
}; (* assignType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(l3arg1z: @identrec);
{
    curVal.m := l3arg1z@.id.m * hashMask.m;
    mapai(curval.a, curval.i);
    l3arg1z@.next := symHashTabBase[curval.i];
    symHashTabBase[curval.i] := l3arg1z;
}; (* addToHashTab *)
%
procedure error(errno: integer);
    forward;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(insn: bitset);
{
    objBufBase[objBufIdx].m := insn;
    moduleOffset := moduleOffset + 1;
    if objBufIdx = 1024 then {
        error(49); (* errTooManyInsnsInBlock *)
        objBufIdx := 1
    } else
        objBufIdx := objBufIdx + 1;
}; (* storeObjWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(l3arg1z: integer);
var
    l3var1z, l3var2z, l3var3z, l3var4z: word;
    l3var5z: integer;
{
    l3var1z.i := l3arg1z;
    l3var2z.m := l3var1z.m * [0, 1, 3, 24..32];
    if l3var2z.i = insnTemp[VJM] then {
        if glob95z = l3var2z then
            exit;
        if putLeft and (glob95z.i = 1) then {
            l3var5z := objBufIdx - 1;
            if objBufBase[l3var5z].m * [0..8] = [0, 1, 3..5, 8] then {
                glob95z := l3var2z;
                l3var3z.m := l3var1z.m * [33..47];
                besm(ASN64-24);
                l3var3z :=;
                l3var4z.m := objBufBase[l3var5z].m * [9..23];
                besm(ASN64+24);
                l3var4z :=;
                objBufBase[l3var5z].m := [0, 1, 3, 4, 6, 28, 29] +
                    l3var3z.m + l3var4z.m;
                exit;
            }
       }
    };
    glob95z := l3var2z;
    if (putLeft) then {
        isLeftInsn.m := l3var1z.m * halfWord;
        besm(ASN64-24);
        isLeftInsn :=;
        putLeft := false
    } else {
        putLeft := true;
        storeObjWord(isLeftInsn.m + (l3var1z.m * halfWord))
    }
}; (* form1Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: integer);
{
    form1Insn(i1);
    form1Insn(i2);
}; (* form2Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: integer);
{
    form2Insn(i1, i2);
    form1Insn(i3);
}; (* form3Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
{
    if arithMode <> 1 then {
        form1Insn(disNormTemplate);
        arithMode := 1;
    }
}; (* disableNorm *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus: integer;
{
   if putLeft then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
}; (* getObjBufIdxPlus *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJumpOnCond(var l3arg1z: integer);
var
    l3var1z: integer;
    l3var2z: boolean;
{
    if glob95z.i <> insnTemplateBase[VJM] then {
        l3var1z := getObjBufIdxPlus;
        l3var2z := putLeft;
        form1Insn(int51z + l3arg1z);
        if putLeft = l3var2z then
            l3var1z := l3var1z - 1;
        l3arg1z := l3var1z;
    }
}; (* formJumpOnCond *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formLabel;
{
    if not putLeft then
        form1Insn(insnTemplateBase[WTC]);
    glob95z.i := 0;
}; (* formLabel *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formInsnAndLabel(l3arg1z: integer);
{
    form1Insn(l3arg1z);
    formLabel;
    glob95z.i := 1;
}; (* formInsnAndLabel *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(l3arg1z: bitset);
{
    symTab[symTabPos].m := l3arg1z;
    if symTabPos = 75500B then {
        error(50); (* errSymbolTableOverflow *)
        symTabPos := 74000B;
    } else
        symTabPos := symTabPos + 1;
}; (* putToSymTab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z: word): integer;
var
    l3var1z: word;
    l3var2z: integer;
{
    allocExtSymbol := symTabPos;
    if (curVal.m * halfWord <> []) then {
        for l3var2z to longSymCnt do
            if (curVal = longSymsBase[l3var2z]) then {
                allocExtSymbol := longSymTabBase[l3var2z];
                exit
            };
        longSymCnt := longSymCnt + 1;
        if (longSymCnt >= 90) then {
            error(51); (* errLongSymbolOverflow *)
            longSymCnt := 1;
        };
        longSymTabBase[longSymCnt] := symTabPos;
        longSymsBase[longSymCnt] := curVal;
        l3arg1z.m := l3arg1z.m + [25];
    } else
        l3arg1z.m := l3arg1z.m + curVal.m;
    putToSymTab(l3arg1z.m);
}; (* allocExtSymbol *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z: integer): integer;
{
    if (helperMapBase[l3arg1z] = 0) then {
        curVal := helperNameBase[l3arg1z];
        helperMapBase[l3arg1z] := allocExtSymbol(glob139z);
    };
    getHelperProc := helperMapBase[l3arg1z] + 67100000B;
}; (*getHelperProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
{
    write(FCST, curVal);
    FcstCnt := FcstCnt + 1;
}; (* toFCST *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addSomethingToFCST: integer;
var
    l3var1z, l3var2z, l3var3z: integer;
{
    l3var1z := 1;
    if (FcstCountTo500 = 0) then {
        addSomethingToFCST := FcstCnt;
        FcstCountTo500 := 1;
        constValsTabBase[1] := curVal;
        constNumTabBase[1] := FcstCnt;
        toFCST;
    } else {
        l3var2z := FcstCountTo500;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (curVal = constValsTabBase[l3var3z]) then {
                addSomethingToFCST := constNumTabBase[l3var3z];
                exit
            };
            if curval.a < constValsTabBase[l3var3z].a then
                l3var2z := l3var3z - 1
            else
                l3var1z := l3var3z + 1
        until l3var2z < l3var1z;
        addSomethingToFCST := FcstCnt;
        if FcstCountTo500 <> 500 then {
            if curval.a < constValsTabBase[l3var3z].a then
                l3var2z := l3var3z
            else
                l3var2z := l3var3z + 1;
            for l3var3z := FcstCountTo500 downto l3var2z do {
                l3var1z := l3var3z + 1;
                constValsTabBase[l3var1z] := constValsTabBase[l3var3z];
                constNumTabBase[l3var1z] := constNumTabBase[l3var3z];
            };
            FcstCountTo500 := FcstCountTo500 + 1;
            constValsTabBase[l3var2z] := curVal;
            constNumTabBase[l3var2z] := FcstCnt;
        };
        toFCST;
    }
}; (* addSomethingToFCST *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtabForAbsolute(l3arg1z: bitset): integer;
var
    l3var1z, l3var2z, l3var3z: integer;
    l3var4z: word;
{
    l3var1z := 1;
    l3var4z.m := l3arg1z;
    if symTabCnt = 0 then {
        allocSymtabForAbsolute := symTabPos;
        symTabCnt := 1;
        symTabArray[1].m := l3arg1z;
        symtbidx[1] := symTabPos;
    } else {
        l3var2z := symTabCnt;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (l3var4z = symTabArray[l3var3z]) then {
                allocSymtabForAbsolute := symtbidx[l3var3z];
                exit
            };
            if  l3var4z.a < symTabArray[l3var3z].a then
                 l3var2z := l3var3z - 1
            else
                 l3var1z := l3var3z + 1;
        until l3var2z < l3var1z;
        allocSymtabForAbsolute := symTabPos;
        if symTabCnt <> 80 then {
            if l3var4z.a < symTabArray[l3var3z].a then
                l3var2z := l3var3z
            else
                l3var2z := l3var3z + 1;
            for l3var3z := symTabCnt downto l3var2z do {
                l3var1z := l3var3z + 1;
                symTabArray[l3var1z] := symTabArray[l3var3z];
                symtbidx[l3var1z] := symtbidx[l3var3z];
            };
            symTabCnt := symTabCnt + 1;
            symTabArray[l3var2z] := l3var4z;
            symtbidx[l3var2z] := symTabPos;
        }
    };
    putToSymTab(l3var4z.m);
}; (* allocSymtabForAbsolute *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset: integer;
var
    l3var1z: word;
{
    getFCSToffset := addSomethingToFCST;
    l3var1z :=;
    if (l3var1z.i < 2048) then {
        (* empty *)
    } else if (l3var1z.i >= 4096) then
        error(204)
    else {
        getFCSToffset := allocSymtabForAbsolute(l3var1z.m + [24]) - 28672;
        exit
    }
}; (* getFCSToffset *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(l3arg1z: integer): integer;
{
    curVal.i := l3arg1z;
    curVal.m := curVal.m * [7..47];
    nrOfBits := 48-minel(curval.m);
}; (* nrOfBits *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure defineRange(var res: @types; l, r: integer);
var
    temp: @types;
    dummyloc: word;
{
    new(temp=7);
    with temp@ do {
        size := 1;
        bits := 48;
        base := res;
        r4 := 0;
        k := kindRange;
        curVal.i := l;
        curVal.m := curVal.m + intZero;
        left := curVal.i;
        curVal.i := r;
        curVal.m := curVal.m + intZero;
        right := curVal.i;
        if (left >= 0) then
            bits := nrOfBits(curVal.i);
        res := temp
    }
}; (* defineRange *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(l3arg1z: integer): integer;
{
    curVal.i := l3arg1z;
    curVal.m := curVal.m * [0, 1, 3, 33..47];
    if (16384 >= curVal.i) then
        getValueOrAllocSymtab := curVal.i
    else
        getValueOrAllocSymtab :=
            allocSymtabForAbsolute((curVal.m + [24]) * halfWord);
}; (* getValueOrAllocSymtab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(mode, l3arg2z: integer);
label 1;
var
    l3var1z, l3var2z, l3var3z, l3var4z: word;
    l3var5z: integer;
    l3var6z: word;
{
    if mode = 0 then {
        formLabel;
        curVal.i := moduleOffset;
1:      l3var1z.m := curval.m * [33..47];
        curVal := curVal;
        besm(ASN64-24);
        l3var3z:=;
        while l3arg2z <> 0 do {
            if 4096 < l3arg2z then {
                l3var4z.b := true;
                l3arg2z := l3arg2z - 4096;
            } else l3var4z.b := false;
            l3var2z := objBufBase[l3arg2z];
            if l3var4z.b then {
                curVal.m := l3var2z.m * [9..23];
                besm(ASN64+24);
                curVal :=;
                curVal.m := curVal.m + intZero;
                l3var2z.m := l3var2z.m * [0..8, 24..47] + l3var3z.m
            } else {
                curVal.m := intZero + l3var2z.m * [33..47];
                l3var2z.m := l3var2z.m * [0..32] + l3var1z.m;
            };
            objBufBase[l3arg2z] := l3var2z;
            l3arg2z := curVal.i;
        };
        exit;
    } else if mode = 2 then {
        form1Insn(72400000B + curVal.i);
        if curVal.i = 30721 then
            form1Insn(72500000B + FcstCnt);
        form3Insn(139278, insnTemp[ASN] + l3arg2z, 34150001B);
        form1Insn(34000001B);
        exit;
    } else if (mode = 1) or (mode < -2) then {
        l3arg2z := l3arg2z - curVal.i;
        l3var6z.i := getFCSToffset;
        if mode = 1 then
            l3var5z := getHelperProc(68) + (-64200000B) (* P/DA *)
        else
            l3var5z := -mode;
        curVal.i := l3arg2z;
        l3arg2z := getFCSToffset;
        form3Insn(74000001B, 40050000B + l3var6z.i, l3var5z);
        form3Insn(40060000B + l3arg2z, l3var5z, 74100001B);
        exit;
    } else if mode = -1 then {
        form1Insn(72400000B + lineCnt);
        formInsnAndLabel(getHelperProc(l3arg2z));
        exit;
    };
    curVal.i := mode;
    goto 1;
}; (* P0715 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var
    unused: array[1..14] of integer;
    err, errPos, prevPos, listMode,
    startPos, lastErr: integer;
%
    procedure OBPROG(var start, fin: word);
        external;
{
    listMode := pasinfor.listMode;
    if (listMode <> 0) or (errsInLine <> 0) then
    {
        write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
              lineCnt:5, lineNesting:3, commentModeCH);
        startPos := 13;
        if (S4 in optSflags.m)
            and (maxLineLen = 72)
            and (linePos >= 80)
        then {
            for err := 73 to 80 do
                write(lineBufBase[err]);
            write(' ');
            linePos := 73;
            startPos := 22;
        }; (* 1106 *)
        repeat
            linePos := linePos-1
        until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
        for err to linePos do {
            output@ := lineBufBase[err];
            put(output);
        };
        writeln;
        if errsInLine <> 0 then {
            write('*****':startPos, ' ':errMapBase[0], '0');
            lastErr := errsInLine - 1;
            for err to lastErr do {
                errPos := errMapBase[err];
                prevPos := errMapBase[err-1];
                if errPos <> prevPos then {
                    if prevPos + 1 <> errPos then
                        write(' ':(errPos-prevPos-1));
                    write(chr(err + 48));
                }
            };
            writeln;
            errsInLine := 0;
            prevErrPos := 0;
        }
    }; (* 1160 *)
    if (listMode = 2) and (moduleOffset <> lineStartOffset) then {
        OBPROG(objBufBase[objBufIdx - moduleOffset + lineStartOffset],
               objBufBase[objBufIdx-1]);
    }; (* 1174 *)
    lineStartOffset := moduleOffset;
    linePos := 0;
    lineCnt := lineCnt + 1;
    if eof(pasinput) then {
        error(errEOFEncountered);
        goto 9999;
    }
}; (* endOfLine *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(sym: symbol);
{
    if linePos <> prevErrPos then
        error(ord(sym) + 88);
}; (* requiredSymErr *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
{
    while linePos < 81 do {
        linePos := linePos + 1;
        lineBufBase[linePos] := PASINPUT@;
        if linePos <> 81 then get(PASINPUT);
    };
    endOfLine
}; (* readToPos80 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol;
label
    1473, 1, 2, 2175, 2233, 2320, 2334;
var
    localBuf: array[0..130] of char;
    tokenLen, tokenIdx: integer;
    l3var134z: boolean;
    l3var135z: @identrec;
    l3var136z, l3var137z: real;
    l3var138z: char;
    numstr: array [1..16] of word;
    l3vars2: array [155..159] of word;
    l3var160z, l3var161z: integer;
    l3var162z: word;
    chord: integer;
    l3var164z: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
{
    repeat
        atEOL := eoln(PASINPUT);
        CH := PASINPUT@;
        get(PASINPUT);
        linePos := linePos + 1;
        lineBufBase[linePos] := CH;
    until (maxLineLen >= linePos) or atEOL;
}; (* nextCH *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment;
label 1; (*workaround*)
var
    l4var1z, l4var2z: boolean;
    l4var3z: char;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var l5arg1z: integer; l5arg2z: integer);
{
    nextCH;
    l5arg1z := 0;
    while ('9' >= CH) and (CH >= '0') do {
        l5arg1z := 10 * l5arg1z + ord(CH) - ord('0');
        nextCH;
        l4var1z := false;
    };
    if l5arg2z < l5arg1z then l4var1z := true;
}; (* readOptVal *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var l5arg1z: boolean);
{
    nextCH;
    if (CH = '-') or (CH = '+') then {
        l5arg1z := CH = '+';
        l4var1z := false;
    };
    nextCH
}; (* readOptFlag *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseComment *)
    nextCH;
    if CH = '=' then {
        repeat nextCH;
        l4var1z := true;
        case CH of
        'D': {
             readOptVal(curVal.i, 15);
             optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
        };
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': {
             readOptFlag(l4var2z);
             if l4var2z then maxLineLen := 72 else maxLineLen := 120;
        };
        'S': {
             readOptVal(curVal.i, 9);
             if curVal.i = 3 then lineCnt := 1
             else if curVal.i in [4..9] then
                 optSflags.m := optSflags.m + [curVal.i - 3]
             else {
                 extSymAdornment := curVal.i;
                 goto 1
             }; 1:; };
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        end;
        if l4var1z then
            error(54); (* errErrorInPseudoComment *)
        until CH <> ',';
    }; (* 1446 *)
    repeat
        while CH <> '*' do {
            l4var3z := commentModeCH;
            commentModeCH := '*';
            if atEOL then
                endOfLine;
            nextCH;
            commentModeCH := l4var3z;
        };
        nextCH
    until CH = ')';
    nextCH;
}; (* parseComment *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (again) { (* inSymbol *)
    if dataCheck then {
        error(errEOFEncountered);
        readToPos80;
        goto 9999;
    };
1473:
    while (CH = ' ') and not atEOL do
        nextCH;
    if '_200' < CH then {
        lineBufBase[linePos] := ' ';
        chord := ord(CH);
        for l2var22z := 130 to chord do {
            linePos := linePos + 1;
            lineBufBase[linePos] := ' ';
        };
        nextCH;
        goto 1473;
    };
    if atEOL then {
        endOfLine;
        nextCH;
        if CH = '%' then while not atEOL do
            nextCH;
        goto 1473;
    };
    hashTravPtr := NIL;
    SY := charSymTabBase[CH];
    charClass := chrClassTabBase[CH];
(lexer)
    if SY <> NOSY then {
        case SY of
        IDENT: {
1:          curToken.m := [];
            tokenLen := 1;
            repeat
                curVal.c := iso2text[CH];
                nextCH;
                if 8 >= tokenLen then {
                    tokenLen := tokenLen + 1;
                    curToken := curToken;
                    besm(ASN64-6);
                    curToken:=;
                    curToken.m := curToken.m + curVal.m;
                };
            until chrClassTabBase[CH] <> ALNUM;
            curVal.m := curToken.m * hashMask.m;
            mapAI(curVal.a, bucket);
            curIdent := curToken;
            keywordHashPtr := kwordHashTabBase[bucket];
            while keywordHashPtr <> NIL do {
                if keywordHashPtr@.w = curToken then {
                    SY := keywordHashPtr@.sym;
                    charClass := keywordHashPtr@.op;
                    exit lexer;
                };
                keywordHashPtr := keywordHashPtr@.next;
                besm(2200000B);(*workaround*)
            };
            bool100z := false;
            SY := IDENT;
            case int93z of
            0: {
                hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    if hashTravPtr@.offset = curFrameRegTemplate then
                    {
                        if hashTravPtr@.id <> curIdent then
                            hashTravPtr := hashTravPtr@.next
                        else {
                            bool100z := true;
                            exit lexer;
                        }
                    } else
                        exit lexer;
                };
            };
            1: {
2:              hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    if hashTravPtr@.id <> curIdent then
                        hashTravPtr := hashTravPtr@.next
                    else
                        exit lexer;
                };
            };
            2: {
                if strp63z = NIL then
                    goto 2;
                strp62z := strp63z;
                l3var135z := typeHashTabBase[bucket];
                if l3var135z <> NIL then {
                    while strp62z <> NIL do {
                        l3var162z := strp62z@.f[3].s@.f[0];
                        hashTravPtr := l3var135z;
                        while hashTravPtr <> NIL do {
                            if (hashTravPtr@.id = curIdent)
                            and (hashTravPtr@.f[6] = l3var162z) then
                                exit lexer;
                            hashTravPtr := hashTravPtr@.next;
                            besm(2200000B);
                        };
                        strp62z := strp62z@.f[2].e;
                    };
                };
                goto 2;
                besm(3041704B); (* workaround *)
            };
            3: {
                hashTravPtr := typeHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    with hashTravPtr@ do {
                        if (id = curIdent) and
                           (strp121z = f[6].t)
                        then
                            exit lexer;
                        hashTravPtr := next;
                   }
               }
            };
            end;
        }; (* IDENT *)
        REALCONST: {
            nextCH;
            if charSymTabBase[CH] = IDENT then
                goto 1;
            if CH = '(' then
                SY := BEGINSY
            else if CH = ')' then
                SY := ENDSY
            else {
                SY := NOSY;
                exit
            };
            nextCH;
        }; (* REALCONST *)
        INTCONST: { (*=m-*)
            SY := INTCONST;
            tokenLen := 0;
            repeat
                tokenLen := tokenLen + 1;
                if (16 >= tokenLen) then
                    numstr[tokenLen].i := ord(CH)-ord('0')
                else {
                    error(55); (* errMoreThan16DigitsInNumber *)
                    tokenLen := 1;
                };
                nextCH;
            until charSymTabBase[CH] <> INTCONST;
(octdec)    {
                if CH = 'B' then
                    octalMode := chr(1)
                else if CH = 'C' then
                    octalMode := chr(3)
                else if CH = 'T' then
                    octalMode := chr(2)
                else {
                    octalMode := chr(0);
                    exit octdec;
                };
                nextCH;
                curToken.c := chr(0);
                for tokenIdx to tokenLen do {
                    if 7 < numstr[tokenIdx].i then
                        error(20); (* errDigitGreaterThan7 *)
                    curToken := curToken;
                    besm(ASN64-3);
                    curToken:=;
                    curToken.m := numstr[tokenIdx].m * [45..47] +
                    curToken.m;
                };
                if octalMode = chr(1) then {
                    if curToken.m * [0..6] <> [] then {
                        error(errNumberTooLarge);
                        curToken.i := 1;
                    } else
                        curToken.m := curToken.m + intZero;
                } else if octalMode = chr(2) then {
                    l3var164z := 16 - tokenLen;
                    for l3var161z to l3var164z do {
                        curToken := curToken;
                        besm(ASN64-3);
                        curToken :=;
                    };
                } else
                    ; (* workaround *)
                exit lexer;
            }; (* octdec *)
            curToken.i := 0;
            for tokenIdx to tokenLen do {
                if 109951162777 >= curToken.i then
                    curToken.i := 10 * curToken.i +
                        numstr[tokenIdx].i
                else {
                    error(errNumberTooLarge);
                    curToken.i := 1;
                };
            };
            l3var161z := 0;
            if CH = '.' then {
                nextCH;
                if CH = '.' then {
                    CH := ':';
                    exit lexer
                };
                curToken.r := curToken.i;
                SY := REALCONST;
                if charSymTabBase[CH] <> INTCONST then
                    error(56) (* errNeedMantissaAfterDecimal *)
                else
                    repeat
                        curToken.r := 10.0*curToken.r + ord(CH)-48;
                        l3var161z := l3var161z-1;
                        nextCH;
                    until charSymTabBase[CH] <> INTCONST;
            }; (*2062*)
            if CH = 'E' then {
                if l3var161z = 0 then {
                    curToken.r := curToken.i;
                    SY := REALCONST;
                };
                l3var134z := false;
                nextCH;
                if CH = '+' then
                    nextCH
                else if CH = '-' then {
                    l3var134z := true;
                    nextCH
                } else
                    ; (* workaround *)
                l3var160z := 0;
                if charSymTabBase[CH] <> INTCONST then
                    error(57) (* errNeedExponentAfterE *)
                else
                    repeat
                        l3var160z := 10 * l3var160z + ord(CH) - 48;
                        nextCH
                    until charSymTabBase[CH] <> INTCONST;
                if l3var134z then
                    l3var161z := l3var161z - l3var160z
                else
                    l3var161z := l3var161z + l3var160z;
            }; (* 2122 *)
            if l3var161z <> 0 then {
                l3var137z := 1.0;
                l3var134z := l3var161z < 0;
                l3var161z := abs(l3var161z);
                l3var136z := 10.0;
                if 18 < l3var161z then {
                    l3var161z := 1;
                    error(58); (* errExponentGreaterThan18 *)
                };
                repeat
                    if odd(l3var161) then
                        l3var137z := l3var137z * l3var136z;
                    l3var161z := l3var161z div 2;
                    if l3var161z <> 0 then
                        l3var136z := l3var136z*l3var136z;
                until l3var161z = 0;
                if l3var134z then
                    curToken.r := curToken.r / l3var137z
                else
                    curToken.r := curToken.r * l3var137z;
            };
            exit lexer
        }; (* INTCONST *) (*=m+*)
        CHARCONST: {
(loop)      {
                for tokenIdx := 6 to 130 do {
                    nextCH;
                    if charSymTabBase[CH] = CHARCONST then {
                        nextCH;
                        if charSymTabBase[CH] <> CHARCONST then
                            exit loop
                        else
                            goto 2233;
                    };
                    if atEOL then {
2175:                   error(59); (* errEOLNInStringLiteral *)
                        exit loop
                    } else if ((CH = chr(35B)) or
                               (charSymTabBase[CH] = REALCONST))
                           and (charSymTabBase[PASINPUT@] = INTCONST)
                    then {
                        l3var160z := 0;
                        for tokenLen to 3 do {
                            nextCH;
                            if '7' < CH then
                               error(errFirstDigitInCharLiteralGreaterThan3);
                            l3var160z := 8*l3var160z + ord(CH) - 48;
                        };
                        if 255 < l3var160z then
                           error(errFirstDigitInCharLiteralGreaterThan3);
                        localBuf[tokenIdx] := chr(l3var160z);
                    } else
2233:                   with PASINFOR do {
                            if charEncoding = 3 then {
                                if (ch < '*') or ('_176' < CH) then
                                    l3var138z := chr(0)
                                else {
                                    l3var138z := iso2text[CH];
                                    besm(3042246B); (*workaround*)
                                    }
                            } else if '_176' < CH then {
                                l3var138z := CH;
                            } else if charEncoding = 0 then {
                                l3var138z := a0@[CH];
                            } else if charEncoding = 1 then {
                                l3var138z := a1@[CH];
                            } else if charEncoding = 4 then {
                                l3var138z := a4@[CH];
                            } else {
                                l3var138z := CH;
                                (q) exit q (*workaround*)
                            };
                            localBuf[tokenIdx] := l3var138z;
                        };
                };
                goto 2175
            };
            strLen := tokenIdx - 6;
            if strLen = 0 then {
               error(61); (* errEmptyString *)
               strLen := 1;
               goto 2320
            } else if strLen = 1 then {
                SY := CHARCONST;
                tokenLen := 1;
                curToken.c := chr(0);
                unpck(localBuf[0], curToken.a);
                pck(localBuf[tokenLen], curToken.a);
                exit lexer;
            } else 2320: {
                curVal.a := '      ';
                SY := LTSY;
                unpck(localBuf[tokenIdx], curVal.a);
                pck(localBuf[6], curToken.a);
                curVal :=;
                if 6 >= strLen then
                    exit lexer
                else {
                    curToken.i := FcstCnt;
                    tokenLen := 6;
2334:               {
                        toFCST;
                        tokenLen := tokenLen + 6;
                        if tokenIdx < tokenLen then
                            exit lexer;
                        pck(localBuf[tokenLen], curVal.a);
                        goto 2334;
                    }
                }
            };
%           goto 2334; (* doesn't help here as a workaround *)
        }; (* CHARCONST *)
        LTSY: {
            SY := RELOP;
            nextCH;
            if CH = '>' then {
                charClass := NEOP;
                nextCH
            } else if CH = '=' then {
                charClass := LEOP;
                nextCH
            }
        }; (* LTOP *)
        GTSY: {
            SY := RELOP;
            nextCH;
            if CH = '=' then {
                charClass := GEOP;
                nextCH
            }
        }; (* GTOP *)
        LPAREN: {
            nextCH;
            if CH = '*' then {
                parseComment;
                goto 1473
            }
        };
        COLON: {
            nextCH;
            if CH = '=' then {
                nextCH;
                SY := BECOMES;
                charClass := NOOP
            }
        };
        NOTSY, LBRACK, MULOP, ADDOP, RELOP, RPAREN, RBRACK,
        COMMA, SEMICOLON, ARROW: {
            nextCH;
        };
        PERIOD: {
            nextCH;
            if CH = '.' then {
                nextCH;
                SY := COLON;
                charClass := NOOP
            } else {
                if prevSY = ENDSY then
                    dataCheck := true;
            }
        };
        end (* case *)
    } else { (* 2444 *)
        nextCH;
    };
    prevSY := SY;
    if not pseudoZ and not (DebugCode in optSflags.m) then {
        commentModeCH := '=';
        goto again;
    };
    commentModeCH := ' ';
    int93z := int92z;
} }; (* inSymbol *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skipToEnd;
var
    sym: symbol;
{
    sym := SY;
    while (sym <> ENDSY) or (SY <> PERIOD) do {
        sym := SY;
        inSymbol
    };
    if CH = 'D' then
        while SY <> ENDSY do
            inSymbol;
    goto 9999;
};
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* error *)
    errors := true;
    bool110z :=;
    if ((linePos <> prevErrPos) and (9 >= errsInLine))
        or (errno = 52)
    then {
        write(' ');
        totalErrors := totalErrors + 1;
        errMapBase[errsInLine] := linePos;
        errsInLine := errsInLine + 1;
        prevErrPos := linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if 60 < totalErrors then {
            writeln;
            endOfLine;
            printErrMsg(53);
            skipToEnd
        }
    }
};
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skip(toset: setofsys);
{
    while not (SY IN toset) do
        inSymbol;
}; (* skip *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure test1(sym: symbol; toset: setofsys);
{
    if (SY <> sym) then {
        requiredSymErr(sym);
        skip(toset)
    } else
        inSymbol;
}; (* test1 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure errAndSkip(errno: integer; toset: setofsys);
{
    error(errno);
    skip(toset)
}; (* errAndSkip *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLiteral(var l3arg1z: @types; var l3arg2z: word;
    l3arg3z: boolean);
label
    99;
var
    l3var1z: operator;
{
    l3arg2z := curToken;
    if (GTSY < SY) then {
        if l3arg3z and (charClass IN [PLUSOP, MINUSOP]) then {
            l3var1z := charClass;
            inSymbol;
            parseLiteral(l3arg1z, l3arg2z, false);
            if (l3arg1z <> integerType) then {
                error(62); (* errIntegerNeeded *)
                l3arg1z := integerType;
                l3arg2z.i := 1;
            } else {
                if (l3var1z = MINUSOP) then
                    l3arg2z.i := -l3arg2z.i;
            };
        } else
99:     {
            l3arg1z := NIL;
            error(errNoConstant);
        }
    } else
        case SY of
        IDENT: {
            if (hashTravPtr = NIL) or
               (hashTravPtr@.f[4].y <> INTCONST) then
                goto 99;
            l3arg1z := hashTravPtr@.f[3].t;
            l3arg2z := hashTravPtr@.f[6];
        };
        INTCONST:
            l3arg1z := integerType;
        REALCONST:
            l3arg1z := realType;
        CHARCONST:
            l3arg1z := charType;
        LTSY:
            assignType(l3arg1z);
        GTSY: {
            l3arg1z := pointerType;
            l3arg2z.s := NIL;
        };
        end (* case *)
}; (* parseLiteral *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P2672(var l3arg1z: @identrec; l3arg2z: @identrec);
var
    l3var1z: boolean;
    l3var2z: integer;
    l3var3z, l3var4z: @identrec;
{
    if l3arg1z = NIL then {
        curVal.m := l3arg2z@.id.m * hashMask.m;
        mapAI(curVal.a, l3var2z);
        l3var1z := true;
        l3arg1z := symHashTabBase[l3var2z];
    } else {
        l3var1z := false;
    };
    if (l3arg1z = l3arg2z) then {
        if (l3var1z) then {
            symHashTabBase[l3var2z] :=
                symHashTabBase[l3var2z]@.next;
        } else {
            l3arg1z := l3arg2z@.next;
        };
    } else {
        l3var3z := l3arg1z;
        while (l3var3z <> l3arg2z) do {
            l3var4z := l3var3z;
            if (l3var3z <> NIL) then {
                l3var3z := l3var3z@.next;
            } else {
                exit
            }
        };
        l3var4z@.next := l3arg2z@.next;
    }
}; (* P2672 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr: @types): boolean;
{
    isFileType := (typtr@.k = kindFile) or
        (typtr@.k = kindRecord) and typtr@.s8.f[5].b;
}; (* isFileType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F2751(var l3arg1z: @identrec): boolean;
{
    if (typelist <> NIL) then {
        l3arg1z := typelist;
        while (l3arg1z <> NIL) do {
            if (l3arg1z@.id = curIdent) then {
                F2751 := true;
                exit
            };
            l3arg1z := l3arg1z@.next;
            besm(2200000B); (* workaround *)
        }
    };
    F2751 := false;
}; (* F2751 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkSymAndRead(sym: symbol);
{
    if (SY <> sym) then
        requiredSymErr(sym)
    else
        inSymbol
}; (* checkSymAndRead *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function typeCheck(type1, type2: @types): boolean;
label
    1;
var
    baseMatch: boolean;
    kind1, kind2: kind;
    link: @typechain;
    basetyp1, basetyp2: @types;
    enums1, enums2: @identrec; span1, span2: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure allocWithTypeCheck;
{
    new(link);
    link@ := [chain, basetyp1, basetyp2];
    chain := link;
    typeCheck := typeCheck(basetyp1, basetyp2);
}; (* allocWithTypeCheck *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function checkRecord(l4arg1z, l4arg2z: @types): boolean;
var
    l4var1z: boolean;
{
    l4var1z := (l4arg1z = NIL) or (l4arg2z = NIL);
    if (l4var1z) then {
        checkRecord := l4arg1z = l4arg2z;
    } else {
        checkRecord := typeCheck(l4arg1z@.base, l4arg2z@.base) and
                 checkRecord(l4arg1z@.s8.f[5].t, l4arg2z@.s8.f[5].t);
    };
}; (* checkRecord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* typeCheck *)
    rangeMismatch := false;
    if (type1@.k = kindRange) then {
        strp120z := type1@.base;
    } else {
        strp120z := type1;
    };
    if not checkTypes or (type1 = type2) then
1:      typeCheck := true
    else
        with type1@ do {
            kind1 := k;
            kind2 := type2@.k;
            if (kind1 = kind2) then {
                case kind1 of
                kindReal:
                    (* empty *);
                kindScalar: {
(chain)             if (type1@.numen = type2@.numen) then {
                        enums1 := type1@.enums;
                        enums2 := type2@.enums;
                        while (enums1 <> NIL) and (enums2 <> NIL) do {
                            if (enums1@.id <> enums2@.id) then
                                exit chain;
                            enums1 := enums1@.f[5].q;
                            enums2 := enums2@.f[5].q;
                        };
                        if (enums1 = NIL) and (enums2 = NIL) then
                            goto 1;
                    }
                };
                kindRange: {
                    baseMatch := (type1@.base = type2@.base);
                    strp120z := type1@.base;
                    rangeMismatch := (type1@.left <> type2@.left) or
                                (type1@.right <> type2@.right);
                    typeCheck := baseMatch;
                    exit
                };
                kindPtr: {
                    if (type1 = pointerType) or (type2 = pointerType) then
                        goto 1;
                    basetyp1 := type1@.base;
                    basetyp2 := type2@.base;
                    if (chain <> NIL) then {
                        link := chain;
                        while (link <> NIL) do with link@ do {
                            if (type1 = basetyp1) and
                               (type2 = basetyp2) or
                               (type2 = basetyp1) and
                               (type1 = basetyp2) then
                                goto 1;
                            link := next;
                        };
                        allocWithTypeCheck;
                    } else {
                        setup(type1);
                        allocWithTypeCheck;
                        chain := NIL;
                        rollup(type1);
                        exit
                    }
                };
                kindSet:
                    goto 1;
                kindArray: {
                    with type1@.range@ do
                        span1 := right - left;
                    with type2@.range@ do
                        span2 := right - left;
                    if typeCheck(type1@.base, type2@.base) and
                       (span1 = span2) and
                       (type1@.pck = type2@.pck) and
                       not rangeMismatch then {
                        if type1@.pck then {
                            if (type1@.pcksize = type2@.pcksize) then
                                goto 1
                        } else
                            goto 1
                    }
                };
                kindFile: {
                    if typeCheck(type1@.base, type2@.base) then
                        goto 1;
                };
                kindRecord: {
                    if checkRecord(type1@.s8.f[4].t, type2@.s8.f[4].t) then
                        goto 1;
                }
                end (* case *)
            } else {
                if (kind1 = kindRange) then {
                    rangeMismatch := true;
                    strp120z := type2;
                    if (type1@.base = type2) then
                        goto 1;
                } else if (kind2 = kindRange) and
                          (type1 = type2@.base) then
                    goto 1;
            };
            typeCheck := false;
        }
}; (* typeCheck *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3307(l3arg1z: @identrec): integer;
var
    l3var1z: integer;
    l3var2z: @identrec;
{
    l3var2z := l3arg1z@.f[7].q;
    l3var1z := 0;
    if (l3var2z <> NIL) then
        while (l3var2z <> l3arg1z) do {
            l3var1z := l3var1z + 1;
            l3var2z := l3var2z@.f[5].q;
        };
    F3307 := l3var1z;
}; (* F3307 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeNameWithStars(isProc: boolean): word;
var
    wantBoth: boolean;
{
    wantBoth := not isProc and (extSymAdornment = 0);
    if curVal.m * [0..5] = [] then {
        curVal := curVal;
        besm(ASN64-6);
        curVal := ;
        if wantBoth or (extSymAdornment = 1) then
            curVal.m := curVal.m + [44, 46];
        while curVal.m * [0..11] = [] do {
            curVal := curVal;
            besm(ASN64-6);
            curVal := ;
        };
        if curVal.m * [0..5] = [] then {
            if wantBoth then
                curVal.m := [2, 4] + curVal.m
            else {
                curVal := curVal;
                besm(ASN64-6);
                curVal := ;
            }
        }
    };
    makeNameWithStars := curVal;
}; (* makeNameWithStars *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formOperator(l3arg1z: opgen);
var
    l3var1z, l3var2z: word;
    l3var3z: word;
    l3var4z: integer;
    l3var5z: word;
    flags: opflg;
    l3var7z,
    l3var8z, l3var9z, l3var10z, l3var11z: word;
    l3var12z: @struc;
    l3var13z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genOneOp;
label
    3556;
var
    l4var1z: integer;
    l4var2z, l4var3z, l4var4z: integer;
    l4var5z: word;
    l4var6z, l4var7z, l4var8z: @expr;
    l4var9z: integer;
    insnBuf: array[1..200] of word;
    l4var210z: word;
    l4var211z: word;
    l4var212z: @struc;
    l4var213z: boolean;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3363;
{
    if l4var213z then
        form1Insn(insnTemp[XTA])
    else
        form1Insn(04100010B)
}; (* P3363 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  addInsnToBuf(l5arg1z: integer);
{
    insnBuf[l4var1z].i := l5arg1z;
    l4var1z := l4var1z + 1;
}; (* addInsnToBuf *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure add2InsnsToBuf(l5arg1z, l5arg2z: integer);
{
    insnBuf[l4var1z].i := l5arg1z;
    insnBuf[l4var1z+1].i := l5arg2z;
    l4var1z := l4var1z + 2;
}; (* add2InsnsToBuf *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3413: boolean;
{
    l4var7z := l4var6z;
    while l4var7z <> NIL do {
        if (l4var7z@.op = l4var210z.o) then {
            F3413 := true;
            while (l4var7z@.f[2].i = macro) do {
                l4var7z := ptr(l4var7z@.f[3].i);
            };
            exit
        } else {
            l4var7z := l4var7z@.f[0].e;
        }
    };
    F3413 := false;
}; (* F3413 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3436(l5arg1z: integer);
{
    if not F3413 then {
        new(l4var7z);
        l4var7z@.f[0].e := l4var6z;
        l4var7z@.op := l4var210z.o;
        l4var7z@.f[2].i := 0;
        l4var7z@.f[3].i := 0;
        l4var6z := l4var7z;
    };
    addInsnToBuf((macro + l5arg1z) + ord(l4var7z))
}; (* P3436 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genOneOp *)
    if insnList = NIL
        then exit;
    set145z := set145z + insnList@.f[3].m;
    l4var212z := insnList@.f[1].s;
    l4var9z := 370007B;
    l4var1z := 1;
    if l4var212z = NIL then
        exit;
    l4var6z := NIL;
    while l4var212z <> NIL do {
        l4var211z.i := l4var212z@.f[2].i;
        l4var4z := l4var211z.i -  macro;
        l4var210z.i := l4var212z@.f[3].i;
        case l4var212z@.f[1].i of
         0: ;
         1: if arithMode <> 1 then {
                addInsnToBuf(370007B);
                arithMode := 1
            };
         2: arithMode := 1;
         3: if arithMode <> 2 then {
                addInsnToBuf(insnTemp[NTR]);
                arithMode := 2;
            };
         4: arithMode := 2;
        end; (* case *)
        l4var212z := l4var212z@.f[0].s;
        if l4var4z >= 0 then {
            case l4var4z of
            mcCARD: {
                add2InsnsToBuf(00220000B, 04120011B);
            };
            21: goto 3556;
            0:  P3436(insnTemp[U1A]);
            1:  P3436(insnTemp[UJ]);
            2: {
                l4var211z.i := l4var210z.i mod 4096;
                l4var210z.i := l4var210z.i div 4096;
                P3436(insnTemp[VJM]);
                l4var210z.i := l4var211z.i;
3556:           if F3413 then
                    addInsnToBuf(ord(l4var7z) + 200000000B)
                else
                    error(206);
            };
            3: {
                 l4var211z.i := l4var210z.i mod 4096;
                 l4var210z.i := l4var210z.i div 4096;
                 l4var213z :=  F3413;
                 l4var8z := l4var7z;
                 l4var210z.i := l4var211z.i;
                 l4var213z := l4var213z & F3413;
                 if l4var213z then
                    with l4var7z@ do {
                        f[2].i := macro;
                        f[3].i := ord(l4var8z);
                    }
                else
                    error(207);
            };
            20: addInsnToBuf(300000000B + l4var210z.i);
            4: {
                if insnBuf[l4var1z-1].m * [21:23, 28:35] = [] then
                    insnBuf[l4var1z-1].m := insnBuf[l4var1z-1].m + [35]
                else
                    addInsnToBuf(74100000B)
            };
            5:
(blk)       {
                if l4var212z <> NIL then {
                    l4var211z := l4var212z@.f[2];
                    if l4var211z.m * [21:23, 28:35] = [32] then {
                        l4var212z@.f[2].i :=
                            l4var211z.i - insnTemp[XTA] + insnTemp[XTS];
                        exit blk
                    }
                };
                addInsnToBuf(74000000B);
            };
            6:  add2InsnsToBuf(400016B, 72200000B);
            7:  addInsnToBuf(getHelperProc(12));        (* P/MI *)
            8:  add2InsnsToBuf(76300000B, 02500000B+
                               indexreg[l4var210z.i]);
            9:  add2InsnsToBuf(400016B, 70450000B + l4var210z.i);
            10: add2InsnsToBuf(04110010B, 04120011B);
            mcROUND: {
                addInsnToBuf(04040023B);                (* round *)
                add2InsnsToBuf(370007B, 04040011B)
            };
            mcSQRR: {
                add2InsnsToBuf(74000000B, 74170000B);   (* sqr *)
            };
            mcSQRI: {
                add2InsnsToBuf(74000000B, 04120012B);   (* sqrint *)
                add2InsnsToBuf(74170000B, 0310100B)
            };
            14: add2InsnsToBuf(indexreg[l4var210z.i] + 02400000B,
                               0420000B + l4var210z.i);
            mcMINEL: {
                add2InsnsToBuf(04230011B, 04050021B);   (* minel *)
            };
            16: add2InsnsToBuf(insnTemp[XTA], 74000000B + l4var210z.i);
            17: {
                addInsnToBuf(0030000B);
                add2InsnsToBuf(74000001B, 76500000B + l4var210z.i)
            };
            18: add2InsnsToBuf(52400000B, getHelperProc(65)); (* P/B7 *)
            19: {
                addInsnToBuf(72400000B);
                add2InsnsToBuf(74100000B, 70000000B)
            };
            22: {
                add2InsnsToBuf(72400000B, 70100000B);
                curVal.i := 40077777C;
                add2InsnsToBuf(allocSymtabForAbsolute(curVal.m) + 74030000B,
                               40110000B + l4var210z.i);
                add2InsnsToBuf(74120000B, 70000000B)
            };
            end; (* case *)
        } else { (* 4003 *)
            if 28 in l4var211z.m then {
                addInsnToBuf(getValueOrAllocSymtab(l4var210z.i)+l4var211z.i);
            } else {
                curval.i := l4var210z.i mod 32768;
                if curVal.i < 2048 then
                    addInsnToBuf(l4var211z.i + l4var210z.i)
                else
(stmt)          if (curVal.i >= 28672) or (curVal.i < 4096) then {
                    addInsnToBuf(
                        allocSymtabForAbsolute((curVal.m + [24])*halfWord)
                        + l4var211z.i - 28672);
                } else {
                    add2InsnsToBuf(getValueOrAllocSymtab(curVal.i)
                                   + insnTemp[WTC], l4var211z.i);
                    exit stmt; (*workaround*)
                }
            }
        }
    }; (* 4037 *)
    l4var1z := l4var1z-1;
    for l4var4z := l4var1z downto 1 do {
        l4var210z := insnBuf[l4var4z];
        if (l4var210z.i = insnTemp[NTR]) or
           (l4var210z.i = 370007B)
        then {
            l4var3z := l4var4z - 1;
            l4var213z := false;
(loop)      if l4var3z < 1 then exit loop else {
                l4var211z.m := insnBuf[l4var3z].m * [28:32];
                if (l4var211z.m = [28, 31]) or (l4var211z.m = [28, 31, 32])
                then {
                    l4var3z := l4var3z-1;
                    goto loop;
                }
            };
(* one word shorter
(loop)      while l4var3z >= 1 do {
                l4var211z.m := insnBuf[l4var3z].m * [28:32];
                if (l4var211z.m # [28, 31]) and (l4var211z.m # [28, 31, 32])
                then
                    exit loop;
                l4var3z := l4var3z-1;
            };
*)
            l4var3z := l4var3z + 1;
            if (l4var3z <> l4var4z) then {
                for l4var2z := l4var4z-1 downto l4var3z do {
                    insnBuf[l4var2z+1] := insnBuf[l4var2z]
                };
            };
            insnBuf[l4var3z] := l4var210z;
        }; (* 4103 *)
    };
    for l4var4z to l4var1z do
(iter)  {
        l4var210z := insnBuf[l4var4z];
        l4var211z.m := l4var210z.m * [0, 1, 3, 23:32];
        if l4var211z.i = 74000000B then {
            l4var2z := l4var4z + 1;
            while l4var1z + 1 <> l4var2z do {
                curVal.m := insnBuf[l4var2z].m * [0, 1, 3, 23, 28:35];
                l4var211z.m := curVal.m * [0, 1, 3, 23, 28:32];
                if curVal.i = insnTemp[XTA] then {
                    insnBuf[l4var2z].m :=
                        insnBuf[l4var2z].m mod [32, 34, 35];
                    exit iter;
                } else if curVal.i = insnTemp[ITA] then {
                    insnBuf[l4var2z].m := insnBuf[l4var2z].m + [35];
                    exit iter;
                } else if (curVal.i = insnTemp[NTR]) or
                    (l4var211z.i = insnTemp[WTC]) or
                    (l4var211z.i = insnTemp[VTM]) or
                    (l4var211z.i = insnTemp[UTM])
                then
                    l4var2z := l4var2z + 1
                else
                    l4var2z := l4var1z + 1;
            };
        }; (* 4150 *)
        if l4var210z.i = insnTemp[WTC] then
            exit iter;
        if l4var210z.i < macro then {
            form1Insn(l4var210z.i);
            l4var211z.m := l4var210z.m * [28:32];
            if (l4var211z.m = [28, 29, 32]) or
               (l4var211z.m = [30, 32])
            then {
                formLabel;
                glob95z.i := 1;
            };
            exit iter;
        };
        if (l4var210z.i >= 300000000B) then {
            l4var210z.i := l4var210z.i - 300000000B;
            if l4var210z.i >= 4096 then {
                l4var213z := true;
                l4var210z.i := l4var210z.i - 4096;
            } else {
                l4var213z := false;
            };
            if (l4var210z.i = 0) then
                form1Insn(insnTemp[U1A] + moduleOffset + 2);
            P3363;
            form1Insn(insnTemp[VJM] + 2 + moduleOffset);
            formLabel;
            if (l4var210z.i <> 0) then {
                if (not F3413) then
                    error(211);
                P0715(0, l4var7z@.f[2].i);
            };
            l4var213z := not l4var213z;
            P3363;
            formLabel;
            exit iter
        }; (* 4230 *)
        if (l4var210z.i >= 200000000B) then {
            l4var7z := ptr(l4var210z.i - 200000000B);
            P0715(0, l4var7z@.f[2].i);
            l4var7z@.f[3].i := moduleOffset;
        } else {
            l4var210z.i := l4var210z.i - macro;
            curVal.m := l4var210z.m * [0, 1, 3, 28:32];
            int51z := curVal.i;
            curVal.m := [0, 1, 3, 33:47] * l4var210z.m;
            l4var7z := ptr(curVal.i);
            formJumpOnCond(l4var7z@.f[2].i);
            int51z := insnTemp[VJM];
            exit iter
        }
    }; (* loop *)
    insnList := NIL;
    while (l4var6z <> NIL) do {
        with l4var6z@ do
            if (f[3].i = 0) then {
                jumpTarget := f[2];
                exit;
            } else
                l4var6z := f[0].e;
    };
    set146z := set146z - set145z;
}; (* genOneOp *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToInsnList(l4arg1z: integer);
var l4var1z: @expr;
{
    new(l4var1z);
    with l4var1z@ do {
        f[0].s := NIL; f[1].i := 0;
        f[2].i := l4arg1z; f[3].i := 0;
    };
    with insnList@ do {
        if f[0].s = NIL then
            f[1].e := l4var1z
        else
            f[0].s@.f[0].e := l4var1z;
        f[0].e := l4var1z
    }
}; (* addToInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addInsnAndModify(l4arg1z, l4arg2z: integer);
{
    addToInsnList(l4arg1z);
    insnlist@.f[0].s@.f[3].i := l4arg2z
}; (* addInsnAndModify *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addxToInsnList(l4arg1z: integer);
var
    l4var1z: @expr;
{
    new(l4var1z);
    with l4var1z@ do {
        f[0] := insnList@.f[1];
        f[1].i := 0;
        f[2].i := l4arg1z;
        f[3].i := 0;
    };
    if (insnList@.f[1].s = NIL) then {
        insnList@.f[0].e := l4var1z;
    };
    insnList@.f[1].e := l4var1z;
}; (* addxToInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4343;
label
    4545, 4602;
var
    helper: integer;
    l4var2z, l4var3z, l4var4z, l4var5z,
    l4var6z, l4var7z, l4var8z, l4var9z: word;
{
    l4var4z := insnList@.f[2];
    with insnList@ do {
        case f[4].c of
        '_000':{
            curVal := f[5];
            if (l4var4z.s@.f[0].i = 1) then
                curVal.i := getFCSToffset;
            addToInsnList(constRegTemplate.i + curInsnTemplate.i + curVal.i);
        };
        '_001':{
            helper := insnList@.f[7].i;
            l4var2z := insnList@.f[5];
            l4var3z := insnList@.f[6];
            if (15 < helper) then {
                (* empty *)
            } else {
                if (helper = 15) then { (* P/CP *)
                    addToInsnList(macro + 6);
                } else {
                    helper := indexreg[insnList@.f[7].i];
                    if (l4var2z.i = 0) and (insnList@.f[8].c = '_000') then {
                        addInsnAndModify(helper + curInsnTemplate.i,
                                         l4var3z.i);
                        goto 4602;
                    } else {
                        addToInsnList(helper + insnTemp[WTC]);
                        (q) exit q (* workaround *)
                    }
                }
            };
            l4var6z := insnList@.f[8];
            if l4var6z.c = '_000' then {
                addInsnAndModify(l4var2z.i + curInsnTemplate.i, l4var3z.i);
            } else {
                l4var5z := l4var4z.s@.f[2];
                if (l4var5z.c < '_004') or
                   (l4var5z.c = '_006') and (s6 in optSflags.m) then {
                    l4var7z.b := true;
                    l4var8z.b := typeCheck(l4var4z.t, integerType);
                } else {
                    l4var7z.b := false;
                    l4var8z.b := false;
                };
                if l4var6z.c = '_001' then {
                    if (l4var3z <> l4var2z) or
                       (helper <> 18) or (* P/RC *)
                       (l4var2z.i <> 0) then
                        addInsnAndModify(l4var2z.i + insnTemp[XTA],
                                         l4var3z.i);
                    l4var3z := insnList@.f[10];
                    l4var2z := insnList@.f[9];
                    l4var9z.b := true;
                    helper := (l4var3z.i + l4var2z.i);
                    if l4var7z.b then {
                        if (30 < l4var3z.i) then {
                            addToInsnList(ASN64-48 + l4var3z.i);
                            addToInsnList(insnTemp[YTA]);
                            if (helper = 48) then (* P/RDR *)
                                l4var9z.b := false;
                        } else {
                            if (l4var3z.i <> 0) then
                                addToInsnList(ASN64 + l4var3z.i);
                        }; (* 4477 *)
                        if l4var9z.b then {
                            curVal.m := [(48 - l4var2z.i)..47];
                            addToInsnList(40110000B + getFCSToffset);
                        }
                    } else { (* 4511 *)
                        if (helper <> 48) then
                            addToInsnList(ASN64-48 + helper);
                        curVal.m := [0..(l4var2z.i-1)];
                        addToInsnList(40110000B + getFCSToffset);
                    }; (* 4525 *)
                    if l4var8z.b then
                        addToInsnList(04120011B);
                } else { (* 4531 *)
                    if l4var7z.b then
                        helper := ord(l4var8z.b)+74 (* P/LDAR[IN] *)
                    else
                        helper := 56; (* P/RR *)
                    addToInsnList(getHelperProc(helper));
                    insnList@.f[0].s@.f[1].i := 1;
                }
            };
            goto 4545;
        };
        '_002': {
4545:       if bool49z and (l4var4z.t = booleanType) and
               (16 in insnList@.f[3].m) then
                addToInsnList(04120010B);
        };
        '_003': { (* 4555 *)
            if bool49z then
                addInsnAndModify(100000024B,
                    ord(16 in insnList@.f[3].m)*10000B + insnList@.f[5].i);
        };
        end; (* case *)
4602:
    }; (* with *)
    with insnList@ do {
        f[4].c := '_002';
        f[3].m := f[3].m + [0];
    };
}; (* P4343 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4606;
{
    P4343;
    addToInsnList(macro + 5)
}; (* P4606 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4621(reg: integer);
label
    4650, 4654;
var
    l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
    l4var6z, l4var7z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4613;
{
    l4var1z := insnList@.f[6];
    l4var1z.i := l4var1z.i mod 32768;
    l4var6z := l4var1z
}; (* P4613 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P4621 *)
    with insnList@ do {
        l4var2z := f[7];
        l4var3z.i := insnTemp[UTM];
        l4var7z.i := indexreg[reg];
        l4var4z := f[5];
        f[3].m := f[3].m + [reg];
        if (f[4].c = '_000') then {
            curVal := f[5];
            if (f[2].s@.f[0].i = 1) then
                curVal.i := addSomethingToFCST;
            l4var6z := curVal;
            l4var5z.i := 30721;
            goto 4654;
        } else if (l4var2z.i = 18) then {
4650:       P4613;
            if (l4var4z.i = indexreg[1]) then {
                l4var5z.i := 30723;
4654:           l4var1z.i := 100000000B * l4var5z.i + l4var6z.i;
                l4var6z.i := allocSymtabForAbsolute(l4var1z.m * [12:47]);
                addToInsnList(l4var7z.i + l4var3z.i + l4var6z.i);
            } else if (l4var4z.i <> 0) then {
                addInsnAndModify(l4var4z.i + insnTemp[WTC], l4var6z.i);
                addToInsnList(l4var7z.i + l4var3z.i);
            } else {
                addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i);
            }
        } else if (l4var2z.i = 17) then {
            P4613;
            l4var4z := insnList@.f[6];
            l4var5z.i := insnList@.f[0].s@.f[2].i - insnTemp[WTC];
            if (l4var4z.i <> 0) then {
                l4var1z.i := 100000000B * l4var5z.i + l4var4z.i;
                l4var5z.i := allocSymtabForAbsolute(l4var1z.m * [12:47]);
            };
            insnList@.f[0].s@.f[2].i := l4var7z.i + l4var5z.i + l4var3z.i;
        } else if (l4var2z.i = 16) then {
            P4613;
            if (l4var4z.i <> 0) then
                addToInsnList(l4var4z.i + insnTemp[WTC]);
            addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i);
        } else if (l4var2z.i = 15) then {
            addToInsnList(insnTemp[ATI] + reg);
            l4var3z.i := insnTemp[UZA];
            goto 4650;
        } else {
            addToInsnList(indexreg[l4var2z.i] + insnTemp[WTC]);
            goto 4650;
        }
    }; (* with *)
    insnList@.f[4].c := '_001';
    insnList@.f[7].i := reg;
    insnList@.f[6].i := 0;
    insnList@.f[5].i := 0;
}; (* P4621 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4755;
var
    l4var1z, l4var2z, l4var3z, l4var4z, l4var5z, l4var6z, l4var7z: word;
{
    with insnList@ do
        l4var1z := f[7];
    if (15 < l4var1z.i) then {
        (* nothing? *)
    } else if (l4var1z.i = 15) then {
        addToInsnList(macro + 6)
    } else {
        addToInsnList(indexreg[l4var1z.i] + insnTemp[WTC]);
    };
    l4var4z.b := 0 in insnList@.f[3].m;
    l4var6z := insnList@.f[8];
    if (l4var6z.c <> '_000') or l4var4z.b then
        addxToInsnList(macro + 5);
    if (l4var6z.c = '_000') then {
        if (l4var4z.b) then {
            addInsnAndModify(insnList@.f[5].i + insnTemp[WTC],
                             insnList@.f[6].i);
            addToInsnList(100000023B);
        } else {
            addInsnAndModify(insnList@.f[5].i, insnList@.f[6].i);
        }
    } else {
        l4var7z := insnList@.f[2].s@.f[2];
        l4var1z := insnList@.f[2].s@.f[1];
        l4var5z.b := (l4var7z.c < '_004') or
                     (l4var7z.c = '_006') and (S6 in optSflags.m);
        if (l4var6z.c = '_001') then {
            l4var2z := insnList@.f[10];
            l4var3z.i := (l4var2z.i + insnList@.f[9].i);
            if l4var5z.b then {
                if (l4var2z.i <> 0) then
                    addxToInsnList(ASN64 - l4var2z.i);
            } else {
                if (l4var3z.i <> 48) then
                    addxToInsnList(ASN64 + 48 - l4var3z.i);
            };
            addInsnAndModify(insnTemp[WTC] + insnList@.f[5].i,
                             insnList@.f[6].i);
            curVal.m := [0..47] - [(48-l4var3z.i)..(47 -l4var2z.i)];
            addInsnAndModify(100000026B, getFCSToffset);
        } else {
            if not l4var5z.b then {
                l4var2z.i := (insnList@.f[9].i - l4var1z.i);
                if (l4var2z.i <> 0) then
                    addxToInsnList(ASN64 - l4var2z.i);
                addxToInsnList(insnTemp[YTA]);
                addxToInsnList(ASN64 - l4var1z.i);
            };
            addToInsnList(getHelperProc(77)); (* "P/STAR" *)
            insnList@.f[0].s@.f[1].i := 1;
        }
    }
}; (* P4755 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5117(l4arg1z: char);
{
    addInsnAndModify(curFrameRegTemplate, l2var20z);
    new(curExpr);
    with curExpr@ do
        f[0] := insnList@.f[2];
    genOneOp;
    curExpr@.f[1].c := l4arg1z;
    curExpr@.f[2].i := l2var20z;
    l2var20z := l2var20z + 1;
    if (l2var21z < l2var20z) then
        l2var21z := l2var20z;
}; (* P5117 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F5142: integer;
var
    l4var1z: integer;
    l4var2z: @struc;
{
    l4var1z := 0;
    l4var2z := insnList@.f[1].s;
    while (l4var2z <> NIL) do {
        l4var2z := l4var2z@.f[0].s;
        l4var1z := l4var1z + 1;
    };
    F5142 := l4var1z;
}; (* F5142 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genFullExpr(l4arg1z: @expr);
label
    7567, 7760, 10075, 10122;
var
    arg1Const, arg2Const: boolean;
    l4var3z: @struc;
    l4var4z, l4var5z: word;
    curOP: operator;
    l4var7z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5155;
{
    P4343;
    insnList@.f[4].c := '_001';
    insnList@.f[8].c := '_000';
    insnList@.f[6].i := 0;
    insnList@.f[5].i := 0;
    insnList@.f[7].i := 18;
}; (* P5155 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5170;
label
    5220;
var
    l5var1z, l5var2z: word; l5var3z: boolean;
{
    l5var3z := checkBounds and not (NoPtrCheck in optSflags.m)
               and (curOP = op42);
    if not l5var3z and (
        (insnList@.f[8].c = '_000') or
        (insnList@.f[8].c = '_001') and
        (insnList@.f[10].i = 0))
    then {
        l5var1z := insnList@.f[7];
        l5var2z := insnList@.f[6];
        if (l5var1z.i = (18)) or (l5var1z.i = (16)) then {
5220:       addInsnAndModify((insnList@.f[5].i + insnTemp[VTM]), l5var2z.i);
        } else {
            if (l5var1z.i = (17)) then {
                if (l5var2z.i = (0)) then {
                    insnList@.f[0].s@.f[2].i := insnList@.f[0].s@.f[2].i +
                                                insnTemp[XTA];
                } else
                    goto 5220;
            } else if (l5var1z.i = (15)) then {
                addToInsnList(macro + 6);
                goto 5220;
            } else
                addInsnAndModify((indexreg[l5var1z.i] + insnTemp[VTM]),
                                 l5var2z.i);
        }
    } else {
        P5155;
        if (l5var3z) then {
            addToInsnList((72400000B + lineCnt));
            addToInsnList(getHelperProc(7)); (* "P/CA"*)
            insnList@.f[0].s@.f[1].i := (1);
        };
        addToInsnList(macro + 6);
    };
    insnList@.f[6].i := (0);
    insnList@.f[5].i := (0);
    insnList@.f[7].i := (16);
}; (* P5170 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5270;
{
    P4606;
    l3var12z := insnList;
    insnList := l4var3z;
    P4343;
    addToInsnList(getHelperProc(l3var4z));
    insnList@.f[3].m := insnList@.f[3].m + l3var12z@.f[3].m + [11:14];
    l3var12z@.f[0].s@.f[0] := insnList@.f[1];
    insnList@.f[1] := l3var12z@.f[1];
}; (* P5270 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5314;
var
    l5var1z: boolean;
    l5var2z: @struc;
{
    l5var1z := 12 in l4var3z@.f[3].m;
    P4621(12);
    if (l5var1z) then {
        addToInsnList(00420014B);
        addToInsnList(macro + 5);
    };
    l5var2z := insnList;
    insnList := l4var3z;
    P4621((14));
    if (l5var1z) then {
        addToInsnList(macro + 4);
        addToInsnList(00400014B);
    };
    l5var2z@.f[3].m := (insnList@.f[3].m + l5var2z@.f[3].m);
    l5var2z@.f[0].s@.f[0] := insnList@.f[1];
    l5var2z@.f[0] := insnList@.f[0];
    insnList := l5var2z;
}; (* P5314 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5354(l5arg1z: @types);
var
    l5var1z: integer;
    l5var2z, l5var3z, l5var4z: word;
{
    l5var1z := l5arg1z@.s8.f[4].i;
    if (l5var1z = (0)) then {
        curVal := l5arg1z@.s8.f[5];
        l5var4z := l5arg1z@.s8.f[6];
        if (l5arg1z@.base <> integerType) then {
            curVal.m := curVal.m * [7:47];
            l5var4z.m := l5var4z.m * [7:47];
        };
        glob95z.i := (0);
        formInsnAndLabel((03000005B + moduleOffset));
        l5arg1z@.s8.f[4].i := moduleOffset;
        l5var1z := moduleOffset;
        P0715((1), l5var4z.i);
        formInsnAndLabel(67000000B);
    };
    P4343;
    addToInsnList((72400000B + lineCnt));
    addToInsnList((67100000B + l5var1z));
    insnList@.f[0].s@.f[1].i := (1);
}; (* P5354 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5420;
{
    if (insnList@.f[4].c = '_000') then {
        insnList@.f[5].b := not insnList@.f[5].b;
    } else {
        insnList@.f[3].m := insnList@.f[3].m mod [16];
    }
}; (* P5420 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5433(l5arg1z: boolean);
label
    100, 22, 33;
var
    l5var1z: integer;
    l5var2z: @struc;
{
    if not (0 in l4var3z@.f[3].m) then {
        l5var1z := (0);
    } else
(stmt)
    if not (0 in insnList@.f[3].m) then {
        l5var1z := ord(l5arg1z) + 1;
    } else {
        l5var1z := (3);
        exit stmt; (* workaround *)
    };
    case l5var1z of
    0:
100: {
        P4343;
        l3var12z := insnList;
        insnList := l4var3z;
        curInsnTemplate.i := l3var4z;
        P4343;
        curInsnTemplate.i := insnTemp[XTA];
    };
    1:
        if (l3var4z = insnTemp[SUB]) then {
            l3var4z := insnTemp[RSUB];
            goto 22;
        } else
            goto 33;
   2:
22: {
        l3var12z := insnList;
        insnList := l4var3z;
        l4var3z := l3var12z;
        goto 100;
    };
    3:
33: {
        P4343;
        addToInsnList(indexreg[15] + l3var4z);
        l5var2z := insnList;
        insnList := l4var3z;
        P4606;
        l3var12z := insnList;
        insnList := l5var2z;
    };
    end; (* case *)
    insnList@.f[0].s@.f[1].i := (0);
    l3var12z@.f[0].s@.f[0] := insnList@.f[1];
    insnList@.f[1] := l3var12z@.f[1];
    insnList@.f[3].m := insnList@.f[3].m + [0];
}; (* P5433 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5531;
var
    l5var1z, l5var2z: boolean;
    l5var3z, l5var4z, l5var5z, l5var6z, l5var7z: integer;
    l5var8z: @struc;
    l5var9z: word;
{
    if (arg1Const) then {
        if (l4var4z.b) then
            insnList := l4var3z;
    } else if (arg2Const) then {
        if (not l4var5z.b) then
            insnList := l4var3z;
    } else {
        l5var1z := 16 in insnList@.f[3].m;
        l5var2z := 16 in l4var3z@.f[3].m;
        l5var5z := int94z;
        int94z := (int94z + (1));
        bool49z := false;
        l5var6z := ord(l5var1z) + macro;
        l5var7z := ord(l5var2z) + macro;
        if (insnList@.f[4].c = '_003') then {
            l5var3z := insnList@.f[5].i;
        } else {
            l5var3z := (0);
            P4343;
        };
        if (l4var3z@.f[4].c = '_003') then {
            l5var4z := l4var3z@.f[5].i;
        } else {
            l5var4z := (0);
        };
        l5var9z.m := (insnList@.f[3].m + l4var3z@.f[3].m);
        if (l5var3z = (0)) then {
            if (l5var4z = (0)) then {
                addInsnAndModify(l5var6z, l5var5z);
                l5var8z := insnList;
                insnList := l4var3z;
                P4343;
                addInsnAndModify(l5var7z, l5var5z);
            } else {
                if (l5var2z) then {
                    addInsnAndModify(l5var6z, l5var5z);
                    l5var8z := insnList;
                    insnList := l4var3z;
                    addInsnAndModify(macro + 2,
                                     10000B * l5var5z + l5var4z);
                } else {
                    addInsnAndModify(l5var6z, l5var4z);
                    l5var5z := l5var4z;
                    l5var8z := insnList;
                    insnList := l4var3z;
                }
            };
        } else {
            if (l5var4z = (0)) then {
                if (l5var1z) then {
                    addInsnAndModify(macro + 2,
                                     10000B * l5var5z + l5var3z);
                    l5var8z := insnList;
                    insnList := l4var3z;
                    P4343;
                    addInsnAndModify(l5var7z, l5var5z);
                } else {
                    l5var8z := insnList;
                    insnList := l4var3z;
                    P4343;
                    addInsnAndModify(l5var7z, l5var3z);
                    l5var5z := l5var3z;
                };
            } else {
                if (l5var1z) then {
                    if (l5var2z) then {
                        addInsnAndModify(macro + 2,
                                         10000B * l5var5z + l5var3z);
                        l5var8z := insnList;
                        insnList := l4var3z;
                        addInsnAndModify(macro + 2,
                                         10000B * l5var5z + l5var4z);
                    } else {
                        addInsnAndModify(macro + 2,
                                         10000B * l5var4z + l5var3z);
                        l5var8z := insnList;
                        insnList := l4var3z;
                        l5var5z := l5var4z;
                    }
                } else {
                    l5var8z := insnList;
                    insnList := l4var3z;
                    l5var5z := l5var3z;
                    if (l5var2z) then
                        addInsnAndModify(macro + 2,
                                         10000B * l5var3z + l5var4z)
                    else
                        addInsnAndModify(macro + 3,
                                         10000B * l5var3z + l5var4z);
                }
            }
        };
        insnList@.f[3].m := l5var9z.m - [16];
        l5var8z@.f[0].s@.f[0] := insnList@.f[1];
        insnList@.f[1] := l5var8z@.f[1];
        insnList@.f[4].c := '_003';
        insnList@.f[5].i := l5var5z;
        bool49z := true;
        exit; (* workaround *)
    }
}; (* P5531 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5757;
var
    l5var1z, l5var2z, l5var3z, l5var4z, l5var5z, l5var6z,
        l5var7z, l5var8z: integer;
    l5var9z: struc;
    l5var20z, l5var21z: @struc;
    l5var22z, l5var23z: word;
    l5var24z: boolean;
    l5var25z: word;
    l5var26z: @struc;
    l5var27z: @types;
    l5var28z: word;
    l5var29z: @expr;
    l5var30z: array[1..10] of word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function myminel(l6arg1z: bitset): integer;
{
    myminel := minel(l6arg1z);
}; (* myminel *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P5757 *)
    l5var2z := (0);
    l5var29z := l4arg1z;
    while (l5var29z@.f[1].c = '_034') do {
        genFullExpr(l5var29z@.f[3].e);
        l5var2z := (l5var2z + (1));
        l5var30z[l5var2z].s := insnList;
        l5var29z := l5var29z@.f[2].e;
    };
    genFullExpr(l5var29z);
    l5var21z := insnList;
    l5var9z := insnList@;
    l5var20z := ref(l5var9z);
    l5var22z.m := set147z;
    for l5var3z to l5var2z do
       l5var22z.m := l5var22z.m - l5var30z[l5var3z].s@.f[3].m;
    for l5var3z := l5var2z downto 1 do {
        l5var26z := l5var9z.f[2].s@.f[3].s;
        l5var27z := l5var9z.f[2].s@.f[4].t;
        l5var25z := l5var9z.f[2].s@.f[5];
        l5var7z := l5var27z@.left;
        l5var8z := l5var26z@.f[0].i;
        if not l5var25z.b then
            l5var9z.f[6].i := l5var9z.f[6].i - l5var8z * l5var7z;
        insnList := l5var30z[l5var3z].s;
        l5var28z := insnList@.f[4];
        if (l5var28z.c = '_000') then {
            curVal := insnList@.f[5];
            curVal.m := curVal.m +  intZero;
            if (curVal.i < l5var7z) or
               (l5var27z@.right < curVal.i) then
                error(29); (* errIndexOutOfBounds *)
            if (l5var25z.b) then {
                l5var4z := (curVal.i - l5var7z);
                l5var5z := l5var9z.f[2].s@.f[6].i;
                l5var9z.f[3].m := l5var9z.f[3].m + [0];
                l5var9z.f[6].i := l5var4z DIV l5var5z + l5var9z.f[6].i;
                l5var6z := (l5var5z-1-l5var4z MOD l5var5z) *
                           l5var9z.f[2].s@.f[7].i;
                case l5var9z.f[8].c of
                '_000': l5var9z.f[10].i := l5var6z;
                '_001': l5var9z.f[10].i := l5var9z.f[10].i + l5var6z +
                                           l5var9z.f[2].s@.f[1].i - 48;
                '_002': error(errUsingVarAfterIndexingPackedArray);
                end; (* case *)
                l5var9z.f[9] := l5var9z.f[2].s@.f[7];
                l5var9z.f[8].b := true;
            } (* 6116 *) else {
                l5var9z.f[6].i := curVal.i  * l5var26z@.f[0].i +
                                  l5var9z.f[6].i;
            }
        } else { (* 6123*)
            if (checkBounds) then {
                l5var24z := typeCheck(l5var27z, insnList@.f[2].t);
                if (rangeMismatch) then
                    P5354(l5var27z);
            };
            if (l5var8z <> (1)) then {
                P4343;
                if (l5var27z@.base = integerType) then {
                    l5var4z := 00310100B;
                } else {
                    l5var4z := 00310030B;
                };
                addToInsnList(l5var9z.f[2].s@.f[6].i);
                insnList@.f[0].s@.f[1].i := (1);
                if (l5var7z >= (0)) then
                    addToInsnList(l5var4z)
                else
                    addToInsnList(macro + mcMULTI);
           };
           if (l5var28z.c = '_003') or
              (l5var28z.c = '_001') and
              (insnList@.f[8].c <> '_000') then
               P4343;
           l5var23z.m := (l5var9z.f[3].m + insnList@.f[3].m);
           if (not l5var25z.b) then {
               if (l5var9z.f[7].i = (18)) then {
                    if (insnList@.f[4].c = '_002') then {
                        l5var9z.f[7].i := (15);
                    } else { (* 6200 *)
                        l5var9z.f[7].i := (16);
                        curInsnTemplate.i := insnTemp[VTM];
                        P4343;
                        curInsnTemplate.i := insnTemp[XTA];
                    }; (* 6205 *)
                    l5var9z.f[0] := insnList@.f[0];
                    l5var9z.f[1] := insnList@.f[1];
                } else { (* 6211 *)
                    if (l5var9z.f[7].i >= (15)) then {
                        l5var1z :=  myminel(l5var22z.m);
                        if ((0) >= l5var1z) then {
                            l5var1z := myminel(set147z - l5var9z.f[3].m);
                            if ((0) >= l5var1z) then
                                l5var1z := (9);
                        };
                        l3var12z := insnList;
                        insnList := l5var20z;
                        l5var23z.m := l5var23z.m + [l5var1z];
                        if (l5var9z.f[7].i = (15)) then {
                            addToInsnList(insnTemp[ATI] + l5var1z);
                        } else {
                            addToInsnList(indexreg[l5var1z] + insnTemp[UTM]);
                        };
                        l5var9z.f[7].i := l5var1z;
                        l5var9z.f[3].m := l5var9z.f[3].m + [l5var1z];
                        insnList := l3var12z;
                    } else {
                            l5var1z := l5var9z.f[7].i;
                    }; (* 6251 *)
                    if (l5var1z IN insnList@.f[3].m) then {
                         P4606;
                         insnList@.f[0].s@.f[0] := l5var9z.f[1];
                         l5var9z.f[1] := insnList@.f[1];
                         insnList := l5var20z;
                         addInsnAndModify(100000010B, l5var1z);
                    } else {
                         if (insnList@.f[4].c = '_002') then {
                             addInsnAndModify(100000011B, l5var1z);
                         } else {
                             curInsnTemplate.i := insnTemp[VTM];
                             P4343;
                             curInsnTemplate.i := insnTemp[XTA];
                             addToInsnList(indexreg[l5var1z] + insnTemp[UZA]);
                         };
                         l5var9z.f[0].s@.f[0] := insnList@.f[1];
                         l5var9z.f[0] := insnList@.f[0];
                     }
                }; (* 6305 *)
           } else { (* 6306 *)
                if (l5var9z.f[8].c = '_000') then {
                    P4343;
                    if (l5var7z <> (0)) then {
                        curVal.i := ((0) - l5var7z);
                        if (not typeCheck(insnList@.f[2].t, integerType)) then
                            curVal.m := curVal.m - intZero;
                        addToInsnList(40040000B + getFCSToffset);
                        insnList@.f[0].s@.f[1].i := (1);
                    };
                    l5var24z := 0 in l5var9z.f[3].m;
                    if (l5var24z) then
                        addToInsnList(macro + 5);
                    l3var12z := insnList;
                    insnList := l5var20z;
                    P4621((14));
                    if (l5var24z) then
                        addToInsnList(macro + 4);
                    l5var23z.m := l5var23z.m + [0, 10, 11, 13, 14];
                    l5var9z.f[8].c := '_002';
                    l5var9z.f[6].i := (0);
                    l5var9z.f[5].i := (0);
                    l5var9z.f[9] := l5var9z.f[2].s@.f[7];
                    curVal := l5var9z.f[9];
                    if (curVal.i = (24)) then
                        curVal.i := (7);
                    curVal := curVal;besm(ASN64-24);curVal:=;
                    addToInsnList(allocSymtabForAbsolute(
                        helperNameBase[76].m + curVal.m) + 56400000B);
                    l5var9z.f[7].i := (16);
                    l5var9z.f[10].i := (0);
                    l3var12z@.f[0].s@.f[0] := l5var9z.f[1];
                    l5var9z.f[1] := l3var12z@.f[1];
                } else {
                    error(errUsingVarAfterIndexingPackedArray);
                }
            }; (* 6403 *)
            l5var9z.f[3] := l5var23z;
        };
        l5var9z.f[2].s := l5var26z;
    }; (* 6406 *)
    insnList := l5var21z;
    insnList@ := l5var9z;
}; (* P5757 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P6470;
label 7007;
var
    l5var1z, l5var2z, l5var3z, l5var4z, l5var5z,
    l5var6z, l5var7z, l5var8z, l5var9z, l5var10z,
    l5var11z, l5var12z, l5var13z, l5var14z, l5var15z,
    l5var16z, l5var17z, l5var18z, l5var19z, l5var20z,
    l5var21z, l5var22z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocGlobalObject(l6arg1z: @identrec): integer;
{
    if (l6arg1z@.f[10].i = (0)) then {
        if (l6arg1z@.f[11].m * [20, 21] <> []) then {
            curVal := l6arg1z@.id;
            curVal := makeNameWithStars(true);
            l6arg1z@.f[10].i := allocExtSymbol(glob139z);
        } else {
            l6arg1z@.f[10].i := symTabPos;
            putToSymTab([]);
        }
    };
    allocGlobalObject := l6arg1z@.f[10].i;
}; (* allocGlobalObject *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P6443(l6arg1z: boolean);
{
    if not (debugEntry in optSflags.m) then
        exit;
    curVal := l5var5z.s@.f[0];
    addToInsnList(52400000B + addSomethingToFCST);
    if (l6arg1z) then
        addToInsnList((56400000B + lineCnt));
    addToInsnList(getHelperProc(ord(l6arg1z) * 22 + 57)); (* P/C(E|I) *)
}; (* P6443 *)
%
{ (* P6470 *)
    l5var1z := l4arg1z@.f[2];
    l5var5z := l4arg1z@.f[3];
    l5var7z.b := (l5var5z.s@.f[3].s = NIL);
    l5var9z.b := (l5var5z.s@.f[5].s = NIL);
    if (l5var7z.b) then
        l5var13z.i := (3) else l5var13z.i := (4);
    l5var12z := l5var5z.q@.f[11];
    l5var10z.b := (21 in l5var12z.m);
    l5var11z.b := (24 in l5var12z.m);
    if (l5var9z.b) then {
        l5var14z.i := F3307(l5var5z.q);
        l5var6z := l5var5z.s@.f[7];
    } else {
        l5var13z.i := (l5var13z.i + (2));
    };
    new(insnList);
    insnList@.f[1].s := NIL;
    insnList@.f[0].s := NIL;
    insnList@.f[2] := l5var5z.s@.f[3];
    insnList@.f[3].m := (l5var5z.q@.f[11].m + [7:15]) * [0:8, 10:15];
    insnList@.f[4].c := '_002';
    if (l5var10z.b) then {
        l5var8z.b := not l5var7z.b;
        if (checkFortran) then {
            addToInsnList(getHelperProc(92)); (* "P/MF" *)
        }
    } else {
        l5var8z.b := true;
        if (not l5var9z.b) and (l5var1z.s <> NIL)
            or (l5var9z.b) and (l5var14z.i >= (2)) then {
            addToInsnList((76500000B + l5var13z.i));
        };
    };
    l5var14z.i := (0);
(loop)
    while l5var1z.s <> NIL do { (* 6574 *)
        l5var2z := l5var1z.s@.f[3];
        l5var1z := l5var1z.s@.f[2];
        l5var21z := l5var2z.s@.f[1];
        l5var14z.i := (l5var14z.i + (1));
        l5var20z.s := insnList;
        if (l5var21z.c = '_046') or (l5var21z.c = '_047') then {
            l5var4z := l5var2z.s@.f[3];
            new(insnList);
            insnList@.f[1].s := NIL;
            insnList@.f[0].s := NIL;
            insnList@.f[3].m := [];
            set145z := set145z + l5var4z.q@.f[11].m;
            if (l5var4z.s@.f[5].s <> NIL) then {
                addToInsnList(l5var4z.s@.f[1].i + insnTemp[XTA] +
                              l5var4z.s@.f[6].i);
                if (l5var10z.b) then
                    addToInsnList(getHelperProc(19)); (* "P/EA" *)
            } else
(a)         { (* 6636 *)
                if (l5var4z.s@.f[6].i = (0)) then {
                    if (l5var10z.b) and (21 in l5var4z.q@.f[11].m) then {
                        addToInsnList(allocGlobalObject(l5var4z.q) +
                                      72400000B);
                        addToInsnList(00420016B);
                        exit a;
                    } else { (* 6651 *)
                        l5var16z.i := (0);
                        formJumpOnCond(l5var16z.i);
                        formLabel;
                        l5var4z.s@.f[6].i := moduleOffset;
                        l5var3z := l5var4z.s@.f[7];
                        l5var15z.i := ord(l5var4z.s@.f[3].s <> NIL);
                        l5var17z.i := F3307(l5var4z.q);
                        form3Insn(52400004B + moduleOffset,
                                  46400000B + l5var15z.i,
                                  42474001B);
                        formInsnAndLabel(getHelperProc(62)); (* "P/BP" *)
                        l5var15z.i := l5var17z.i + 2 + l5var15z.i;
                        form1Insn(74100000B + l5var15z.i);
                        if ((1) < l5var17z.i) then
                            form1Insn(76500000B + l5var15z.i)
                        else
                            form1Insn(0);
                        form2Insn(
                            getHelperProc(63(*P/B6*)) + 6437777777300000C,
                            allocGlobalObject(l5var4z.q) + 03000000B);
                        if (l5var3z.s <> NIL) then {
                            repeat
                                l5var22z := l5var3z.s@.f[4];
                                if (l5var22z.c = '_002') and
                                   (l5var3z.s@.f[3].s <> NIL) then
                                    l5var22z.c := '_001';
                                form2Insn(0, ord(l5var22z.c));
                                l5var3z := l5var3z.s@.f[5];
                            until (l5var4z = l5var3z);
                        }; (* 6745 *)
                        storeObjWord([]);
                        P0715(0, l5var16z.i);
                    }
                }; (* 6752 *)
                addToInsnList((72400000B + l5var4z.q@.f[6].i));
                if 21 in l5var4z.q@.f[11].m then
                    addToInsnList(00420016B)
                else
                    addToInsnList(getHelperProc(64)); (* "P/PB" *)
            }; (* 6765 *)
            if (l5var21z.c = '_046') then
                l5var22z.c := '_002'
            else
                l5var22z.c := '_001';
        } else { (* 6772 *)
            genFullExpr(l5var2z.e);
            if (insnList@.f[4].c = '_001') then
                l5var22z.c := '_004'
            else
                l5var22z.c := '_003';
        }; (* 7001 *)
        if not (not l5var9z.b or (l5var22z.c <> '_004') or
               (l5var6z.s@.f[4].c <> '_003')) then
            l5var22z.c := '_003';
7007:   if (l5var22z.c = '_004') or (l5var11z.b) then {
            P4621(14);
            addToInsnList(00420016B);
        } else if (l5var22z.c = '_003') then {
            if (insnList@.f[2].s@.f[0].i <> (1)) then {
                l5var22z.c := '_004';
                goto 7007; (* a structural label doesn't work *)
            } else {
                P4343;
                (q) exit q (* workaround *)
            }
        }; (* 7027 *)
        if not l5var8z.b then
            addxToInsnList(macro + 5);
        l5var8z.b := false;
        if (l5var20z.s@.f[0].s <> NIL) then {
            l5var20z.s@.f[0].s@.f[0] := insnList@.f[1];
            insnList@.f[1] := l5var20z.s@.f[1];
        };
        insnList@.f[3].m := insnList@.f[3].m + l5var20z.s@.f[3].m;
        if not l5var9z.b then {
            curVal := l5var22z;
            addToInsnList(40030000B + getFCSToffset);
        };
        if l5var9z.b and not l5var11z.b then
            l5var6z := l5var6z.s@.f[5];
    }; (* while -> 7061 *)
    P6443(true);
    if l5var10z.b then {
        addToInsnList(00370002B);
        insnList@.f[0].s@.f[1].i := (4);
    };
    if l5var9z.b then {
        addToInsnList(allocGlobalObject(l5var5z.q) + 67100000B);
        if (20 in l5var5z.q@.f[11].m) then {
            l5var17z.i := (1);
        } else {
            l5var17z.i := l5var5z.q@.offset div 4000000B;
        } (* 7102 *)
    } else { (* 7103 *)
        l5var15z.i := (0);
        if (l5var14z.i = (0)) then {
            l5var17z.i := (l5var13z.i + (1));
        } else {
            l5var17z.i := -(2 * l5var14z.i + l5var13z.i);
            l5var15z.i := (1);
        }; (* 7115 *)
        addInsnAndModify(100000020B + l5var15z.i,
                         getValueOrAllocSymtab(l5var17z.i));
        addToInsnList(l5var5z.s@.f[1].i + insnTemp[WTC] + l5var5z.s@.f[6].i);
        addToInsnList(100000022B);
        l5var17z.i := (1);
    }; (* 7132 *)
    insnList@.f[0].s@.f[1].i := (2);
    if (curProcNesting <> l5var17z.i) then {
        if not l5var10z.b then {
            if ((l5var17z.i + (1)) = curProcNesting) then {
                addToInsnList((34440000B + curProcNesting));
            } else {
                l5var15z := frameRestore[curProcNesting][l5var17z.i];
                if (l5var15z.i = (0)) then {
                    curVal.i := 6017T; (* P/ *)
                    l5var19z.i := (curProcNesting + (16));
                    besm(ASN64-30);
                    l5var19z := ;
                    l5var18z.i := (l5var17z.i + (16));
                    besm(ASN64-24);
                    l5var18z := ;
                    curVal.m := curVal.m + l5var19z.m + l5var18z.m;
                    l5var15z.i := allocExtSymbol(glob139z);
                    frameRestore[curProcNesting][l5var17z.i] := l5var15z;
                };
                addToInsnList((67100000B + l5var15z.i));
            }
        }
    }; (* 7176 *)
    if not l5var9z.b or ([20, 21] * l5var12z.m <> []) then {
        addToInsnList(42474001B);
    };
    set145z := (set145z + l5var12z.m) * [1:15];
    P6443(false);
    if l5var10z.b then {
        if (not checkFortran) then
            addToInsnList(00370007B)
        else
            addToInsnList(getHelperProc(93));    (* "P/FM" *)
        insnList@.f[0].s@.f[1].i := (2);
    } else {
        if not l5var7z.b then
            addToInsnList(74100000B + l5var13z.i - (1));
    }; (* 7226 *)
    if not l5var7z.b then {
        insnList@.f[2] := l5var5z.s@.f[3];
        insnList@.f[3].m := insnList@.f[3].m + [0];
        insnList@.f[4].c := '_002';
        set146z := set146z - l5var12z.m;
    }
    (* 7237 *)
}; (* P6470 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure startInsnList(l5arg1z: char);
{
    new(insnList);
    insnList@.f[0].s := NIL;
    insnList@.f[1].s := NIL;
    insnList@.f[2] := l4arg1z@.f[0];
    insnList@.f[3].m := [];
    insnList@.f[4].c := l5arg1z;
    if (l5arg1z = '_000') then {
        insnList@.f[5] := l4arg1z@.f[2];
        insnList@.f[7] := l4arg1z@.f[3];
    } else {
        insnList@.f[8].c := '_000';
        insnList@.f[7].i := (18);
        insnList@.f[5].i := curFrameRegTemplate;
        insnList@.f[6] := l4arg1z@.f[2];
    }
}; (* startInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P7272;
var
    l5var1z: integer;
{
    l5var1z := insnList@.f[2].s@.f[0].i;
    if (l5var1z = (1)) then {
        l3var12z := insnList;
        insnList := l4var3z;
        P4343;
        genOneOp;
        insnList := l3var12z;
        P4755;
        genOneOp;
    } else {
        P5314;
        genOneOp;
        l5var1z := (l5var1z - (1));
        formInsnAndLabel(getValueOrAllocSymtab(-l5var1z) + 66400000B);
        l4var7z.i := moduleOffset;
        form2Insn((72200000B + l5var1z), 64100000B);
        form3Insn((62200000B + l5var1z), 64000000B, (67700000B + l4var7z.i));
        set145z := set145z + [12:14];
    }
}; (* P7272 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genConstDiv;
    function PASDIV(r: real): word;
        external;
{
    curVal := PASDIV(1/l4var5z.i);
    addToInsnList(40170000B + getFCSToffset);
}; (* genConstDiv *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genEqComp;
label
    7475, 7504, 7514, 7530;
var
    l5var1z, l5var2z, l5var3z, l5var4z: word;
{
    l3var3z.i := ord(curOP) - (8);
    l5var1z.b := odd(l3var3z.i);
    if (l3var3z.i = (6)) then {
        if (arg1Const) then {
            if (arg2Const) then {
                insnList@.f[5].b := (l4var4z.i IN l4var5z.m);
            } else {
                l5var2z.m := [l4var4z.i];
                if (l5var2z.m = []) then {
                    insnList@.f[5].b := false;
                } else {
                    insnList := l4var3z;
                    P4343;
                    curVal := l5var2z;
                    addToInsnList(40110000B + getFCSToffset);
                    insnList@.f[5].i := (0);
                    insnList@.f[4].c := '_003';
                }
            }; (* 7412 *)
        } else { (* 7413 *)
            l3var12z := insnList;
            insnList := l4var3z;
            l4var3z := l3var12z;
            l3var4z := (66);
            P5270;
            insnList@.f[4].c := '_002';
        }
    } else { (* 7423 *)
        if l5var1z.b then
            l3var3z.i := (l3var3z.i - (1));
        l2var13z := insnList@.f[2].t;
        curVarKind := l2var13z@.k;
        l5var4z.i := l2var13z@.size;
        if (l2var13z = realType) then {
            if (fuzzReals) then
                l4var7z.i := (0)
            else
                l4var7z.i := (1);
        } else if (curVarKind = kindSet) then
            l4var7z.i := (2)
        else if (curVarKind IN [kindScalar, kindRange]) then
            l4var7z.i := (3)
        else {
            l4var7z.i := (4);
            (a) exit a (* workaround *)
        };
        if (l5var4z.i <> (1)) then {
            P5314;
            addInsnAndModify(56400000B, ((1) - l5var4z.i));
            addToInsnList(getHelperProc(89 + l3var3z.i)); (* P/EQ *)
            insnList@.f[4].c := '_002';
            l5var1z.b := not l5var1z.b;
        } else (* 7471 *) if l3var3z.i = (0) then {
            if (l4var7z.i = (0)) then {
                l3var4z := (15);
7475:           P5270;
                insnList@.f[4].c := chr(2C);
            } else { (* 7501 *)
                l3var4z := insnTemp[AEX];
                P5433(true);
7504:           insnList@.f[4].c := chr(3C);
                insnList@.f[5].i := (0);
            };
        } else { (* 7510 *)
            case l4var7z.i of
            0: { (*7511*)
                l3var4z := 16;
                goto 7475;
            };
            1: { (*7513*)
                l5var3z.i := (3);
7514:           l3var4z := insnTemp[SUB];
                P5433(false);
                insnList@.f[0].s@.f[1] := l5var3z;
                if (l5var3z.i = (3)) then {
                    addToInsnList(00370023B);
                    insnList@.f[0].s@.f[1].i := (2);
                };
                goto 7504;
            };
            2: { (*7527*)
                l3var4z := insnTemp[AAX];
7530:           P4343;
                addToInsnList(04120024B);
                P5433(true);
                goto 7504;
            };
            3: { (*7536*)
                l5var3z.i := 1;
                goto 7514;
            };
            4: { (*7540*)
                l3var4z := insnTemp[ARX];
                goto 7530;
            };
            end; (* case *)
        }; (* 7554 *)
        insnList@.f[3].m := insnList@.f[3].m - [16];
        if (l5var1z.b)
            then P5420;
    }; (* 7562 *)
    (* 7562 *)
}; (* genEqComp *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genFullExpr *);
    if l4arg1z = NIL then
        exit;
7567:
    curOP := l4arg1z@.f[1].o;
    if (curOP < op34) then {
        genFullExpr(l4arg1z@.f[3].e);
        l4var3z := insnList;
        if (curOP = badop33) then
            l3var13z.c := chr(0C);
        genFullExpr(l4arg1z@.f[2].e);
        if (curOP = badop33) then
            l3var13z.c := chr(1C);
        if (insnList@.f[4].c = chr(0C)) then {
            arg1Const := true;
            l4var4z := insnList@.f[5];
        } else
            arg1Const := false;
        if (l4var3z@.f[4].c = chr(0C)) then {
            arg2Const := true;
            l4var5z := l4var3z@.f[5];
        } else
            arg2Const := false;
        if (curOP IN [NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP]) then {
            genEqComp;
        } else { (* 7625 *)
            if arg1Const and arg2Const then {
                case curOP of
                MUL:        l4var4z.r := l4var4z.r * l4var5z.r;
                RDIVOP:     l4var4z.r := l4var4z.r / l4var5z.r;
                AMPERS:     l4var4z.b := l4var4z.b and l4var5z.b;
                IDIVOP:     l4var4z.i := l4var4z.i DIV l4var5z.i;
                IMODOP:     l4var4z.i := l4var4z.i MOD l4var5z.i;
                PLUSOP:     l4var4z.r := l4var4z.r + l4var5z.r;
                MINUSOP:    l4var4z.r := l4var4z.r - l4var5z.r;
                OROP:       l4var4z.b := l4var4z.b or l4var5z.b:
                IMULOP:     l4var4z.i := l4var4z.i * l4var5z.i;
                SETAND:     l4var4z.m := l4var4z.m * l4var5z.m;
                SETXOR:     l4var4z.m := l4var4z.m MOD l4var5z.m;
                INTPLUS:    l4var4z.i := l4var4z.i + l4var5z.i;
                INTMINUS:   l4var4z.i := l4var4z.i - l4var5z.i;
                SETOR:      l4var4z.m := l4var4z.m + l4var5z.m;
                IDIVROP:    l4var4z.r := l4var4z.i / l4var5z.i;
                XORALLONES:
                    goto 10075;
                NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP,
                badop27, badop30, badop31, MKRANGE, badop33:
                    error(200);
                end; (* case 7750 *)
                insnList@.f[5] := l4var4z;
            } else { (*7752*)
                l3var3z.i := opToMode[curOP];
                flags := opFlags[curOP];
                l3var4z := opToInsn[curOP];
                case flags of
                opf0:
7760:               P5433(curOP in [MUL, PLUSOP, SETAND, INTPLUS]);
                opf1:
                    P5270;
                opf7: {
                    P7272;
                    exit
                };
                opf2: {
                    P5531;
                    exit
                };
                opf3: {
                    P5420;
                    l3var12z := insnList;
                    insnList := l4var3z;
                    P5420;
                    l4var3z := insnList;
                    insnList := l3var12z;
                    P5531;
                    P5420;
                    exit
                };
                opf5:
                    if (arg2Const) then {
                        P4343;
                        if card(l4var5z.m) = 4 then {
                            curVal.m := [minel(l4var5z.m-intZero)+1..47];
                            (* TODO + [0,1,3] *)
                            addToInsnList(40110000B +getFCSToffset);
                            l3var3z.i := (0);
                        } else { (* 10016 *)
                            addToInsnList(macro + 5);
                            genConstDiv;
                            insnList@.f[0].s@.f[1].i := (1);
                            curVal.m := l4var5z.m - [1, 3];
                            addToInsnList(40170000B + getFCSToffset);
                            addToInsnList(00310100B);
                            addToInsnList(74060000B);
                            l3var3z.i := (1);
                        } (* 10036 *)
                    } else { (* 10037 *)
                        P5270;
                    };
                opf4: {
                    if arg2Const then {
                        P4343;
                        genConstDiv;
                        l3var3z.i := (1);
                    } else
                        P5270;
                };
                opf6: {
                    if (arg1Const) then {
                        insnList@.f[5].m := l4var4z.m MOD [1, 3];
                    } else {
                        if (arg2Const) then {
                            l4var3z@.f[5].m := l4var5z.m MOD [1, 3];
                        } else {
                            P4343;
                            addToInsnList(04120012B);
                        }
                    };
                    P5433(true);
                    insnList@.f[0].s@.f[1].i := (1);
                    if (fixMult) then
                        addToInsnList(macro + mcMULTI)
                    else
                        addToInsnList(00310100B);
                };
                opf8: 10075: {
                    l3var12z := insnList;
                    insnList := l4var3z;
                    l4var3z := l3var12z;
                    P4343;
                    addToInsnList(04120024B);
                    goto 7760
                }
                end; (* case 10122 *)
10122:          insnList@.f[0].s@.f[1] := l3var3z;
            }
        }
    } else { (* 10125 *)
        if (op43 >= curOP) then {
            if (curOP = op35) then {
                new(insnList);
                l2var5z := l4arg1z@.f[2].q;
                with insnList@ do {
                    f[0].s := NIL;
                    f[1].s := NIL;
                    f[3].b := false;
                    f[4].b := true;
                    f[5].i := l2var5z@.offset;
                    f[6] := l2var5z@.f[6];
                    f[8].b := false;
                    f[7].i := (18);
                };
                if (l2var5z@.f[4].c = chr(4C)) then {
                    P5170;
                } else if (l2var5z@.f[4].c = chr(2C)) then {
                    insnList@.f[6].i := (3);
                    insnList@.f[5].i := (insnList@.f[5].i + frameRegTemplate);
                } else if (insnList@.f[6].i >= 74000B) then {
                    addToInsnList(insnTemp[WTC] + insnList@.f[6].i);
                    insnList@.f[6].i := (0);
                    insnList@.f[7].i := (17);
                    insnList@.f[5].i := (0);
                }
            } else (* 10171 *)
            if (curOP = op41) then {
                genFullExpr(l4arg1z@.f[2].e);
                l2var5z := l4arg1z@.f[3].q;
                with insnList@ do {
                    f[6].i := f[6].i + l2var5z@.offset;
                    if (l2var5z@.f[7].b) then {
                        case f[8].c of
                        '_000':
                            f[10] := l2var5z@.f[8];
                        '_001': {
                            f[10].i := f[10].i + l2var5z@.f[8].i;
                            if not (S6 IN optSflags.m) then
                                f[10].i := f[10].i +
                                           l2var5z@.f[6].s@.f[1].i - 48;
                        };
                        '_002':
                            if (not l3var13z.b) then
                                error(errUsingVarAfterIndexingPackedArray)
                            else {
                                P5155;
                                insnList@.f[10] := l2var5z@.f[8];
                            }
                        end; (* 10235*)
                        insnList@.f[9] := l2var5z@.f[9];
                        insnList@.f[8].b := true;
                        insnList@.f[3].m := insnList@.f[3].m + [0];
                    }
                };
            } else (* 10244 *)
            if (curOP = op34) then
                P5757
            else
            if (curOP = op42) or (curOP = op43) then {
                genFullExpr(l4arg1z@.f[2].e);
                P5170;
            } else
            if (curOP = op36) then {
                startInsnList(chr(1));
            } else
            if (curOP = op37) then {
                startInsnList(chr(1));
                P5170;
            } else
            if (curOP = op40) then
                startInsnList(chr(0));
        } else (* 10272 *)
        if (curOP = ALNUM) then
            P6470
        else if (curOP IN [op50..RNEGOP]) then {
            genFullExpr(l4arg1z@.f[2].e);
            if (insnList@.f[4].c = chr(0C)) then {
                l4var4z := insnList@.f[5];
                case curOP of
                op50: {
                    l4var5z.m := [0, 1, 3] + l4var4z.m;
                    with l4arg1z@.f[3].s@ do {
                        if (l4var5z.i < f[5].i) or
                           (f[6].i < l4var5z.i) then
                            error(errNeedOtherTypesOfOperands)
                    }
                };
                TOREAL: l4var4z.r := l4var4z.i;
                NOTOP:  l4var4z.b := not l4var4z.b;
                RNEGOP: l4var4z.r := -l4var4z.r;
                INEGOP: l4var4z.i := -l4var4z.i;
                end; (* case 10345 *)
                insnList@.f[5] := l4var4z;
            } else (* 10347 *)
            if (curOP = NOTOP) then {
                P5420;
            } else {
                P4343;
                if (curOP = op50) then {
                    if (checkBounds) then
                        P5354(l4arg1z@.f[3].t);
                } else if (curOP = TOREAL) then {
                    addToInsnList(insnTemp[AVX]);
                    l3var3z.i := (3);
                    goto 10122;
                } else {
                    addToInsnList(04140017B);
                    if (curOP = RNEGOP) then
                        l3var3z.i := (3)
                    else
                        l3var3z.i := (1);
                    goto 10122;
                }
            }
        } else (* 10376 *)
        if (curOP = op55) then {
            genFullExpr(l4arg1z@.f[2].e);
            l4var7z := l4arg1z@.f[3];
            if ((100) < l4var7z.i) then {
                P4343;
                addToInsnList(getHelperProc(l4var7z.i - 100));
            } else {
                if (insnList@.f[4].c = chr(0C)) then {
                    arg1Const := true;
                    l4var4z := insnList@.f[5];
                } else
                    arg1Const := false;
                arg2Const := (insnList@.f[2].t = realType);
                if (arg1Const) then {
                    case l4var7z.i of
                    fnSQRT:  l4var4z.r := sqrt(l4var4z.r);
                    fnSIN:   l4var4z.r := sin(l4var4z.r);
                    fnCOS:   l4var4z.r := cos(l4var4z.r);
                    fnATAN:  l4var4z.r := arctan(l4var4z.r);
                    fnASIN:  l4var4z.r := arcsin(l4var4z.r);
                    fnLN:    l4var4z.r := ln(l4var4z.r);
                    fnEXP:   l4var4z.r := exp(l4var4z.r);
                    fnABSR:  l4var4z.r := abs(l4var4z.r);
                    fnTRUNC: l4var4z.i := trunc(l4var4z.r);
                    fnODD:   l4var4z.b := odd(l4var4z.i);
                    fnORD:   l4var4z.i := ord(l4var4z.c);
                    fnCHR:   l4var4z.c := chr(l4var4z.i);
                    fnSUCC:  l4var4z.c := succ(l4var4z.c);
                    fnPRED:  l4var4z.c := pred(l4var4z.c);
                    fnPTR:   l4var4z.s := ptr(l4var4z.i);
                    fnSQRR:  l4var4z.r := l4var4z.r*l4var4z.r;
                    fnROUND: l4var4z.i := round(l4var4z.r);
                    fnCARD:  l4var4z.i := card(l4var4z.m);
                    fnMINEL: l4var4z.i := minel(l4var4z.m);
                    fnABSI:  l4var4z.i := abs(l4var4z.i);
                    fnSQRI:  l4var4z.i := l4var4z.i*l4var4z.i;
                    fnEOF,
                    fnREF,
                    fnEOLN:
                        error(201);
                    end; (* 10546 *)
                    insnList@.f[5] := l4var4z;
                } else (* 10550 *)
                if (l4var7z.i >= 14) and (16 >= l4var7z.i) then {
                    if (l4var7z.i = 15) then {
                        P4621(14);
                        addToInsnList(00420016B);
                    } else {
                        P4621(12);
                        addToInsnList(getHelperProc(l4var7z.i - 6));
                    };
                    with insnList@ do {
                        f[4].c := chr(2C);
                        f[3].m := f[3].m + [0];
                    }
                } else {
                    P4343;
                    if (l4var7z.i = (8)) then {
                        l3var3z.i := (2);
                        addToInsnList(getHelperProc(58)); (*"P/TR"*)
                        goto 10122;
                    };
                    if (l4var7z.i IN [0, 1, 2, 3, 4, 5, 6,
                                      9, 10, 11, 12, 19, 21]) then {
                        l3var3z.i := (0);
                    } else if (l4var7z.i IN [7, 17]) then
                        l3var3z.i := (3)
                    else {
                        l3var3z.i := (1);
                        (q) exit q (* workaround *)
                    };
                    addToInsnList(funcInsn[l4var7z.i]);
                    goto 10122;
                }
            }
        } else { (* 10621 *)
            if (curOP = NOOP) then {
                curVal := l4arg1z@.f[0];
                if (curVal.i IN set146z) then {
                    new(insnList);
                    with insnList@ do {
                        f[2] := l4arg1z@.f[3].s@.f[0];
                        f[0].s := NIL;
                        f[1] := ;
                        f[3].m := [];
                        f[4].c := chr(1C);
                        f[7].i := (18);
                        f[5].i := indexreg[curVal.i];
                        f[6].i := (0);
                        f[8].b := false;
                    }
                } else {
                    curVal.i := (14);
                    l4arg1z@.f[0] := curVal;
                    l4arg1z := l4arg1z@.f[3].e;
                    goto 7567;
                };
                exit
            } else
                error((220));
        }
    }; (* 10654 *)
    insnList@.f[2] := l4arg1z@.f[0];
    (* 10656 *)
}; (* genFullExpr *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formFileInit;
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z: word;
{
    if (S5 IN optSflags.m) then {
        formInsnAndLabel(67000000B);
    } else {
        form2Insn(00430015B, 74000000B);
        while (curExpr <> NIL) do {
            l4var1z.s := ptr(ord(curExpr@.f[0].s));
            l4var3z := curExpr@.f[3];
            l4var4z := l4var3z.s@.f[6];
            l4var2z := l4var3z.s@.f[3].s@.f[3];
            l4var5z := l4var3z.s@.f[3].s@.f[4];
            if (l4var4z.i < 00074000B) then {
                form1Insn(getValueOrAllocSymtab(l4var4z.i) +
                          insnTemp[WTC] + 34000000B);
                l4var4z.i := (0);
            };
            form3Insn(62400000B + l4var4z.i, 52400000B + fileBufSize,
                      46400000B + l4var5z.i);
            form1Insn(56400000B + l4var2z.s@.f[0].i);
            if (l4var1z.s = NIL) then {
                form1Insn(insnTemp[XTA]);
            } else {
                curVal := l4var1z.s@.f[3];
                if (curVal.i = (512)) then
                    curVal := l4var1z.s@.f[1];
                form1Insn(40100000B + getFCSToffset);
            };
            formInsnAndLabel(getHelperProc(69)); (*"P/CO"*)
            curVal := l4var3z.s@.f[0];
            form2Insn(40100000B+getFCSToffset, 60000032B);
            if (l4var5z.i <> (0)) and
               typeCheck(l4var2z.t, integerType) then
                form2Insn(04100011B, 60000031B);
            curExpr := curExpr@.f[2].e;
        };
        form1Insn(getHelperProc(70)(*"P/IT"*) + (-64100000B));
        formLabel;
    }
}; (* formFileInit *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* formOperator *)
    l3var13z.c := chr(1C);
    if (errors and (l3arg1z <> SETREG)) or (curExpr = NIL) then
        exit;
    if not (l3arg1z IN [gen3, gen6, gen9, gen14, gen16]) then
        genFullExpr(curExpr);
    case l3arg1z of
    gen7: genOneOp;
    SETREG: {
        with insnList@ do {
            l3var3z.i := F5142;
            new(l3var5z.e);
            l3var5z.s@.f[2].e := strp63z;
            strp63z := l3var5z.e;
            l3var5z.e@.op := NOOP;
            case f[8].c of
            '_000': {
                if (l3var3z.i = (0)) then {
                    l3var2z.i := (14);
                } else {
                    l3var10z.m := set148z * set147z;
                    if (l3var10z.m <> []) then {
                        l3var2z.i := minel(l3var10z.m);
                    } else {
                        l3var2z.i := (14);
                    };
                    if (l3var3z.i <> (1)) then {
                        P4621(l3var2z.i);
                        addToInsnList(00420000B + l3var2z.i);
                        P5117(chr(37C));
                    } else if (l3var2z.i <> (14)) then {
                        P4621(l3var2z.i);
                        genOneOp;
                    };
                    l3var11z.m := [l3var2z.i] - [14];
                    set145z := set145z - l3var11z.m;
                    set147z := set147z - l3var11z.m;
                    set146z := set146z + l3var11z.m;
                };
                curVal := l3var2z;
                l3var5z.s@.f[0] := curVal;
            };
            '_001': {
                curVal.i := (14);
                l3var5z.s@.f[0] := curVal;
            };
            '_002':
                error(errVarTooComplex);
            end; (* case *)
        }; (* with *)
        l3var5z.s@.f[3].e := curExpr;
    }; (* SETREG *)
    gen0: {
        P4343;
        if (F5142 > 1) then
            P5117(chr(36B))
    };
    STORE: {
        P4755;
        genOneOp
    };
    gen3: {
        curInsnTemplate := curVal;
        formOperator(LOAD);
        curInsnTemplate.i := insnTemp[XTA];
    };
    gen5: {
        if (insnList@.f[8].c <> chr(0C)) then
            error(errVarTooComplex);
        P4621((9));
        genOneOp;
    };
    gen6: {
        l3var1z := curVal;
        genFullExpr(curExpr);
        P4343;
        if (9 IN insnList@.f[3].m) then
            error(errVarTooComplex);
        genOneOp;
        form1Insn(44000000B + l3var1z.i);
    };
    gen8: {
        P4621(12);
        genOneOp
    };
    gen9: {
        curVal.m := curVal.m + intZero;
        form1Insn(40100000B + getFCSToffset);
    };
    gen10: {
        P4343;
        addxToInsnList(macro + 5);
        genOneOp;
    };
    gen11, gen12: {
        P4621((11));
        if (l3arg1z = gen12) then
            addxToInsnList(macro + 5);
        genOneOp;
        set145z := (set145z + [12]);
    };
    FILEACCESS: {
        P4621((12));
        genOneOp;
        formInsnAndLabel(jumpTarget.i);
    };
    gen14:
        formFileInit;
    LOAD: {
        P4343;
        genOneOp
    };
    gen15:
        with insnList@ do {
            l3var9z.b := jumpTarget.i = 0;
            l3var3z := jumpTarget;
            if (f[4].c = chr(0C)) then {
                if (f[5].b) then {
                    jumpTarget.i := (0);
                } else {
                    if (l3var9z.b) then {
                        formJumpOnCond(jumpTarget.i);
                    } else {
                        form1Insn(insnTemp[VJM] + jumpTarget.i);
                    }
                }
            } else {
                l3var8z.b := (16 in insnList@.f[3].m);
                if (insnList@.f[4].c = chr(3C)) and
                   (insnList@.f[5].i <> (0)) then {
                    genOneOp;
                    if (l3var8z.b) then {
                        if (l3var9z.b) then
                            formJumpOnCond(l3var3z.i)
                        else
                            form1Insn(insnTemp[VJM] + l3var3z.i);
                        P0715((0), jumpTarget.i);
                        jumpTarget := l3var3z;
                    } else {
                        if (not l3var9z.b) then {
                            if (not putLeft) then
                                formLabel;
                            P0715(l3var3z.i, jumpTarget.i);
                        }
                    };
                } else {
                    if (insnList@.f[4].c =chr(1C)) then {
                        bool49z := false;
                        P4343;
                        bool49z := true;
                    };
                    genOneOp;
                    if (l3var8z.b) then
                        l3var4z := insnTemp[UJ]
                    else
                        l3var4z := insnTemp[U1A];
                    if (l3var9z.b) then {
                        int51z := l3var4z;
                        formJumpOnCond(l3var3z.i);
                        int51z := insnTemp[VJM];
                        jumpTarget := l3var3z;
                    } else {
                        form1Insn(l3var4z + l3var3z.i);
                    }
                }
            }
        }; (* gen15 *)
    gen16: {
        l3var5z.e := curExpr;
        curExpr := curExpr@.f[2].e;
        formOperator(gen11);
        genFullExpr(l3var5z.s@.f[3].e);
        if (11 IN insnList@.f[3].m) then
            error(44); (* errIncorrectUsageOfStandProcOrFunc *)
        P4621((12));
        genOneOp;
        arg1Type := l3var5z.s@.f[3].e@.typ;
        with arg1Type@.range@ do
            l3var3z.i := right - left + 1;
        form2Insn((72400000B + l3var3z.i), (52400100B - arg1Type@.pcksize));
        l3var3z.i := ord(l3var5z.s@.f[0].s);
        l3var1z.i := arg1Type@.perword;
        if (l3var3z.i = (72)) then
            l3var1z.i := ((1) - l3var1z.i);
        form1Insn((getValueOrAllocSymtab(l3var1z.i) + 46400000B));
        if typeCheck(curExpr@.typ, integerType) then {
            l3var1z.i := 04100011B;
        } else {
            l3var1z.i := insnTemp[XTA];
        };
        form1Insn(l3var1z.i);
        formInsnAndLabel(getHelperProc(l3var3z.i));
   };
   LITINSN: {
        with insnList@ do {
            if (f[4].c <> chr(0C)) then
                error(errNoConstant);
            if (insnList@.f[2].s@.f[0].i <> (1)) then
                error(errConstOfOtherTypeNeeded);
            curVal := insnList@.f[5];
        }
    };
    end; (* case *)
}; (* formOperator *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseTypeRef(var newtype: @types; l3arg2z: bitset);
label
    12247, 12366, 12476, 12760, 13020;
type
    pair = record
            first, second: integer
        end;
    pair7 = array [1..7] of pair;
    caserec = record
            f1, f2: integer;
            pairs: pair7;
        end;
var
    l3var1z, l3var2z: word;
    l3var3z: caserec;
    l3var19z, l3var20z, l3var21z, l3var22z: word;
    l3var23z: word; l3var24z: @identrec;
    l3var25z: @identrec;
    l3var26z, l3var27z, l3var28z, l3var29z: @types;
    l3var30z: word; l3var31z: @identrec;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePtrType(l4arg1z: @types);
{
    new(l3var29z = 4);
    l3var29z@ := [1, 15, kindPtr, l4arg1z];
    new(l3var24z = 5);
    l3var24z@ := [curIdent, lineCnt, typelist, l3var29z, false];
    typelist := l3var24z;
}; (* definePtrType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseRecordDecl(rectype: @types; l4arg2z: boolean);
type
    struc6 = record
            f: array [0..5] of word
        end;
var
    l4var1z, l4var2z, l4var3z: word;
    l4var4z: struc6;
    l4var10z, l4var26z: caserec;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToTypeHashTab;
{
    l3var24z@ := [curIdent, , typeHashTabBase[bucket], ,
                    chr(5), NIL, l3var29z, l3var1z];
    typeHashTabBase[bucket] := l3var24z;
}; (* addToTypeHashTab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure computeFieldOffsets;
label
    11523, 11622;
var
    l5var1z, l5var2z, l5var3z, l5var4z, l5var5z: integer;
    l5var6z: @struc;
{
    parseTypeRef(l4var2z.t, l3arg2z + [33]);
    if (l3var29z@.ptr2 = NIL) then {
        l3var29z@.ptr2 := l3var25z;
    } else {
        l3var31z@.f[5].q := l3var25z;
    };
    l3var2z.b := isFileType(l4var2z.t);
    if (not l4arg2z) and l3var2z.b then
        error(errTypeMustNotBeFile);
    l3var29z@.s8.f[5].b := l3var2z.b or l3var29z@.s8.f[5].b;
    l3var31z := l3var24z;
    repeat
        l3var25z@.f[3] := l4var2z;
(q)     if (l3var1z.b) then {
            l5var1z := l4var2z.s@.f[1].i;
            l3var25z@.f[9].i := l5var1z;
            if (l5var1z <> (48)) then {
                for l5var2z to l3var3z.f2 do
11523:          {
                    l5var6z := ref(l3var3z.pairs[l5var2z]);
                    if (l5var6z@.f[0].i >= l5var1z) then {
                        l3var25z@.f[8].i := 48 - l5var6z@.f[0].i;
                        l3var25z@.offset := l5var6z@.f[1].i;
                        if not (S6 IN optSflags.m) then
                            l3var25z@.f[8].i := 48 - l3var25z@.f[9].i -
                                                  l3var25z@.f[8].i;
                        l5var6z@.f[0].i := l5var6z@.f[0].i - l5var1z;
                        if (l5var6z@.f[0].i = (0)) then {
                            l3var3z.pairs[l5var2z] :=
                                l3var3z.pairs[l3var3z.f2];
                            l3var3z.f2 := (l3var3z.f2 - (1));
                        }; (* 11562 *)
                        goto 11622;
                    }
                }; (* 11564 *)
                if (l3var3z.f2 <> (7)) then {
                    l3var3z.f2 := l3var3z.f2 + 1;
                    l5var2z := l3var3z.f2;
                } else {
                    l5var3z := 48;
                    for l5var4z to 7 do {
                        l5var5z := l3var3z.pairs[l5var4z].first;
                        if (l5var5z < l5var3z) then {
                            l5var3z := l5var5z;
                            l5var2z := l5var4z;
                        }
                    }; (* for *)
                }; (* 11606 *)
                l3var3z.pairs[l5var2z] := [48, l3var3z.f1];
                l3var3z.f1 := (l3var3z.f1 + (1));
                goto 11523;
            }
        }; (* 11615 *)
        l3var25z@.f[7].c := chr(0C);
        l3var25z@.offset := l3var3z.f1;
        l3var3z.f1 := (l3var3z.f1 + l4var2z.s@.f[0].i);
11622:
        if (PASINFOR.listMode = (3)) then {
            write(' ':16);
            if (l3var25z@.f[7].b) then
                write('PACKED');
            write(' FIELD ');
            printTextWord(l3var25z@.id);
            write('.OFFSET=', l3var25z@.offset:5 oct, 'B');
            if (l3var25z@.f[7].b) then {
                write('.<<=SHIFT=', l3var25z@.f[8].i:2,
                      '. WIDTH=', l3var25z@.f[9].i:2, ' BITS');
            } else {
                write('.WORDS=', l4var2z.s@.f[0].i:0);
            };
            writeLN;
        };
        l3var2z.b := (l3var25z = l3var24z);
        l3var25z := l3var25z@.f[5].q;
    until l3var2z.b;
    (* 11674 *)
}; (* computeFieldOffsets *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseRecordDecl *)
    int93z := (3);
    inSymbol;
    (*11702*)
    while (SY = IDENT) do {
        l4var4z.f[2].s := NIL;
        repeat
            if (SY <> IDENT) then {
                error(errNoIdent);
            } else {
                if (hashTravPtr <> NIL) then
                    error(errIdentAlreadyDefined);
                new(l3var24z = 10);
                addToTypeHashTab;
                if (l4var4z.f[2].s = NIL) then {
                    l3var25z := l3var24z;
                } else {
                    l4var4z.f[2].s@.f[5].q := l3var24z;
                };
                l4var4z.f[2].q := l3var24z;
                int93z := (3);
                inSymbol;
            };
            l3var2z.b := (SY <> COMMA);
            if (not l3var2z.b) then {
                int93z := (3);
                inSymbol;
            }
        until l3var2z.b;
        checkSymAndRead(COLON);
        computeFieldOffsets;
        if (SY = SEMICOLON) then {
            int93z := (3);
            inSymbol;
        }
    }; (*11752*)
    if (SY = CASESY) then {
        int93z := (3);
        inSymbol;
        l4var2z.t := integerType;
(identif)
        if (SY <> IDENT) then {
            error(3);
            skip((l3arg2z + [42]));
        } else { (* 11766 *)
            l4var4z.f[4] := curIdent;
            l4var4z.f[5].i := bucket;
            l3var24z := hashTravPtr;
            inSymbol;
            if (SY = COLON) then {
                if (l3var24z <> NIL) then
                    error(errIdentAlreadyDefined);
                new(l3var24z = 10);
                curIdent := l4var4z.f[4];
                bucket := l4var4z.f[5].i;
                addToTypeHashTab;
                inSymbol;
                l3var25z := l3var24z;
                computeFieldOffsets;
            } else {
                l3var24z := symHashTabBase[l4var4z.f[5].i];
                while (l3var24z <> NIL) do {
                    if (l3var24z@.id <> l4var4z.f[4]) then {
                        l3var24z := l3var24z@.next;
                    } else {
                        if (l3var24z@.f[4].c <> chr(0C)) then {
                            error(errNotAType);
                            l4var2z.t := integerType;
                        } else {
                            l4var2z := l3var24z@.f[3];
                        };
                        exit identif;
                    };
                };
                error(errNotDefined)
            };
        }; (* 12035 *)
        if (l4var2z.s@.f[2].c = chr(2C)) then
            l4var2z := l4var2z.s@.f[3];
        checkSymAndRead(OFSY);
        l4var10z := l3var3z;
        l4var26z := l3var3z;
        l4var1z.s := NIL;
        repeat
            l4var3z.s := NIL;
            repeat
                parseLiteral(l4var4z.f[0].t, l4var4z.f[3], false);
                if (l4var4z.f[0].s = NIL) then
                    error(errNoConstant)
                else if (not typeCheck(l4var4z.f[0].t, l4var2z.t)) then
                    error(errConstOfOtherTypeNeeded);
                new(l4var4z.f[1].s = 7);
                l4var4z.f[1].s@ := [l3var3z, 48, chr(10B),
                                    l4var4z.f[3], NIL, NIL, NIL];
                if (l4var3z.s = NIL) then {
                    l3var28z := l4var4z.f[1].t;
                } else {
                    l4var3z.s@.f[6] := l4var4z.f[1];
                };
                l4var3z := l4var4z.f[1];
                inSymbol;
                l3var2z.b := (SY <> COMMA);
                if (not l3var2z.b) then
                    inSymbol;
            until l3var2z.b;
            if (l4var1z.s = NIL) then {
                if (l3var29z@.base = NIL) then {
                    l3var29z@.base := l3var28z;
                } else {
                    rectype@.s8.f[4].t := l3var28z;
                }
            } else {
                l4var1z.s@.f[5].t := l3var28z;
            };
            l4var1z.t := l3var28z;
            checkSymAndRead(COLON);
            if (SY <> LPAREN) then
                requiredSymErr(LPAREN);
            parseRecordDecl(l3var28z, false);
            if (l4var26z.f1 < l3var3z.f1) or
               l3var1z.b and (l3var3z.f1 = 1) and (l4var26z.f1 = 1) and
                (l3var3z.f2 = 1) and (l4var26z.f2 = 1) and
                (l3var3z.pairs[1].first < l4var26z.pairs[1].first) then {
                l4var26z := l3var3z;
            }; (* 12201 *)
            l3var3z := l4var10z;
            checkSymAndRead(RPAREN);
            l3var2z.b := SY <> SEMICOLON;
            if (not l3var2z.b) then
                inSymbol;
            if (SY = ENDSY) then
                l3var2z.b := true;
        until l3var2z.b;
        l3var3z := l4var26z;
    }; (* 12232 *)
    rectype@.size := l3var3z.f1;
    if l3var1z.b and (l3var3z.f1 = (1)) and (l3var3z.f2 = (1)) then {
        rectype@.bits := ((48) - l3var3z.pairs[1].first);
    }
    (* 12242 *)
}; (* parseRecordDecl*)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseTypeRef *)
    l3var1z.b := false;
12247:
    if (SY = LPAREN) then {
        l3var23z.i := (0);
        int93z := (0);
        inSymbol;
        l3var25z := NIL;
        new(l3var29z = 6);
        while (SY = IDENT) do {
            if (bool100z) then
                error(errIdentAlreadyDefined);
            new(l3var24z = 7);
            l3var24z@ := [curIdent, curFrameRegTemplate,
                            symHashTabBase[bucket], l3var29z,
                            chr(1C), NIL, ptr(l3var23z.i)];
            symHashTabBase[bucket] := l3var24z;
            l3var23z.i := (l3var23z.i + (1));
            if (l3var25z = NIL) then {
                l3var29z@.s8.f[3].q := l3var24z;
            } else {
                l3var25z@.f[5].q := l3var24z;
            };
            l3var25z := l3var24z;
            inSymbol;
            if (SY = COMMA) then {
                int93z := (0);
                inSymbol;
            } else {
                if (SY <> RPAREN) then
                    requiredSymErr(RPAREN);
            };
        }; (* 12324 *)
        checkSymAndRead(RPAREN);
        if (l3var25z = NIL) then {
            l3var29z := booleanType;
            error(errNoIdent);
        } else {
            l3var29z@ := [1, nrOfBits(l3var23z.i - 1), chr(1), , l3var23z, 0];
        };
    } else (* 12344 *)
    if (SY = ARROW) then {
        inSymbol;
        if (SY <> IDENT) then {
            error(errNoIdent);
            l3var29z := pointerType;
        } else {
            if (hashTravPtr = NIL) then {
                if (l2var9z) then {
                    if (F2751(l3var24z)) then {
                        l3var29z := l3var24z@.typ;
                    } else {
                        definePtrType(integerType);
                    };
                } else {
12366:              error(errNotAType);
                    l3var29z := pointerType;
                };
            } else {
                if (hashTravPtr@.f[4].c <> chr(0C)) then {
                    goto 12366
                };
                new(l3var29z = 4);
                with l3var29z@ do {
                    size := (1);
                    bits := (15);
                    k := kindPtr;
                    base := hashTravPtr@.typ;
                }
            }; (* 12405 *)
            inSymbol;
        }
    } else (* 12410 *)
    if (SY = IDENT) then {
        if (hashTravPtr <> NIL) then {
            if (hashTravPtr@.f[4].c = chr(0C)) then {
                l3var29z := hashTravPtr@.f[3].t;
            } else {
                goto 12760;
            }
        } else {
            if (l2var9z) then {
                if (F2751(l3var24z)) then {
                    l3var29z := l3var24z@.typ;
                    l3var29z@.base := booleanType;
                } else {
                    definePtrType(booleanType);
                };
            } else {
                error(4);
                l3var29z := integerType;
            };
        };
        inSymbol;
    } else { (* 12440 *)
        if (SY = PACKEDSY) then {
            l3var1z.b := true;
            inSymbol;
            goto 12247;
        };
        if (SY = RECORDSY) then { (* 12446 *)
            new(l3var29z = 7);
            strp121z := l3var29z;
            with l3var29z@ do {
                size := (0);
                bits := (48);
                k := kindRecord;
                ptr1 := NIL;
                ptr2 := NIL;
                flag := false;
                pckrec := l3var1z.b;
            };
            l3var3z.f1 := (0);
            l3var3z.f2 := (0);
            parseRecordDecl(l3var29z, true);
            checkSymAndRead(ENDSY);
        } else (* 12467 *)
        if (SY = ARRAYSY) then {
            inSymbol;
            if (SY = LBRACK) then
                inSymbol;
            l3var28z := NIL;
12476:      parseTypeRef(l3var27z, l3arg2z + [42]);
            curVarKind := l3var27z@.k;
            if (curVarKind <> kindRange) then {
                if (curVarKind = kindScalar) and
                   (l3var27z <> integerType) then {
                    l3var23z := l3var27z@.s8.f[4];
                } else {
                    error(8);
                    l3var27z := integerType;
                    l3var23z.i := (10);
                };
                defineRange(l3var27z, 0, l3var23z.i - 1);
            }; (* 12524 *)
            new(l3var26z, kindArray);
            with l3var26z@ do {
                size := ord(l3var28z);
                bits := (48);
                k := kindArray;
                range := l3var27z;
            };
            if (l3var28z =  NIL) then
                l3var29z := l3var26z
            else
                l3var28z@.base := l3var26z;
            l3var28z := l3var26z;
            if (SY = COMMA) then {
                inSymbol;
                goto 12476;
            };
            if (SY = RBRACK) then
                inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(l3var27z, l3arg2z);
            l3var26z@.base := l3var27z;
            if isFileType(l3var27z) then
                error(errTypeMustNotBeFile);
            repeat with l3var26z@, s8.f[4].s8@ do {
                l3var23z.i := g[6].i - g[5].i + 1;
                l3var28z := ptr(size);
                l3var22z.i := base@.bits;
                if ((24) < l3var22z.i) then
                    l3var1z.b := false;
                bits := (48);
                if (l3var1z.b) then {
                    l3var22z.i := ((48) DIV l3var22z.i);
                    if (l3var22z.i = (9)) then {
                        l3var22z.i := (8);
                    } else if (l3var22z.i = (5)) then
                        l3var22z.i := (4);
                    perword := l3var22z.i;
                    pcksize := ((48) DIV l3var22z.i);
                    l3var22z.i := l3var23z.i * pcksize;
                    if l3var22z.i mod 48 = 0 then
                        l3var21z.i := 0
                    else
                        l3var21z.i := 1;
                    size := l3var22z.i div 48 + l3var21z.i;
                    if (size = (1)) then
                        bits := l3var22z.i;
                } else { (* 12633 *)
                    size := l3var23z.i * base@.size;
                    curVal.i := base@.size;
                    curVal.m := ((curVal.m * [7:47]) + [0]);
                    if (range@.base <> integerType) then
                        curVal.m := (curVal.m + [1, 3]);
                    l3var26z@.perword := (getFCSToffset  + 40170000B);
                }; (* 12652 *)
                l3var26z@.pck := l3var1z.b;
                l3var1z.b := false;
                l3var2z.b := (l3var29z = l3var26z);
                l3var26z := l3var28z;
            } until l3var2z.b;
        } else (* 12663 *)
        if (SY = FILESY) then {
            inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(l3var27z, l3arg2z);
            if (isFileType(l3var27z)) then
                error(errTypeMustNotBeFile);
            if (l3var1z.b) then {
                l3var22z.i := l3var27z@.bits;
                if ((24) < l3var22z.i) then
                    l3var1z.b := false;
            };
            new(l3var29z, kindFile);
            if (not l3var1z.b) then
                l3var22z.i := (0);
            with l3var29z@ do {
                size := (30);
                bits := (48);
                k := kindFile;
                base := l3var27z;
                elsize := l3var22z.i;
            }
        } else (* 12721 *)
        if (SY = SETSY) then {
            inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(l3var27z, l3arg2z);
            with l3var27z@ do {
                if (k = kindRange) and
                   (left >= (0)) and
                   ((47) >= right) then
                    l3var21z.i := (right + (1))
                else if (k = kindScalar) and
                        ((48) >= numen) then
                    l3var21z.i := numen
                else {
                    l3var21z.i := (48);
                    error(63); (* errBadBaseTypeForSet *)
                }
            };
            new(l3var29z, kindSet);
            with l3var29z@ do {
                size := 1;
                bits := l3var21z.i;
                k := kindSet;
                base := l3var27z;
            }
        } else {
12760:      ;
            parseLiteral(l3var28z, l3var19z, true);
            if (l3var28z <> NIL) then {
                inSymbol;
                if (SY <> COLON) then {
                    requiredSymErr(COLON);
                } else {
                    inSymbol;
                };
                parseLiteral(l3var29z, l3var20z, true);
                if (l3var29z = l3var28z) and
                   (l3var29z@.k = kindScalar) then {
                    defineRange(l3var29z, l3var19z.i, l3var20z.i);
                    inSymbol;
                    goto 13020;
                }
            };
            error(64); (* errIncorrectRangeDefinition *)
            l3var29z := booleanType;
        };
    };
13020:
    if (errors) then
        skip((skipToSet + [RPAREN, RBRACK, SEMICOLON, OFSY]));
    newtype := l3var29z;
}; (* parseTypeRef *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P13026(l3arg1z: @struc);
var
    l3var1z: @struc;
{
    if (l3arg1z@.f[5].i = (0)) then {
        l3arg1z@.f[5].i := FcstCnt;
        l3var1z := l3arg1z@.f[3].s;
        while (l3var1z <> NIL) do {
            curVal := l3var1z@.f[0];
            l3var1z := l3var1z@.f[5].s;
            toFCST;
        }
    }
}; (* P13026 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formPMD;
var
    l3var1z, l3var2z, l3var3z: word;
    l3var4z: boolean;
    l3var5z: word;
{
    for l3var4z := false to true do {
        if l3var4z then {
            optSflags.m := (optSflags.m + [S3]);
            curVal.i := 00074001B;
            P0715((2), 34); (*"P/DS"*)
            curVal := l2arg2z@.id;
            toFCST;
            curVal.i := lineCnt;
            toFCST;
        }; (* 13063 *)
        for l2var22z := 0 to 127 do {
            l2var5z := symHashTabBase[l2var22z];
            (*13066*)
            while (l2var5z <> NIL) and
                  (l2arg2z < l2var5z) do with l2var5z@ do {
                l3var2z := f[3].s@.f[0];
                if (f[4].i IN [3, 4]) and
                  (f[6].i < 00074000B) then {
                    curVal := id;
                    if (l3var4z) then
                        toFCST;
                    l3var1z := f[3];
                    l3var5z := l3var1z.s@.f[2];
                    l3var3z.c := chr(0C);
                    if (l3var5z.c = chr(3C)) then {
                        l3var1z := l3var1z.s@.f[3];
                        l3var5z := l3var1z.s@.f[2];
                        l3var3z.m := [0];
                    };
                    if (l3var1z.t = realType) then
                        curVal.i := (0)
                    else if typeCheck(l3var1z.t, integerType) then
                        curVal.i := 00100000B
                    else if typeCheck(l3var1z.t, charType) then
                        curVal.i := 00200000B
                    else if (l3var5z.c = chr(5C)) then
                        curVal.i := 00400000B
                    else if (l3var5z.c = chr(1C)) then {
                        P13026(l3var1z.s);
                        curVal.i := 1000000B * l3var1z.s@.f[5].i + 00300000B;
                    } else if (l3var5z.c = chr(7C)) then
                        curVal.i := 00600000B
                    else {
                        curVal.i := 00500000B;
                        (q) exit q (* workaround *)
                    };
                    curVal.i := (curVal.i + l2var5z@.f[6].i);
                    l3var2z := l3var2z;
                    besm(ASN64-33);
                    l3var2z := ;
                    curVal.m := curVal.m * [15:47] + l3var2z.m + l3var3z.m;
                    if (l3var4z) then
                        toFCST;
                }; (* 13164 *)
                l2var5z := l2var5z@.next;
            }; (* 13166 *)
        }; (*13167+*)
        curVal.m := [];
        if l3var4z then
            toFCST;
    }
}; (* formPMD *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseDecls(l3arg1z: integer);
var
    l3var1z, l3var2z, l3var3z: word;
{
    case l3arg1z of
    0: {
        int93z := (0);
        inSymbol;
        if (SY <> IDENT) then
            errAndSkip(3, skipToSet + [IDENT]);
    };
    1: {
        prevErrPos := (0);
        write('IDENT ');
        printTextWord(l2var12z);
        write(' IN LINE ', l2var5z@.offset:0);
    };
    2: {
        with l2arg2z@ do
            ; (* useless *)
        formLabel;
        l3var3z.b := 22 IN l2arg2z@.f[11].m;
        l3arg1z := l2arg2z@.f[10].i;
        l3var2z.i := (moduleOffset - 00040000B);
        if (l3arg1z <> (0)) then
            symTab[l3arg1z].m := [24, 29] + l3var2z.m * halfWord;
        l2arg2z@.f[10].i := moduleOffset;
        l3arg1z := F3307(l2arg2z);
        if (l3var3z.b) then {
            if ((41) >= entryPtCnt) then {
                curVal := l2arg2z@.id;
                entryPtTableBase[entryPtCnt] := makeNameWithStars(true);
                entryPtTableBase[entryPtCnt+1].m := [1] + l3var2z.m - [0, 3];
                entryPtCnt := (entryPtCnt + (2));
            } else
                error(87); (* errTooManyEntryProcs *)
        };
        if (l2arg2z@.f[3].s = NIL) then {
            l3var2z.i := (3);
        } else {
            l3var2z.i := (4);
        };
        if (l3var3z.b) then
            form2Insn(72400000B + l3arg1z + (l3var2z.i - 3) * 1000B,
                      getHelperProc(94 (*"P/NN"*)) - 10000000B);
        if ((1) < l3arg1z) then {
            l3var2z.i := getValueOrAllocSymtab(-(l3var2z.i+l3arg1z));
        };
        if (S5 IN optSflags.m) and
           (curProcNesting = (1)) then
            l3var1z.i := (59)
        else
            l3var1z.i := curProcNesting;
        l3var1z.i := getHelperProc(l3var1z.i) - 6437777774000000C;
        if (l3arg1z = (1)) then {
            form1Insn(74000000B + l3var2z.i);
        } else if (l3arg1z <> (0)) then {
            form2Insn(74000000B, (76500000B + l3var2z.i));
        };
        formInsnAndLabel(l3var1z.i);
        glob57z.i := objBufIdx;
        if (curProcNesting <> (1)) then
            form1Insn((0));
        if (l3var3z.b) then
            form1Insn(42474001B);
        if (l2var11z.i <> (0)) then {
            form1Insn(insnTemp[XTA]);
            formInsnAndLabel((67100000B + l2var11z.i));
            curVal := l2var11z;
            P0715((2), 49 (* "P/RDC" *));
        };
        if (curProcNesting = (1)) then {
            if (heapCallsCnt <> (0)) and
               (heapSize = (0)) then
                error(65 (*errCannotHaveK0AndNew*));
            l3var3z.b := (heapSize = (0)) or
                (heapCallsCnt = (0)) and (heapSize = (100));
            if (heapSize = (100)) then
                heapSize := (4);
            if (not l3var3z.b) then {
                form2Insn(getValueOrAllocSymtab(heapSize * 2000B) + 72400000B,
                          getHelperProc(26 (*"P/GD"*)));
                formLabel;
            }
        };
        if (doPMD) then
            formPMD;
    }
    end; (* case *)
}; (* parseDecls *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure statement;
label
    8888;
var
    l3var1z: @struc; l3var2z: @numLabel;
    l3var3z: @strLabel;
    l3var4z, l3var5z,
    l3var6z, l3var7z, l3var8z: word; l3var9z: integer;
    l3var10z, l3var11z, l3var12z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isCharArray(l4arg1z: @types): boolean;
{
    with l4arg1z@ do
        isCharArray := (k = kindArray) and (base = charType);
}; (* isCharArray *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure expression;
    forward;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLval;
label
    13462, 13530;
var
    l4var1z, l4var2z, l4var3z, l4var4z: word;
{
    if (hashTravPtr@.f[4].c =chr(5C)) then {
        curExpr := strp62z;
        goto 13530;
    } else {
        new(curExpr);
        with curExpr@ do {
            f[0] := hashTravPtr@.f[3];
            op := op35;
            f[2].q := hashTravPtr;
        };
13462:  inSymbol;
        l4var3z := curExpr@.f[0];
        l4var4z := l4var3z.s@.f[2];
        if (SY = ARROW) then {
            new(l4var1z.e);
            with l4var1z.e@ do {
                f[2].e := curExpr;
                if (l4var4z.c =chr(3C)) then {
                    f[0] := l4var3z.s@.f[3];
                    f[1].c := chr(42C);
                } else if (l4var4z.c = chr(7C)) then {
                    f[0] := l4var3z.s@.f[3];
                    f[1].c := chr(43C);
                } else {
                    stmtName := '  ^   ';
                    error(errWrongVarTypeBefore);
                    l4var1z.s@.f[0] := l4var3z;
                }
            };
            curExpr := l4var1z.e;
        } else if (SY = PERIOD) then {
            if (l4var4z.c = chr(6C)) then {
                int93z := (3);
                strp121z := l4var3z.t;
                inSymbol;
                if (hashTravPtr = NIL) then {
                    error(20); (* errDigitGreaterThan7 ??? *)
                } else 13530: {
                    new(l4var1z.e);
                    with l4var1z.e@ do {
                        f[0] := hashTravPtr@.f[3];
                        op := op41;
                        f[2].e := curExpr;
                        f[3].q := hashTravPtr;
                    };
                    curExpr := l4var1z.e;
                }
            } else {
                stmtName := '  .   ';
                error(errWrongVarTypeBefore);
            };
        } else if (SY = LBRACK) then {
            stmtName := '  [   ';
            repeat
                l4var1z.e := curExpr;
                expression;
                l4var3z := l4var1z.s@.f[0];
                if (l4var3z.s@.f[2].c <> chr(5C)) then {
                    error(errWrongVarTypeBefore);
                } else {
                    if (not typeCheck(l4var3z.s@.f[4].t, curExpr@.f[0].t)) then
                        error(66 (*errOtherIndexTypeNeeded *));
                    new(l4var2z.e);
                    with l4var2z.e@ do {
                        f[0] := l4var3z.s@.f[3];
                        f[2] := l4var1z;
                        f[3].e := curExpr;
                        op := op34;
                    };
                    l4var1z := l4var2z;
                };
                curExpr := l4var1z.e;
                stmtName := '  ,   ';
            until (SY <> COMMA);
            if (SY <> RBRACK) then
                error(67 (*errNeedBracketAfterIndices*));
        } else exit;
    };
    goto 13462;
}; (* parseLval *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure castToReal(var value: @expr);
var
    cast: @expr;
{
    new(cast);
    with cast@ do {
        typ := realType;
        op := TOREAL;
        arg1.e := value;
        value := cast;
    }
}; (* castToReal *)
%
function areTypesCompatible(var l4arg1z: @expr): boolean;
{
    if (arg1Type = realType) then {
        if typeCheck(integerType, arg2Type) then {
            castToReal(l4arg1z);
            areTypesCompatible := true;
            exit
        };
    } else if (arg2Type = realType) and
               typeCheck(integerType, arg1Type) then {
        castToReal(curExpr);
        areTypesCompatible := true;
        exit
    };
    areTypesCompatible := false;
}; (* areTypesCompatible *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseCallArgs(l4arg1z: @identrec);
label
    13736;
var
    l4var1z: boolean;
    l4var2z: @expr;
    l4var3z, l4var4z: @expr;
    l4var5z: @identrec;
    l4var6z, l4var7z: word;
{
    with l4arg1z@ do {
        if f[3].s <> NIL then
            set146z := set146z - f[11].m;
        l4var1z := (f[5].s = NIL) and not (24 in f[11].m);
    };
    new(l4var3z);
    l4var4z := l4var3z;
    bool48z := true;
    with l4var3z@ do {
        f[0] := l4arg1z@.f[3];
        f[1].c := chr(45C);
        f[3].q := l4arg1z;
        f[2].s := NIL;
    };
    if (SY = LPAREN) then {
        if (l4var1z) then {
            l4var5z := l4arg1z@.f[7].q;
            if (l4var5z = NIL) then {
                error(errTooManyArguments);
                goto 8888;
            }
        };
        repeat
            if (l4var1z) and (l4arg1z = l4var5z) then {
                error(errTooManyArguments);
                goto 8888;
            };
            bool47z := true;
            expression;
            l4var6z := curExpr@.f[1];
(a)         if l4var1z then {
                l4var7z := l4var5z@.f[4];
                if (l4var6z.c = chr(46C)) then {
                    if (l4var7z.c <> chr(2C)) or
                       (l4var5z@.f[3].s <> NIL) then {
13736:                  error(39); (*errIncompatibleArgumentKinds*)
                        exit a
                    }
                } else { (* 13741 *)
                    if (l4var6z.c = chr(47C)) then {
                        if (l4var7z.c = chr(2C)) then {
                            if (l4var5z@.f[3].s = NIL) then
                                goto 13736
                        } else (* 13750 *)
                        if (curExpr@.f[3].s@.f[7].s = NIL) and
                           (l4var7z.c = chr(3C)) then {
                            curExpr@.f[1].c := chr(45C);
                            curExpr@.f[2].s := NIL;
                        } else
                            goto 13736;
                    } else (* 13762 *)
                    if (l4var6z.i IN lvalOpSet) then {
                        if (l4var7z.c <> chr(3C)) and
                           (l4var7z.c <> chr(4C)) then
                            goto 13736;
                    } else {
                        if (l4var7z.c <> chr(3C)) then
                            goto 13736;
                        (q) exit q (* workaround *)
                    }
                };
                arg1Type := curExpr@.f[0].t;
                if (arg1Type <> NIL) then {
                    if not typeCheck(arg1Type, l4var5z@.f[3].t) then
                        error(40); (*errIncompatibleArgumentTypes*)
                }
            }; (* 14006 *)
            new(l4var2z);
            with l4var2z@ do {
                f[0].s := NIL;
                f[2].s := NIL;
                f[3].e := curExpr;
            };
            l4var4z@.f[2].e := l4var2z;
            l4var4z := l4var2z;
            if (l4var1z) then
                l4var5z := l4var5z@.f[5].q;
        until (SY <> COMMA);
        if (SY <> RPAREN) or
           l4var1z and (l4var5z <> l4arg1z) then
            error(errNoCommaOrParenOrTooFewArgs)
        else
            inSymbol;
    } else { (* 14035 *)
        if (l4var1z) and (l4arg1z@.f[7].s <> NIL) then
            error(42); (*errNoArgList*)
    };
    curExpr := l4var3z;
    (* 14042 *)
}; (* parseCallArgs *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure factor;
label
    14567;
var
    l4var1z: word;
    l4var2z: boolean;
    l4var3z, l4var4z: word;
    l4var5z, l4var6z: @expr;
    l4var7z, l4var8z: @expr;
    l4var9z: @identrec;
    l4var10z: word;
    l4var11z: word;
    l4var12z: boolean;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure stdCall;
var
    l5var1z: operator;
    l5var2z: @types;
    l5var3z: word;
    l5var4z: bitset;
    l5var5z, l5var6z: integer;
{
    curVal := l4var9z@.f[5];
    l5var5z := curVal.i;
    if (SY <> LPAREN) then {
        requiredSymErr(LPAREN);
        goto 8888;
    };
    expression;
    if (l5var5z >= (14)) and
       ((16) >= l5var5z) and
       not (curExpr@.f[1].i IN [28, 29, 30, 31, 32, 33, 34, 35]) then {
        error(27); (* errExpressionWhereVariableExpected *)
        exit;
    };
    arg1Type := curExpr@.f[0].t;
    if (arg1Type@.k = kindRange) then
        arg1Type := arg1Type@.base;
    l5var3z.k := arg1Type@.k;
    if (arg1Type = realType) then
        l5var6z := (0)
    else if (arg1Type = integerType) then
        l5var6z := (1)
    else if (arg1Type = charType) then
        l5var6z := (2)
    else if (l5var3z.k = kindScalar) then
        l5var6z := (3)
    else if (l5var3z.k = kindPtr) then
        l5var6z := (4)
    else if (l5var3z.k = kindFile) then
        l5var6z := (5)
    else if (l5var3z.k = kindSet) then
        l5var6z := (6)
    else {
        l5var6z := (7);
        (q) exit q (* workaround *)
    };
    l5var4z := [l5var5z];
    if not ((l5var6z = (0)) and (l5var4z <= [0:8, 15, 17, 18, 29]) or
           ((l5var6z = (1)) and (l5var4z <= [0:7, 9, 11, 15, 17, 21])) or
           ((l5var6z IN [2, 3, 4]) and (l5var4z <= [10, 12, 13, 15])) or
           ((l5var6z = (5)) and (l5var4z <= [14, 15, 16])) or
           ((l5var6z = (6)) and (l5var4z <= [15, 19, 20])) or
           ((l5var6z = (7)) and (l5var5z = (15)))) then
        error(errNeedOtherTypesOfOperands);
    if not (l5var4z <= [7, 12, 13, 17]) then {
        arg1Type := l4var9z@.f[3].t;
    } else if (l5var6z = (1)) and (l5var4z <= [7, 17]) then {
        if (l5var5z = (7)) then
            l5var5z := (22)
        else
            l5var5z := (23);
    };
    new(l4var6z);
    l4var6z@.op := op55;
    l4var6z@.f[2].e := curExpr;
    l4var6z@.f[3].i := l5var5z;
    if (l5var5z = (24)) then {
        if (SY <> COMMA) then {
            requiredSymErr(COMMA);
            goto 8888;
        };
        expression;
        l5var2z := curExpr@.f[0].t;
        l5var1z := badop27;
        if (l5var2z <> realType) and
            not typeCheck(l5var2z, integerType) then
            error(errNeedOtherTypesOfOperands);
        if (l5var2z = realType) then
            l5var1z := badop30
        else if (l5var6z = (0)) then
            l5var1z := badop31;
        l4var6z@.f[3].e := curExpr;
        l4var6z@.op := l5var1z;
    };
    curExpr := l4var6z;
    curExpr@.f[0].t := arg1Type;
    checkSymAndRead(RPAREN);
    (* 14247 *)
}; (* stdCall *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* factor *)
    l4var2z := bool47z;
    bool47z := false;
    if (SY < MULOP) then {
        case SY of
        IDENT: {
            if (hashTravPtr = NIL) then {
                error(errNotDefined);
                curExpr := uVarPtr;
            } else
                case hashTravPtr@.f[4].c of
                '_000': {
                    error(23); (* errTypeIdInsteadOfVar *)
                    curExpr := uVarPtr;
                };
                '_001': {
                    new(curExpr);
                    with curExpr@ do {
                        f[0] := hashTravPtr@.f[3];
                        f[1].c := chr(40C);
                        f[2] := hashTravPtr@.f[6];
                        f[3].i := (0);
                    };
                    inSymbol;
                };
                '_002': {
                    l4var9z := hashTravPtr;
                    inSymbol;
                    if (l4var9z@.offset = (0)) then {
                        if (l4var9z@.f[3].s <> NIL) and
                           (SY = LPAREN) then {
                            stdCall;
                            exit;
                        };
                        besm(2200000B); (* workaround *)
                        error(44); (* errIncorrectUsageOfStandProcOrFunc *)
                    } else if (l4var9z@.f[3].s =  NIL) then {
                        if (l4var2z) then {
                            l4var10z.c := chr(46C);
                        } else {
                            error(68); (* errUsingProcedureInExpression *)
                        }
                   } else (* 14330 *) {
                        if (SY = LPAREN) then {
                            parseCallArgs(l4var9z);
                            exit
                        };
                        if (l4var2z) then {
                            l4var10z.c := chr(47C);
                        } else {
                            parseCallArgs(l4var9z);
                            exit
                        };
                        (q) exit q
                    }; (* 14342 *)
                    new(curExpr);
                    if not (SY IN [RPAREN, COMMA]) then {
                        error(errNoCommaOrParenOrTooFewArgs);
                        goto 8888;
                    };
                    with curExpr@ do {
                        f[0] := l4var9z@.f[3];
                        f[1] := l4var10z;
                        f[2].s := NIL;
                        f[3].q := l4var9z;
                    }
                };
                '_003', '_004', '_005':
                    parseLval;
                end (* case *)
        };
        LPAREN: {
            expression;
            checkSymAndRead(RPAREN);
        };
        INTCONST, REALCONST, CHARCONST, LTSY, GTSY: {
            new(curExpr);
            parseLiteral(curExpr@.f[0].t, curExpr@.f[2], false);
            curExpr@.f[3].i := ord(octalMode);
            curExpr@.f[1].c := chr(40C);
            inSymbol;
        };
        NOTSY: {
            inSymbol;
            factor;
            if (curExpr@.f[0].t <> booleanType) then
                error(1); (* errNoCommaNorSemicolon *)
            l4var6z := curExpr;
            new(curExpr);
            with curExpr@ do {
                typ := booleanType;
                op := NOTOP;
                f[2].e := l4var6z;
            }
        };
        LBRACK: {
            new(curExpr);
            inSymbol;
            l4var8z := curExpr;
            l4var1z.b := false;
            if (SY <> RBRACK) then {
                l4var12z := true;
                bool102z := false;
                repeat
                    l4var6z := curExpr;
                    expression;
                    if (l4var12z) then {
                        l4var11z := curExpr@.f[0];
                        if not (l4var11z.s@.f[2].i IN [1, 2]) then
                            error(23); (* errTypeIdInsteadOfVar *)
                    } else {
                        if not typeCheck(l4var11z.t, curExpr@.f[0].t) then
                            error(24); (*errIncompatibleExprsInSetCtor*)
                    };
                    l4var12z := false;
                    l4var5z := curExpr;
                    if (SY = COLON) then {
                        expression;
                        if not typeCheck(l4var11z.t, curExpr@.f[0].t) then
                            error(24); (*errIncompatibleExprsInSetCtor*)
                        if (l4var5z@.op = op40) and
                           (curExpr@.op = op40) then {
                            l4var4z := l4var5z@.f[2];
                            l4var3z := curExpr@.f[2];
                            l4var4z.m := l4var4z.m - intZero;
                            l4var3z.m := l4var3z.m - intZero;
                            l4var1z.m := l4var1z.m + [l4var4z.i..l4var3z.i];
                            curExpr := l4var6z;
                            goto 14567;
                        };
                        new(l4var7z);
                        with l4var7z@ do {
                            typ := setType;
                            op := MKRANGE;
                            f[2].e := l4var5z;
                            f[3].e := curExpr;
                        };
                        l4var5z := l4var7z;
                        (q); (* workaround *)
                   } else {(* 14535 *)
                        if (l4var5z@.op = op40) then {
                            l4var4z := l4var5z@.f[2];
                            l4var4z.m := l4var4z.m - intZero;
                            l4var1z.m := l4var1z.m + [l4var4z.i];
                            curExpr := l4var6z;
                            goto 14567;
                        };
                        new(l4var7z);
                        with l4var7z@ do {
                            typ := setType;
                            op := op55;
                            f[2].e := l4var5z;
                            f[3].i := (109);
                            l4var5z := l4var7z;
                        }
                    }; (* 14560 *)
                    new(curExpr);
                    with curExpr@ do {
                        typ := setType;
                        op := SETOR;
                        f[2].e := l4var6z;
                        f[3].e := l4var5z;
                    };
14567:              ;
                until SY <> COMMA;
            }; (* 14571 *)
            checkSymAndRead(RBRACK);
            with l4var8z@ do {
                f[1].c := chr(40C);
                f[0].t := setType;
                f[2] := l4var1z;
            }
        };
        end; (* case *)
    } else {
        error(errBadSymbol);
        goto 8888;
    }
    (* 14623 *)
}; (* factor *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure term;
label
    14650;
var
    l4var1z, l4var2z, l4var3z: word; l4var4z: boolean;
{
    factor;
    while (SY = MULOP) do {
        l4var1z.o := charClass;
        inSymbol;
        l4var2z.e := curExpr;
        factor;
        arg1Type := curExpr@.f[0].t;
        arg2Type := l4var2z.s@.f[0].t;
        l4var4z := typeCheck(arg1Type, arg2Type);
        if (not l4var4z) and
           (chr(1C) < l4var1z.c) then
14650:      error(errNeedOtherTypesOfOperands)
        else {
            case l4var1z.c of
            '_000', '_001': {
                if (l4var4z) then {
                    if (arg1Type = realType) then {
                        (* empty *)
                    } else {
                        if (strp120z = integerType) then {
                            if (l4var1z.c = chr(0C)) then {
                                arg1Type := integerType;
                            } else {
                                arg1Type := realType;
                            };
                            l4var1z := glob327z[l4var1z.i];
                        } else {
                            if (arg1Type@.k = kindSet) then {
                                l4var1z := glob332z[l4var1z.i];
                            } else
                                goto 14650;
                        }
                    }
                } else {
                    if areTypesCompatible(l4var2z.e) then {
                        arg1Type := realType;
                    } else
                        goto 14650;
                }
            };
            '_002': {
                if (arg1Type <> booleanType) then
                    goto 14650;
            };
            '_003': {
                if (strp120z <> integerType) then
                    goto 14650;
                arg1Type := integerType;
            };
            '_004': {
                if (strp120z = integerType) then {
                    arg1Type := integerType;
                } else {
                    if (arg1Type@.k = kindSet) then
                        l4var1z.c := chr(22C)
                    else
                        goto 14650;
                }
            };
            end;
            new(l4var3z.e);
            with l4var3z.e@ do {
                op := l4var1z.o;
                f[2] := l4var2z;
                f[3].e := curExpr;
                curExpr := l4var3z.e;
                typ := arg1Type;
            }
        }
    }
    (* 14746 *)
}; (* term *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure simpleExpression;
label
    15031;
var
    l4var1z, l4var2z: @expr;
    l4var3z: word;
    l4var4z: word;
    l4var5z: boolean;
{
    l4var5z := false;
    if (charClass IN [PLUSOP, MINUSOP]) then {
        if (charClass = MINUSOP) then
            l4var5z := true;
        inSymbol;
    };
    term;
(minus)
    if (l4var5z) then {
        arg1Type := curExpr@.typ;
        new(l4var2z);
        with l4var2z@ do {
            typ := arg1Type;
            f[2].e := curExpr;
            if (arg1Type = realType) then {
                op := RNEGOP;
            } else if typeCheck(arg1Type, integerType) then {
                l4var2z@.op := INEGOP;
                l4var2z@.typ := integerType;
            } else {
                error(69); (* errUnaryMinusNeedRealOrInteger *)
                exit minus
            };
            curExpr := l4var2z;
        }
    }; (* 15010 *)
    while (SY = ADDOP) do {
        l4var3z.o := charClass;
        inSymbol;
        l4var2z := curExpr;
        term;
        arg1Type := curExpr@.f[0].t;
        arg2Type := l4var2z@.f[0].t;
        l4var5z := typeCheck(arg1Type, arg2Type);
        l4var4z.k := arg2Type@.k;
        if (chr(4C) < l4var4z.c) then {
15031:      error(errNeedOtherTypesOfOperands);
        } else {
            new(l4var1z);
            with l4var1z@ do {
                if (l4var3z.c = chr(7C)) then {
                    if (not l4var5z) or
                       (arg1Type <> booleanType) then
                        goto 15031;
                    f[0].t := booleanType;
                    f[1] := l4var3z;
                } else (* 15046 *) {
                    if (l4var5z) then {
                        if (arg1Type = realType) then {
                            f[1] := l4var3z;
                            f[0].t := realType;
                        } else if (strp120z = integerType) then {
                            f[1] := glob334z[l4var3z.i];
                            f[0].t := integerType;
                        } else if (l4var4z.c = chr(4C)) then {
                            f[1] := glob332z[l4var3z.i];
                            f[0].t := arg1Type;
                        } else {
                            goto 15031
                        }
                    } else if areTypesCompatible(l4var2z) then {
                        l4var1z@.f[0].t := realType;
                        l4var1z@.f[1] := l4var3z;
                    } else
                        goto 15031
                }; (* 15077 *)
                l4var1z@.f[2].e := l4var2z;
                l4var1z@.f[3].e := curExpr;
                curExpr := l4var1z;
            }
        };
    }
    (* 15104 *)
}; (* simpleExpression *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure expression;
var l4var1z: word; l4var2z, l4var3z: @expr;
{
    if (bool102z) then
        inSymbol
    else
        bool102z := true;
    simpleExpression;
    if (SY = RELOP) then {
        l4var1z.o := charClass;
        inSymbol;
        l4var3z := curExpr;
        simpleExpression;
        arg1Type := curExpr@.f[0].t;
        arg2Type := l4var3z@.f[0].t;
        if typeCheck(arg1Type, arg2Type) then {
            if (l4var1z.c = chr(16C)) or
               (arg1Type@.k = kindFile) or
               (arg1Type@.size <> (1)) and
               (l4var1z.c >= chr(12C)) and
               not isCharArray(arg1Type) then
                error(errNeedOtherTypesOfOperands);
        } else (* 15150 *) {
            if not areTypesCompatible(l4var3z) and
               ((arg1Type@.k <> kindSet) or
               not (arg2Type@.k IN [kindScalar, kindRange]) or
               (l4var1z.c <> chr(16C))) then {
                besm(2200000B); besm(2200000B); (* workaround *)
                error(errNeedOtherTypesOfOperands);
            }
        }; (* 15167 *)
        new(l4var2z);
        if (arg2Type@.k = kindSet) and
           (l4var1z.i IN [10, 12]) then
            error(errNeedOtherTypesOfOperands);
        with l4var2z@ do {
            f[0].t := booleanType;
            if (l4var1z.o IN [GTOP, LEOP]) then {
                f[2].e := curExpr;
                f[3].e := l4var3z;
                if (l4var1z.o = GTOP) then
                    op := LTOP
                else
                    op := GEOP;
            } else {
                f[2].e := l4var3z;
                f[3].e := curExpr;
                f[1] := l4var1z;
            };
            curExpr := l4var2z;
        }
    }
    (* 15217 *)
}; (* expression *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure forStatement;
var
    l4var1z: @types;
    l4var2z, l4var3z: @expr;
    l4var4z: @expr;
    l4var5z, l4var6z: integer;
    l4var7z: integer;
    l4var8z: integer;
    l4var9z: boolean;
{
    inSymbol;
    disableNorm;
    curExpr := NIL;
    if (SY = IDENT) then {
        if (hashTravPtr <> NIL) and (hashTravPtr@.f[4].c = chr(3C)) then {
            parseLval;
            if (curExpr@.f[1].c <> chr(35C)) then
                error(errNoSimpleVarForLoop);
        } else
            error(errNoSimpleVarForLoop);
    } else {
        errAndSkip(errNoIdent, skipToSet + [BECOMES, DOSY, TOSY, DOWNTOSY]);
    }; (* 15251 *)
    if (curExpr = NIL) then
        curExpr := uVarPtr;
    l4var2z := curExpr;
    l4var1z := l4var2z@.f[0].t;
    if not (l4var1z@.k IN [kindScalar, kindRange]) then
        error(25); (* errExprNotOfADiscreteType *)
    if typeCheck(integerType, l4var1z) then
        l4var5z := 04000021B
    else
        l4var5z := 04000010B;
    if (SY = BECOMES) then {
        expression;
        l4var9z := true;
    } else {
        l4var9z := false;
    };
    l4var3z := curExpr;
    l4var6z := insnTemp[ADD];
    if not typeCheck(l4var1z, l4var3z@.f[0].t) then
        error(31); (* errIncompatibleTypesOfLoopIndexAndExpr *)
(todownto)
    if (SY = TOSY) then
        exit todownto
    else if (SY = DOWNTOSY) then
        l4var6z := insnTemp[SUB]
    else
        error(70); (* errNeitherToNorDownto *)
    expression;
    if not typeCheck(l4var1z, curExpr@.f[0].t) then
        error(31); (* errIncompatibleTypesOfLoopIndexAndExpr *)
    formOperator(gen0);
    l4var4z := curExpr;
    if (l4var9z) then {
        curExpr := l4var3z;
        formOperator(LOAD);
    } else {
        form1Insn(insnTemp[XTA] + l4var5z);
    };
    l4var7z := (0);
    disableNorm;
    formJumpOnCond(l4var7z);
    formLabel;
    l4var8z := moduleOffset;
    checkSymAndRead(DOSY);
    statement;
    disableNorm;
    curExpr := l4var2z;
    formOperator(LOAD);
    form1Insn(l4var6z + l4var5z);
    P0715((0), l4var7z);
    formOperator(STORE);
    curExpr := l4var4z;
    if (l4var6z = insnTemp[SUB]) then
        curVal.i := l4var6z
    else
        curVal.i := insnTemp[RSUB];
    (*15401*)
    formOperator(gen3);
    form1Insn(insnTemp[U1A] + l4var8z);
}; (* forStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure withStatement;
var
    l4var1z: @expr;
    l4var2z, l4var3z: bitset;
    l4var4z: integer;
{
    l4var1z := strp63z;
    l4var4z := l2var20z;
    l4var2z := set147z;
    l4var3z := [];
    repeat
        inSymbol;
        if (hashTravPtr <> NIL) and
           (hashTravPtr@.f[4].c >= chr(3C)) then {
            parseLval;
            if (curExpr@.f[0].s@.f[2].c = chr(6C)) then {
                formOperator(SETREG);
                l4var3z := (l4var3z + [curVal.i]) * set148z;
            } else {
                error(71); (* errWithOperatorNotOfARecord *)
            };
        } else {
            error(72); (* errWithOperatorNotOfAVariable *)
        }
    until (SY <> COMMA);
    checkSymAndRead(DOSY);
    statement;
    strp63z := l4var1z;
    l2var20z := l4var4z;
    set147z := l4var2z;
    set145z := (set145z + l4var3z);
}; (* withStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure reportStmtType(l4arg1z: integer);
{
    writeln(' STATEMENT ', stmtname:0, ' IN ', l3var9z:0, ' LINE');
}; (* reportStmtType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function structBranch(isGoto: boolean): boolean;
var
    curLab: @strLabel;
{
    structBranch := true;
    if (SY = IDENT) or not isGoto then {
        curLab := strLabList;
        l2var19z := (1);
        while (curLab <> NIL) do {
            with curLab@ do {
                if (ident.m = []) then {
                    l2var19z := (l2var19z - (1));
                } else {
                    if (ident = curIdent) then {
                        if (l2var19z = (1)) then {
                            if (isGoto) then {
                                form1Insn(insnTemp[VJM] + offset);
                            } else {
                                formJumpOnCond(curLab@.exitTarget);
                            };
                        } else {
                            form1Insn(getValueOrAllocSymtab(l2var19z) +
                                      66400000B);
                            if (isGoto) then {
                                form1Insn(52400000B + curLab@.offset);
                            } else {
                                int51z := 52400000B;
                                formJumpOnCond(curLab@.exitTarget);
                                int51z := insnTemp[VJM];
                            };
                            form1Insn(getHelperProc(60) +
                                      6437777713700000C); (* P/ZAM *)
                        };
                        exit
                    }
                };
                curLab := curLab@.next;
            }
        };
        if not isGoto and (SY <> IDENT) then {
            if (l2var19z <> (1)) then {
                form1Insn(getValueOrAllocSymtab(l2var19z) + 66400000B);
                form1Insn(getHelperProc(60)); (* P/ZAM *)
            };
            formJumpOnCond(int53z);
        } else {
            error(errNotDefined);
        }
    } else
        structBranch := false;
}; (* structBranch *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure caseStatement;
label
    16211;
type
    casechain = record
        next:   @casechain;
        f: array [1..2] of word;
    end;
var
    l4var1z, l4var2z, l4var3z, l4var4z: @casechain;
    l4var5z: word;
    l4var6z: boolean;
    l4var7z: integer;
    l4var8z, l4var9z, l4var10z, l4var11z: word;
    l4var12z: @types;
    l4var13z, l4var14z, l4var15z: word;
    l4var16z, l4var17z, l4var18z: integer;
    l4var19z, l4var20z, l4var21z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function max(a, b: integer): integer;
{
    if (b < a) then
        max := a
    else
        max := b;
}; (* max *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* caseStatement *)
    l4var16z := lineCnt;
    expression;
    l4var12z := curExpr@.f[0].t;
    l4var6z := false;
    if (l4var12z = alfaType) or
       (l4var12z@.k IN [kindScalar, kindRange]) then
        formOperator(LOAD)
    else
        error(25); (* errExprNotOfADiscreteType *)
    disableNorm;
    l4var17z := (0);
    l4var18z := (0);
    l4var1z := NIL;
    formJumpOnCond(l4var17z);
    checkSymAndRead(OFSY);
    l4var10z.s := NIL;
    l4var9z.b := true;
    (* 15640 *)
    repeat
        if not (SY IN [SEMICOLON, ENDSY]) then {
            formLabel;
            arithMode := (1);
            if (SY = OTHERSY) then {
                if (l4var6z) then
                    error(73); (* errCaseLabelsIdentical *)
                inSymbol;
                l4var6z := true;
                l4var7z := moduleOffset;
            } else (* 15657 *) repeat
                parseLiteral(l4var11z.t, l4var13z, true);
                if (l4var11z.s <> NIL) then {
                    if (l4var10z.s = NIL) then {
                        l4var10z := l4var11z;
                    } else {
                        if not typeCheck(l4var11z.t, l4var10z.t) then
                            error(errConstOfOtherTypeNeeded);
                    }; (* 15700 *)
                    new(l4var3z);
                    l4var3z@.f[1] := l4var13z;
                    l4var3z@.f[2].i := moduleOffset;
                    l4var2z := l4var1z;
(loop)              while (l4var2z <> NIL) do {
                        if (l4var13z = l4var2z@.f[1]) then {
                            error(73); (* errIdenticalCaseLabels *)
                            exit loop
                        } else if (l4var13z.i < l4var2z@.f[1].i) then {
                            exit loop
                        } else {
                            l4var4z := l4var2z;
                            l4var2z := l4var2z@.next;
                        }
                    }; (* 15723 *)
                    if (l4var2z = l4var1z) then {
                        l4var3z@.next := l4var1z;
                        l4var1z := l4var3z;
                    } else {
                        l4var3z@.next := l4var2z;
                        l4var4z@.next := l4var3z;
                    };
                    inSymbol;
                }; (* 15735 *)
                l4var8z.b := (SY <> COMMA);
                if not l4var8z.b then
                    inSymbol;
            until l4var8z.b; (* 15745 *)
            checkSymAndRead(COLON);
            statement;
            l4var9z.b := l4var9z.b and (arithMode = 1);
            formJumpOnCond(l4var18z);
        }; (* 15762 *)
        l4var8z.b := (SY = ENDSY);
        if not l4var8z.b then
            inSymbol;
        (* 15771 *)
    until l4var8z.b;
    if (SY <> ENDSY) then {
        requiredSymErr(ENDSY);
        stmtName := 'CASE  ';
        reportStmtType(l4var16z);
    } else
        inSymbol;
    if not typeCheck(l4var10z.t, l4var12z) then {
        error(88); (* errDifferentTypesOfLabelsAndExpr *);
        exit
    };
    formLabel;
    l4var5z.b := typeCheck(l4var12z, integerType);
    if (l4var1z <> NIL) then {
        l4var15z := l4var1z@.f[1];
        l4var19z := l4var15z;
        l4var2z := l4var1z;
        while (l4var2z <> NIL) do {
            if (l4var15z = l4var2z@.f[1]) and
               (l4var12z@.k = kindScalar) then {
                l4var21z := l4var15z;
                if (l4var5z.b) then {
                    l4var15z.i := (l4var15z.i + (1));
                } else {
                    curVal := l4var15z;
                    curVal.c := succ(curVal.c);
                    l4var15z := curVal;
                };
                l4var2z := l4var2z@.next;
            } else {
                l4var14z.i := 00102320B;
                P0715(0, l4var17z);
                if (l4var10z.s@.f[2].c = chr(2C)) then {
                    l4var14z.i := max(abs(l4var10z.s@.f[5].i),
                                      abs(l4var10z.s@.f[6].i));
                } else {
                    if (l4var10z.s@.f[2].c = chr(1C)) then
                        l4var14z := l4var10z.s@.f[4];
                };
                l4var8z.b := (l4var14z.i < 00076400B);
                if (l4var8z.b) then {
                    form1Insn(00400016B);
                } else {
                    form1Insn(74000001B);
                };
                l4var19z.i := (l4var19z.i - l4var19z.i); (* WTF? *)
                while (l4var1z <> NIL) do {
                    if (l4var8z.b) then {
                        curVal.i := (l4var19z.i - l4var1z@.f[1].i);
                        curVal.m := (curVal.m + intZero);
                        form1Insn(getValueOrAllocSymtab(curVal.i) +
                                  72500000B);
                        form1Insn(73400000B + l4var1z@.f[2].i);
                        l4var19z := l4var1z@.f[1];
                    } else {
                        form1Insn(74100001B);
                        curVal := l4var1z@.f[1];
                        form2Insn((getFCSToffset + 40120000B),
                                  (insnTemp[U1A] + l4var1z@.f[2].i));
                    };
                    l4var1z := l4var1z@.next;
                };
                if (l4var6z) then
                    form1Insn(insnTemp[VJM] + l4var7z);
                goto 16211;
            }; (* if 16141 *)
        }; (* while 16142 *)
        if (not l4var6z) then {
            l4var7z := moduleOffset;
            formJumpOnCond(l4var18z);
        };
        P0715(0, l4var17z);
        curVal := l4var19z;
        P0715(-(insnTemp[UJ]+l4var7z), l4var21z.i);
        curVal := l4var19z;
        curVal.m := (curVal.m + intZero);
        form1Insn(00400016B);
        curVal.i := ((moduleOffset + (1)) - curVal.i);
        if (curVal.i < 00040000B) then {
            curVal.i := (curVal.i - 00040000B);
            curVal.i := allocSymtabForAbsolute([24, 29] +
                        (curVal.m * O77777.m));
        };
        form1Insn(73000000B + curVal.i);
        while (l4var1z <> NIL) do {
            formLabel;
            form1Insn(insnTemp[VJM] + l4var1z@.f[2].i);
            l4var1z := l4var1z@.next;
        };
        16211:
        P0715(0, l4var18z);
        if (not l4var9z.b) then
           disableNorm;
        (* 16217 *)
    }
}; (* caseStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignStatement(l4arg1z: boolean);
label
    16332;
var
    l4var1z, l4var2z, l4var3z, l4var4z, l4var5z: word;
{
    if (l4arg1z) then
        parseLval
    else {
        new(curExpr);
        with curExpr@ do {
            f[0] := hashTravPtr@.f[3];
            op := op35;
            f[2].q := hashTravPtr;
        };
        inSymbol;
    };
    checkSymAndRead(BECOMES);
    bool102z := false;
    l4var5z := curExpr@.f[0];
    if (l4var5z.s@.f[2].c = chr(6C)) and
       (SY = LBRACK) then {
        formOperator(gen5);
        l4var3z.i := (0);
        inSymbol;
        l3var5z.c := chr(0C);
(indices)
        {
            if (SY = COMMA) then {
                l4var3z.i := (l4var3z.i + (1));
                inSymbol;
            } else if (SY = RBRACK) then {
                inSymbol;
                exit indices;
            } else (* 16262 *) {
                bool102z := false;
                expression;
                curVal := l4var3z;
                formOperator(gen6);
            }; (* 16270 *)
            goto indices;
        };
        curExpr := NIL;
    } else (* 16273 *)
    if (SY = SEMICOLON) and allowCompat then {
        formOperator(STORE);
        bool102z := true;
        curExpr := NIL;
    } else (* 16303 *) {
        l4var1z.e := curExpr;
        expression;
        l4var4z := curExpr@.f[0];
        if (typeCheck(l4var5z.t, l4var4z.t)) then {
            if (l4var4z.s@.f[2].c = chr(7C)) then
                error(75) (*errCannotAssignFiles*)
            else {
                if rangeMismatch and (l4var5z.s@.f[2].c = chr(2C)) then {
                    new(l4var2z.e);
                    with l4var2z.e@ do {
                        f[0] := l4var4z;
                        op := op50;
                        f[2].e := curExpr;
                        f[3] := l4var5z;
                    };
                    curExpr := l4var2z.e;
                };
16332:          new(l4var2z.e);
                with l4var2z.e@ do {
                    f[0] := l4var5z;
                    op := badop33;
                    f[2] := l4var1z;
                    f[3].e := curExpr;
                };
                curExpr := l4var2z.e;
            }
        } else if (l4var5z.t = realType) and
            typeCheck(integerType, l4var4z.t) then {
            castToReal(curExpr);
            goto 16332;
        } else {
            error(33); (*errIllegalTypesForAssignment*)
        }
    }
    (* 16356 *)
}; (* assignStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure compoundStatement;
{
(loop) {
        statement;
        if (SY = SEMICOLON) then {
            inSymbol;
            goto loop;
        }
    }
}; (* compoundStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure ifWhileStatement(l4arg1z: symbol);
{
    disableNorm;
    expression;
    if (curExpr@.f[0].t <> booleanType) then
        error(errBooleanNeeded)
    else {
        jumpTarget.i := (0);
        formOperator(gen15);
        l3var10z := jumpTarget;
    };
    checkSymAndRead(l4arg1z);
    statement;
}; (* ifWhileStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P16517;
label
    16545;
type
    DATAREC = record case boolean of
            false: (a: packed array [0..3] of 0..4095);
            true:  (w: word)
        end;
var
    l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
    l4var6z, l4var7z, l4var8z, l4var9z: word;
    F: file of DATAREC;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P16432(l5arg1z: integer);
var
    l5var1z: DATAREC;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F16417(l6arg1z: integer): integer;
{
    if (l6arg1z >= (2048)) then {
        curVal.i := l6arg1z;
        F16417 := allocSymtabForAbsolute((curVal.m + [24]) * halfWord);
    } else {
        F16417 := l6arg1z;
    }
}; (* F16417 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P16432 *)
    l5var1z.a[0] := F16417(l4var4z.i);
    if (FcstCnt = l4var3z.i) then {
        curVal := l4var8z;
        curVal.i := addSomethingToFCST;
    } else {
        curVal := l4var3z;
    };
    l5var1z.a[1] := allocSymtabForAbsolute([12,23] + curVal.m * halfWord);
    l5var1z.a[2] := F16417(l5arg1z);
    if (l4var9z.i = (0)) then {
        curVal := l4var7z;
        besm(ASN64+24);
        curVal := ;
    } else {
        curVal.i := allocSymtabForAbsolute(l4var7z.m + l4var9z.m * halfWord);
    };
    l5var1z.a[3] := curVal.i;
    l4var9z.i := l5arg1z * l4var4z.i + l4var9z.i;
    F@ := l5var1z;
    put(F);
    l4var2z.i := (l4var2z.i + (1));
    l4var4z.i := (0);
    l4var3z.i := FcstCnt;
}; (* P16432 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P16517 *)
    l4var1z.i := FcstCnt;
    inSymbol;
    l4var2z.i := (0);
(loop)
    repeat (* 16530 *)
        inSymbol;
        setup(l4var6z.s);
        if SY <> IDENT then {
            if SY = ENDSY then
                exit loop;
            error(errNoIdent);
            curExpr := uVarPtr;
        } else (* 16543 *) {
            if (hashTravPtr = NIL) then {
16545:          error(errNotDefined);
                curExpr := uVarPtr;
                inSymbol;
            } else {
                if (hashTravPtr@.f[4].c = chr(3C)) then {
                    parseLval;
                } else goto 16545;
            }
        }; (* 16557 *)
        putLeft := true;
        objBufIdx := (1);
        formOperator(gen5);
        if (objBufIdx <> (1)) then
            error(errVarTooComplex);
        l4var7z.m := (isLeftInsn.m * [12,13,14,15,16,17,18,19,20,21,22,23]);
        l4var3z.i := FcstCnt;
        l4var4z.i := (0);
        l4var9z.i := (0);
        repeat (* 16574 *)
            expression;
            formOperator(LITINSN);
            l4var8z := curVal;
            if (SY = COLON) then {
                inSymbol;
                l4var5z := curToken;
                if (SY <> INTCONST) then {
                    error(62); (* errIntegerNeeded *)
                    l4var5z.i := (0);
                } else
                    inSymbol;
            } else
                l4var5z.i := (1);
            if (l4var5z.i <> (1)) then {
                if (l4var4z.i <> (0)) then
                    P16432((1));
                l4var4z.i := (1);
                P16432(l4var5z.i);
            } else {
                l4var4z.i := (l4var4z.i + (1));
                if (SY = COMMA) then {
                    curVal := l4var8z;
                    toFCST;
                } else {
                    if (l4var4z.i <> (1)) then {
                        curVal := l4var8z;
                        toFCST;
                    };
                    P16432((1));
                }
            }; (* 16641 *)
        until SY <> COMMA;
        rollup(l4var6z.s);
    until SY <> SEMICOLON; (* 16645 *)
    if (SY <> ENDSY) then
        error(errBadSymbol);
    reset(F);
    while not eof(F) do {
        FCST@ := F@.w;
        put(FCST);
        get(F);
    };
    int92z := (FcstCnt - l4var1z.i);
    FcstCnt := l4var1z.i;
    int93z := l4var2z.i;
    (* 16666 *)
}; (* P16517 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure standProc;
label
    17753, 20041;
var
    l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
    l4var6z, l4var7z, l4var8z, l4var9z, l4var10z,
    l4var11z, l4var12z, l4var13z, l4var14z, l4var15z,
    l4var16z, l4var17z: word;
    l4var18z: opgen;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P16667(l5arg1z: @types);
{
    if (hashTravPtr <> NIL) and
       (hashTravPtr@.f[4].c >= chr(3C)) then {
        parseLval;
        if (l5arg1z <> NIL) and
           not typeCheck(l5arg1z, curExpr@.typ) then
            error(errNeedOtherTypesOfOperands);
    } else {
        error(errNotDefined);
        curExpr := uVarPtr;
    }
}; (* P16667 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure startReadOrWrite(l5arg1z: boolean);
{
    expression;
    l4var3z := curExpr@.f[0];
    l4var7z.e := curExpr;
    if not (l5arg1z) then {
        if not (curExpr@.f[1].i IN lvalOpSet) then
            error(27); (* errExpressionWhereVariableExpected *)
    };
    if (l4var9z.s = NIL) then {
        if (l4var3z.s@.f[2].c = chr(7C)) then {
            l4var9z.e := curExpr;
        } else {
            new(l4var9z.e);
            l4var9z.e@.typ := textType;
            l4var9z.e@.op := op35;
            if (l5arg1z) then {
                l4var9z.s@.f[2].q := outputFile;
            } else {
                if (inputFile <> NIL) then
                    l4var9z.s@.f[2].q := inputFile
                else
                    error(37); (* errInputMissingInProgramHeader *)
            }
        };
        arg2Type := l4var9z.s@.f[0].t;
        l4var13z.b := typeCheck(arg2Type@.base, charType);
        l4var12z.c := chr(1C);
        new(l4var8z.e);
        l4var8z.e@.typ := arg2Type@.base;
        l4var8z.e@.op := op43;
        l4var8z.e@.f[2] := l4var9z;
        new(l4var6z.e);
        l4var6z.e@.typ := l4var8z.e@.typ;
        l4var6z.e@.op := badop33;
        if (l5arg1z) then
            l4var6z.e@.f[2] := l4var8z
        else
            l4var6z.e@.f[3] := l4var8z;
    } (* 17002 *)
}; (* startReadOrWrite *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseWidthSpecifier(var l5arg1z: @expr);
{
    expression;
    if not typeCheck(integerType, curExpr@.f[0].t) then {
        error(14); (* errExprIsNotInteger *)
        curExpr := uVarPtr;
    };
    l5arg1z := curExpr;
}; (* parseWidthSpecifier *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P17020;
{
    if ([12] <= set145z) or (l4var12z.b) then {
        curExpr := l4var9z.e;
        formOperator(gen8);
    };
    l4var12z.b := false;
    formInsnAndLabel(getHelperProc(l4var17z.i));
    disableNorm;
}; (* P17020 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P17037;
{
    set145z := (set145z - [12]);
    if (l4var17z.i <> (49)) and
       not typeCheck(l4var8z.s@.f[0].t, l4var7z.s@.f[0].t) then
        error(34) (* errTypeIsNotAFileElementType *)
    else {
        if (l4var17z.i = (29)) then {
            l4var6z.s@.f[3] := l4var7z;
        } else {
            if (l4var17z.i = (49)) then
                l4var17z.i := (30);
            l4var6z.s@.f[2] := l4var7z;
        };
        curExpr := l4var6z.e;
        formOperator(gen7);
        P17020;
    }
}; (* P17037 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkElementForReadWrite;
var l5var1z: word;
{
 set145z := (set145z - [12]);
 if (l4var3z.s@.f[2].c = chr(2C)) then
    l4var3z := l4var3z.s@.f[3];
 curVarKind := l4var3z.s@.f[2].k;
 l4var17z.i := (36);
 if (l4var3z.t = integerType) then
    l4var15z.i := (10)
 else if (l4var3z.t = realType) then {
    l4var17z.i := (37);
    l4var15z.i := (14);
 } else if (l4var3z.t = charType) then {
    l4var17z.i := (38);
    l4var15z.i := (1);
 } else if (curVarKind = kindScalar) then {
    l4var17z.i := (41);
    P13026(l4var3z.s);
    l4var15z.i := (8);
 } else if (isCharArray(l4var3z.t)) then {
    l5var1z.s := ref(l4var3z.s@.f[4].s@.f[0]);
    l4var15z.i := ((l5var1z.s@.f[6].i - l5var1z.s@.f[5].i) + (1));
    if not (l4var3z.s@.f[5].b) then
       l4var17z.i := (81)
    else if ((6) >= l4var15z.i) then
       l4var17z.i := (39)
    else
       l4var17z.i := (40);
 } else if (l4var3z.s@.f[0].i = (1)) then {
    l4var17z.i := (42);
    l4var15z.i := (17);
 } else
 error(34); (* errTypeIsNotAFileElementType *)
}; (* checkElementForReadWrite *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure writeProc;
{
 l4var9z.s := NIL;
 l4var13z.b := true;
 repeat {
    startReadOrWrite(true);
    if (l4var7z <> l4var9z) then {
       if not (l4var13z.b) then {
          l4var17z.i := (29);
          P17037;
       } else {
          checkElementForReadWrite;
          l4var5z.s := NIL;
          l4var4z.s := NIL;
          if (SY = COLON) then
             parseWidthSpecifier(l4var4z.e);
          if (SY = COLON) then {
             parseWidthSpecifier(l4var5z.e);
             if (l4var17z.i <> (37)) then
                error(35); (* errSecondSpecifierForWriteOnlyForReal *)
          } else {
             if (curToken = litOct) then {
                l4var17z.i := (42);
                l4var15z.i := (17);
                if (l4var3z.s@.f[0].i <> (1)) then
                   error(34); (* errTypeIsNotAFileElementType *)
                inSymbol;
             }
          };
          l4var11z.c := chr(0C);
          if (l4var4z.s = NIL) and
             (l4var17z.i IN [38,39,40]) then {
             l4var17z.i := (l4var17z.i + (5));
             l4var11z.c := chr(1C);
          } else {
             if (l4var4z.s = NIL) then {
                curVal := l4var15z;
                formOperator(gen9);
             } else {
                curExpr := l4var4z.e;
                formOperator(LOAD);
             }
          };
          if (l4var17z.i = (37)) then {
             if (l4var5z.s = NIL) then {
                curVal.i := (4);
                form1Insn((getFCSToffset + 40030000B));
             } else {
               curExpr := l4var5z.e;
               formOperator(gen10);
             }
          };
          curExpr := l4var7z.e;
          if (l4var11z.b) then {
             if (l4var17z.i = (45)) then
                l4var18z := gen11
             else
                l4var18z := LOAD;
          } else {
             if (l4var17z.i = (40)) or
                (l4var17z.i = (81)) then
                l4var18z := gen12
             else
                l4var18z := gen10;
          };
          formOperator(l4var18z);
          if (l4var17z.i IN [39,40,44,45]) or
             (l4var17z.i = (81)) then
             form1Insn((52400000B + l4var15z.i))
          else {
             if (l4var17z.i = (41)) then
                form1Insn((56400000B + l4var3z.s@.f[5].i));
          };
          P17020;
       }
    }
 } until (SY <> COMMA);
 if (l4var16z.i = (11)) then {
    l4var17z.i := (46);
    P17020;
 };
 set145z := (set145z + [12]);
 if (l4var14z.i = moduleOffset) then
    error(36); (*errTooFewArguments *)
}; (* writeProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readProc;
label 17346, 17362;
{
 l4var9z.s := NIL;
 l4var13z.b := true;
 l4var14z.i := moduleOffset;
 repeat {
    startReadOrWrite(false);
    if (l4var7z <> l4var9z) then {
       if not (l4var13z.b) then {
          l4var17z.i := (30);
17346:
          P17037;
       } else {
          checkElementForReadWrite;
          if (l4var17z.i = (38)) then {
             l4var17z.i := (49);
             goto 17346;
          };
          if (l4var17z.i = (39)) or
             (l4var17z.i = (40)) then {
             l4var17z.i := (51);
17362:
             curExpr := l4var7z.e;
             formOperator(gen5);
             form1Insn((52400000B + l4var15z.i));
             P17020;
          } else {
             if (l4var17z.i = (81)) then {
                l4var17z.i := (90);
                goto 17362;
             };
             l4var17z.i := (l4var17z.i + (11));
             P17020;
             curExpr := l4var7z.e;
             formOperator(STORE);
          }
       }
    }
 } until (SY <> COMMA);
 set145z := (set145z + [12]);
 if (l4var16z.i = (13)) then {
    l4var17z.i := (53);
    P17020;
 };
 if (l4var14z.i = moduleOffset) then
    error(36); (* errTooFewArguments *)
}; (* readProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P17417;
{
 P16667(NIL);
 l4var9z.e := curExpr;
 l4var1z := curExpr@.f[0];
 if (l4var1z.s@.f[5].b) or
    (l4var1z.s@.f[2].c <> chr(5C)) then
    error(errNeedOtherTypesOfOperands);
 checkSymAndRead(COMMA);
 bool102z := false;
 expression;
 l4var8z.e := curExpr;
 if not typeCheck(l4var1z.s@.f[4].t, l4var8z.s@.f[0].t) then
    error(errNeedOtherTypesOfOperands);
}; (* P17417 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P17451;
var l5var1z: @struc;
{
 new(l4var7z.e);
 l4var7z.e@.f[0] := l4var1z.s@.f[3];
 l4var7z.e@.op := op34;
 l4var7z.e@.f[2] := l4var9z;
 l4var7z.e@.f[3] := l4var8z;
 l5var1z := ref(l4var6z.s@.f[0].s@);
 if (l5var1z@.f[2].c <> chr(5C)) or
    not l5var1z@.f[5].b or
    not typeCheck(l5var1z@.f[3].t, l4var1z.s@.f[3].t) or
    not typeCheck(l4var1z.s@.f[4].t, l5var1z@.f[4].t) then
    error(errNeedOtherTypesOfOperands);
 new(curExpr);
 curExpr@.f[0].c := chr(l4var16z.i + (50));
 curExpr@.f[2] := l4var7z;
 curExpr@.f[3] := l4var6z;
 formOperator(gen16);
}; (* P17451 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* standProc *)
 curVal := l3var12z.s@.f[5];
 l4var16z := curVal;
 l4var10z.b := (SY = LPAREN);
 l4var14z.i := moduleOffset;
 if not l4var10z.b and
    (l4var16z.i IN [0:5,8:10,12,16:28]) then
    error(45); (* errNoOpenParenForStandProc *)
 if (l4var16z.i IN [0,1,2,3,4,5,8,9]) then {
    inSymbol;
    if (hashTravPtr@.f[4].c < chr(3C)) then
       error(46); (* errNoVarForStandProc *)
    parseLval;
    arg1Type := curExpr@.f[0].t;
    curVarKind := arg1Type@.k;
 };
 if (l4var16z.i IN [0,1,2,3,4,5,6]) then
    jumpTarget.i := getHelperProc(29 + l4var16z.i); (* P/PF *)
 case l4var16z.i of
 0, 1, 2, 3: { (* put, get, rewrite, reset *)
    if (curVarKind <> kindFile) then
       error(47); (* errNoVarOfFileType *)
    if (l4var16z.i = (3)) and
       (SY = COMMA) then {
       formOperator(gen8);
       expression;
       if (not typeCheck(integerType, curExpr@.f[0].t)) then
          error(14); (* errExprIsNotInteger *)
       formOperator(LOAD);
       formInsnAndLabel(getHelperProc(97)); (*"P/RE"*)
    } else {
       formOperator(FILEACCESS);
    }
 };
 4, 5: { (* new, dispose *)
    if (curVarKind <> kindPtr) then
       error(13); (* errVarIsNotPointer *)
    heapCallsCnt := (heapCallsCnt + (1));
    l4var9z.e := curExpr;
    if (l4var16z.i = (5)) then
       formOperator(gen5);
    l2var13z := arg1Type@.base;
    l2var19z := l2var13z@.size;
    if (charClass = EQOP) then {
       expression;
       if not typeCheck(integerType, curExpr@.f[0].t) then
          error(14); (* errExprIsNotInteger *)
       formOperator(LOAD);
       form1Insn(00400016B);
    } else {
       if (arg1Type@.base@.k = kindRecord) then (workaround) {
          l4var1z.t := l2var13z@.base;
(loop)    while (SY = COMMA) and (l4var1z.s <> NIL) do {
             with l4var1z.s@ do
                ; (* useless *)
             inSymbol;
             parseLiteral(l4var2z.t, curVal, true);
             if (l4var2z.s = NIL) then
                exit loop
             else {
                inSymbol;
(loop2)         while (l4var1z.s <> NIL) do {
                   l4var2z := l4var1z;
                   while (l4var2z.s <> NIL) do {
                      if (l4var2z.s@.f[3] = curVal) then {
                         l2var19z := l4var1z.s@.f[0].i;
                         exit loop2;
                      };
                      l4var2z := l4var2z.s@.f[6];
                      (workaround);
                   };
                   l4var1z := l4var1z.s@.f[5];
                };
             };
             besm(2200000B); (* workaround *)
          }
       };
       form1Insn(getValueOrAllocSymtab(l2var19z) + 72400000B);
    };
    formInsnAndLabel(jumpTarget.i);
    if (l4var16z.i = (4)) then {
       curExpr := l4var9z.e;
       formOperator(STORE);
    }
 };
 6: { (* halt *)
    formInsnAndLabel(jumpTarget.i);
    exit
 };
 7: { (* stop *)
    form1Insn(00740000B);
    exit
 };
 8, 9: { (* setup, rollup *)
    if (curVarKind <> kindPtr) then
       error(13); (* errVarIsNotPointer *)
    if (l4var16z.i = (8)) then {
       form1Insn(04100027B);
       formOperator(STORE);
    } else {
       formOperator(LOAD);
       form1Insn(04000027B);
    }
 };
 10: { (* write *)
    writeProc;
 };
 11: 17753: { (* writeln *)
    if (SY = LPAREN) then {
       writeProc;
    } else {
       formInsnAndLabel(getHelperProc(54)); (*"P/WOLN"*)
       exit
    }
 };
 12: { (* read *)
    readProc;
 };
 13: { (* readln *)
    if (SY = LPAREN) then {
       readProc;
    } else {
       formInsnAndLabel(getHelperProc(55)); (*"P/RILN"*)
       exit
    }
 };
 14: { (* exit *)
    l4var10z.b := (SY = LPAREN);
    if (l4var10z.b) then
       inSymbol;
    if (SY = IDENT) then {
       if not structBranch(false) then
           error(1); (* errCommaOrSemicolonNeeded *)
       inSymbol;
    } else {
       formJumpOnCond(int53z);
    };
    if not (l4var10z.b) then
       exit
 };
 15: { (* debug *)
    if (debugPrint IN optSflags.m) then {
       l4var16z.i := (11);
       goto 17753;
    };
    while (SY <> RPAREN) do
       inSymbol;
 };
 16: { (* besm *)
    expression;
    formOperator(LITINSN);
    formInsnAndLabel(curVal.i);
 };
 17: { (* mapia *)
    l4var1z.t := integerType;
    l4var2z.t := alfaType;
 20041:
    expression;
    if not typeCheck(curExpr@.f[0].t, l4var1z.t) then
       error(errNeedOtherTypesOfOperands);
    checkSymAndRead(COMMA);
    formOperator(LOAD);
    if (l4var16z.i = (17)) then {
       form3Insn(ASN64-33, 04210022B, 04120007B);
    } else {
       form3Insn(04200022B, ASN64+33, 04120011B);
    };
    P16667(l4var2z.t);
    formOperator(STORE);
 };
 18: { (* mapai *)
    l4var1z.t := alfaType;
    l4var2z.t := integerType;
    goto 20041;
 };
 19, 20: { (* pck, unpck *)
    inSymbol;
    P16667(charType);
    checkSymAndRead(COMMA);
    formOperator(gen8);
    P16667(alfaType);
    if (l4var16z.i = (20)) then {
       formOperator(LOAD);
    };
    formInsnAndLabel(getHelperProc(l4var16z.i - 6));
    if (l4var16z.i = (19)) then
       formOperator(STORE);
 };
 21: { (* pack *)
    inSymbol;
    P17417;
    checkSymAndRead(COMMA);
    P16667(NIL);
    l4var6z.e := curExpr;
    P17451;
 };
 22: { (* unpack *)
    inSymbol;
    P16667(NIL);
    l4var6z.e := curExpr;
    checkSymAndRead(COMMA);
    P17417;
    P17451;
 };
 23, 24, 25, 26, 27, 28: { (* MARS procedures *)
    l3var5z.b := ((24) < l4var16z.i);
    repeat {
       expression;
       if (curExpr@.f[0].s@.f[0].i <> (1)) then
          error(5); (*errSimpleTypeReq*)
       formOperator(LOAD);
       if (l3var5z.b) then {
          checkSymAndRead(COMMA);
          P16667(NIL);
          l4var9z.e := curExpr;
          if (SY = COLON) then {
             expression;
             formOperator(gen10);
          } else {
             form2Insn(72400000B + l4var9z.s@.f[0].s@.f[0].i, 00430016B);
          };
          curExpr := l4var9z.e;
          formOperator(gen12);
       } else {
          form2Insn(insnTemp[XTS], insnTemp[XTS]);
       };
       form1Insn(72377751B + l4var16z.i);
       formInsnAndLabel(getHelperProc(80)); (*"PAIB"*)
    } until (SY <> COMMA);
 };
 end; (* 20257 *)
 if l4var16z.i in [0,1,2,3,5,10,11,12,13,21,22] then
    arithMode := 1;
 checkSymAndRead(RPAREN);
(* 20265 *)}; (* standProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* statement *)
 setup(l3var1z);
 bool110z := false;
 l3var9z := lineCnt;
 if (set147z = halfWord) then
    P16517
 else {
    if (SY = INTCONST) then {
       set146z := [];
       l3var2z := numLabList;
       disableNorm;
       l3var5z.b := true;
       formLabel;
       while (l3var2z <> l2var16z) do { with l3var2z@ do
          if (id <> curToken) then {
             l3var2z := next;
          } else {
             l3var5z.b := false;
             if (defined) then {
                curVal.i := line;
                error(17); (* errLblAlreadyDefinedInLine *);
             } else {
                l3var2z@.line := lineCnt;
                l3var2z@.defined := true;
                formLabel;
                if (l3var2z@.offset = (0)) then
                { }
                else if (l3var2z@.offset >= 00074000B) then {
                   curVal.i := (moduleOffset - 00040000B);
                   symTab[l3var2z@.offset].m := [24,29] + curVal.m * O77777.m;
                } else {
                  P0715((0), l3var2z@.offset);
                }; (* 20342 *)
                l3var2z@.offset := moduleOffset;
             };
             l3var2z := l2var16z;
          };
       }; (* while 20346 *)
       if (l3var5z.b) then
          error(16); (* errLblNotDefinedInBlock *);
       inSymbol;
       checkSymAndRead(COLON);
    }; (* 20355*)
    if (54B (*debugInteractive*) IN optSflags.m) and
       (glob88z.i <> lineCnt) then {
       P0715(-1, 96 (* "P/DD" *));
       glob88z.i := lineCnt;
       arithMode := (1);
    };
    l3var4z.b := (SY IN [BEGINSY,CASESY,REPEATSY,SELECTSY]);
    if (l3var4z.b) then
       lineNesting := (lineNesting + (1));
(ident)
        if (SY = IDENT) then {
       if (hashTravPtr <> NIL) then {
          l3var6z := hashTravPtr@.f[4];
          if (l3var6z.c >= chr(3C)) then {
             assignStatement(true);
          } else {
             if (l3var6z.c = chr(2C)) then {
                if (hashTravPtr@.f[3].s = NIL) then {
                   l3var12z.q := hashTravPtr;
                   inSymbol;
                   if (l3var12z.s@.f[1].i = (0)) then {
                      standProc;
                      exit ident;
                   };
                   parseCallArgs(l3var12z.q);
                } else {
                   assignStatement(false);
                };
             } else {
                error(32); (* errWrongStartOfOperator *)
                goto 8888;
             }
          };
          formOperator(gen7);
       } else {
          error(errNotDefined);
8888:     skip(skipToSet + statEndSys);
       };
    } else (* 20431 *) if (SY = LPAREN) then {
       set146z := [];
       inSymbol;
       if (SY <> IDENT) then {
          error(errNoIdent);
          goto 8888;
       };
       new(l3var3z);
       formLabel;
       disableNorm;
       with l3var3z@ do {
          next := strLabList;
          ident := curIdent;
          offset := moduleOffset;
          exitTarget := 0;
       };
       strLabList := l3var3z;
       inSymbol;
       checkSymAndRead(RPAREN);
       statement;
       P0715((0), l3var3z@.exitTarget);
       strLabList := strLabList@.next;
    } else (* 20463 *) if (SY = BEGINSY) then
(rep) {
       inSymbol;
(skip) {
          compoundStatement;
          if (SY <> ENDSY) then {
             stmtName := ' BEGIN';
             requiredSymErr(SEMICOLON);
             reportStmtType(l3var9z);
             skip(bigSkipSet);
             if (SY IN statBegSys) then
                goto skip;
             if (SY <> SEMICOLON) then
                exit rep;
             goto rep;
             (workaround) exit rep;
          };
       };
       inSymbol;
    } else (* 20511 *) if (SY = GOTOSY) then {
       inSymbol;
       if (SY <> INTCONST) then {
          if structBranch(true) then {
             inSymbol;
             exit;
          } else
             goto 8888;
       };
       disableNorm;
       l3var2z := numLabList;
(loop) if (l3var2z <> NIL) then with l3var2z@ do {
          if (id <> curToken) then {
             l3var2z := next;
          } else {
             if (curFrameRegTemplate = frame) then {
                if (offset >= 00040000B) then {
                   form1Insn(insnTemp[VJM] + offset);
                } else {
                   formJumpOnCond(offset);
                }
             } else {
                if offset = 0 then {
                   offset := symTabPos;
                   putToSymTab([]);
                };
                form3Insn(frame + 00440015B, 72400000B + offset,
                          getHelperProc(18(*"P/RC"*)) + (-64100000B));
             };
             exit loop;
          };
          goto loop;
       } else
          error(18); (* errLblNotDefined *)
       inSymbol;
    } else (* 20571 *) if (SY = IFSY) then {
       ifWhileStatement(THENSY);
       if (SY = ELSESY) then {
          l3var11z.i := (0);
          formJumpOnCond(l3var11z.i);
          P0715(0, l3var10z.i);
          l3var8z.i := arithMode;
          arithMode := (1);
          inSymbol;
          statement;
          P0715(0, l3var11z.i);
          if (l3var8z.i <> arithMode) then {
             arithMode := (2);
             disableNorm;
          }
       } else {
          P0715(0, l3var10z.i);
       }
    } else (* 20625 *) if (SY = WHILESY) then {
       set146z := [];
       disableNorm;
       formLabel;
       l3var8z.i := moduleOffset;
       ifWhileStatement(DOSY);
       disableNorm;
       form1Insn(insnTemp[VJM] + l3var8z.i);
       P0715(0, l3var10z.i);
       arithMode := (1);
    } else (* 20644 *) if (SY = REPEATSY) then {
       set146z := [];
       disableNorm;
       formLabel;
       l3var7z.i := moduleOffset;
       repeat
          inSymbol;
          statement;
       until (SY <> SEMICOLON);
       if (SY <> UNTILSY) then {
          requiredSymErr(UNTILSY);
          stmtName := 'REPEAT';
          reportStmtType(l3var9z);
          goto 8888;
       };
       disableNorm;
       expression;
       if (curExpr@.f[0].t <> booleanType) then {
          error(errBooleanNeeded)
       } else {
         jumpTarget := l3var7z;
         formOperator(gen15);
       };
    } else (* 20676 *)
    if (SY = FORSY) then {
       set146z := [];
       forStatement;
    } else (* 20702 *) if (SY = SELECTSY) then {
       disableNorm;
       l3var5z.b := true;
       l3var11z.i := (0);
       (* 20707 *)
       repeat
          arithMode := (1);
          expression;
          if (curExpr@.f[0].t <> booleanType) then {
             error(errBooleanNeeded);
          } else {
             jumpTarget.i := (0);
             formOperator(gen15);
             l3var10z := jumpTarget;
          };
          checkSymAndRead(COLON);
          statement;
          formJumpOnCond(l3var11z.i);
          l3var5z.b := l3var5z.b and (arithMode = 1);
          P0715(0, l3var10z.i);
       until (SY <> SEMICOLON);
       checkSymAndRead(ENDSY);
       P0715((0), l3var11z.i);
       if not l3var5z.b then {
          arithMode := (2);
          disableNorm;
       }
    } else (* 20751 *) if (SY = CASESY) then {
       caseStatement
    } else if (SY = WITHSY) then {
       withStatement;
       (q) exit q; (* workaround *)
    }; (* 20757 *)
    if (l3var4z.b) then
       lineNesting := (lineNesting - (1));
    rollup(l3var1z);
    if (bool110z) then {
       bool110z := false;
       goto 8888;
    }
 }
(* 20766 *)}; (* statement *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure outputObjFile;
var l3var1z: integer;
{
 formLabel;
 objBufIdx := (objBufIdx - (1));
 for l3var1z to objBufIdx do
    write(CHILD, objBufBase[l3var1z]);
 lineStartOffset := moduleOffset;
 glob95z.i := (0);
}; (* outputObjFile *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure defineRoutine;
var l3var1z, l3var2z, l3var3z, l3var4z, l3var5z, l3var6z, l3var7z: word;
{
 objBufIdx := (1);
 objBufBase[objBufIdx].m := [];
 curInsnTemplate.i := insnTemp[XTA];
 bool48z := 22 IN l2arg2z@.f[11].m;
 lineStartOffset := moduleOffset;
 l3var1z := ;
 int92z := (2);
 strp63z := NIL;
 arithMode := (1);
 set146z := [];
 set147z := [curProcNesting+1..6];
 set148z := set147z - [minel(set147z)];
 l3var7z.m := set147z;
 int53z := (0);
 set145z := [1:15] - set147z;
 if (curProcNesting <> 1) then
    parseDecls(2);
 l2var21z := l2var20z;
 if (SY <> BEGINSY) then
    requiredSymErr(BEGINSY);
 if 23 IN l2arg2z@.f[11].m then {
    l3var5z := l2arg2z@.f[7];
    l3var4z.i := (3);
    if (l2arg2z@.f[3].s <> NIL) then
    l3var4z.i := (4);
    while (l3var5z.q <> l2arg2z) do {
       if (l3var5z.s@.f[4].c = chr(3C)) then {
          l3var2z := l3var5z.s@.f[3].s@.f[0];
          if (l3var2z.i <> (1)) then {
             form3Insn(72400000B + l3var4z.i,
                       62400000B + l3var2z.i,
                       56400000B + l3var5z.s@.f[6].i);
             formInsnAndLabel(getHelperProc(73)); (* "P/LNGPAR" *)
          }
       };
       l3var4z.i := l3var4z.i + 1;
       l3var5z := l3var5z.s@.f[5];
    }
 }; (* 21105 *)
 if checkBounds or not (NoStackCheck IN optSflags.m) then
    P0715(-1, 95); (* P/SC *)
 l3var2z.i := lineNesting;
 repeat
    statement;
    if (SY = SEMICOLON) then {
       if (curProcNesting = (1)) then
          requiredSymErr(PERIOD);
       inSymbol;
       l2var8z := (SY IN blockBegSys);
       if not l2var8z and not errors then
          error(84); (* errErrorInDeclarations *)
    } else {
       if (SY = PERIOD) and (curProcNesting = (1)) then
          l2var8z := true
       else {
          errAndSkip(errBadSymbol, skipToSet);
          l2var8z := (SY IN blockBegSys);
       }
    };
 until l2var8z;
 l2arg2z@.f[11].m := (set145z * [0:15]) + (l2arg2z@.f[11].m - l3var7z.m);
 lineNesting := (l3var2z.i - (1));
 if (int53z <> (0)) then
    P0715((0), int53z);
 if not bool48z and not doPMD and (l2var21z = 3) and (curProcNesting <> 1) and
    (set145z * [1:15] <> [1:15]) then {
     objBufBase[1].i := (37000702200000C);
     with l2arg2z@ do
        f[11].m := f[11].m + [25];
     if (objBufIdx = (2)) then {
        objBufBase[1].i := (6700000000000000C);
        putLeft := true;
     } else {
        l2arg2z@.f[10] := l3var1z;
        if 13 IN set145z then {
           curVal.i := minel([1:15] - set145z);
           besm(ASN64-24);
           l3var7z := ;
           objBufBase[2].m := objBufBase[2].m + [0,1,3,6,9] + l3var7z.m;
        } else {
           curVal.i := (13);
        };
        form1Insn(insnTemp[VJM] + indexreg[curVal.i]);
     }
 } else (* 21220 *) {
    if (l2var11z.i = (0)) then
       l2var22z := (27)
    else
       l2var22z := (28);
    form1Insn((getHelperProc(l2var22z) + (6437777713700000C)));
    if (curProcNesting = (1)) then {
       parseDecls((2));
       if S3 IN optSflags.m then
          formInsnAndLabel(getHelperProc(78)); (* "P/PMDSET" *)
       form1Insn(insnTemp[VJM] + l3var1z.i);
       curVal.i := (l2arg2z@.f[10].i - 00040000B);
       symTab[74002B].m := [24,29] + (curVal.m * halfWord);
    };
    curVal.i := l2var21z;
    if (curProcNesting <> (1)) then {
       curVal.i := (curVal.i - (2));
       l3var7z := curVal;
       besm(ASN64-24);
       l3var7z := ;
       objBufBase[glob57z.i].m := objBufBase[glob57z.i].m +
                               l3var7z.m + [0,1,2,3,4,6,8];
    }
 }; (* 21261 *)
 outputObjFile;
}; (* defineRoutine *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initScalars;
var l3var1z, l3var2z, l3var3z, l3var4z: word;
    l3var5z, l3var6z: integer;
    l3var7z: word; l3var8z, l3var9z: integer;
    temptype: @types;
    l3var11z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regSysType(l4arg1z:integer; l4arg2z: @types);
{
 new(l2var5z = 5);
 l2var5z@ := [l4arg1z, 0, , l4arg2z, chr(0)];
 addToHashTab(l2var5z);
}; (* regSysType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regSysEnum(l4arg1z: integer; l4arg2z: integer);
{
 new(l2var5z = 7);
 l2var5z@ := [l4arg1z, 48, , temptype, chr(1), NIL, l4arg2z];
 addToHashTab(l2var5z);
}; (* regSysEnum *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regSysProc(l4arg1z: integer);
{
 new(l2var5z = 6);
 l2var5z@ := [l4arg1z, 0, , temptype, chr(2), l3var9z];
 l3var9z := (l3var9z + (1));
 addToHashTab(l2var5z);
}; (* registerSysProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* initScalars *)
 new(booleanType,kindScalar);
 with booleanType@ do {
    size := (1);
    bits := (1);
    k := kindScalar;
    numen := (2);
    start := (0);
 };
 new(integerType, kindScalar);
 with integerType@ do {
    size := (1);
    bits := (48);
    k := kindScalar;
    numen := 100000;
    start := -1;
    enums := NIL;
 };
 new(charType, kindScalar);
 with charType@ do {
    size := (1);
    bits := (8);
    k := kindScalar;
    numen := (256);
    start := -1;
    enums := NIL;
 };
 new(realType,kindReal);
 with realType@ do {
    size := (1);
    bits := (48);
    k := kindReal;
 };
 new(setType, kindSet);
 with setType@ do {
    size := (1);
    bits := (48);
    k := kindSet;
    base := integerType;
 };
 new(pointerType, kindPtr);
 with pointerType@ do {
    size := (1);
    bits := (48);
    k := kindPtr;
    base := pointerType;
 };
 new(textType, kindFile);
 with textType@ do {
    size := (30);
    bits := (48);
    k := kindFile;
    base := charType;
    elsize := (8);
 };
 new(alfaType,kindArray);
 with alfaType@ do {
 size := (1);
 bits := (48);
 k := kindArray;
 base := charType;
 range := temptype;
 pck := true;
 perword := (6);
 pcksize := (8);
 };
 smallStringType[6] := alfaType;
 regSysType(51566445474562C(*" INTEGER"*), integerType);
 regSysType(42575754454156C(*" BOOLEAN"*), booleanType);
 regSysType(43504162C(*"    CHAR"*), charType);
 regSysType(62454154C(*"    REAL"*), realType);
 regSysType(41544641C(*"    ALFA"*), alfaType);
 regSysType(64457064C(*"    TEXT"*), textType);
 temptype := booleanType;
 regSysEnum(64626545C(*"    TRUE"*), (1C));
 hashTravPtr := l2var5z;
 regSysEnum(4641546345C(*"   FALSE"*), (0C));
 l2var5z@.f[5].q := hashTravPtr;
 booleanType@.enums := l2var5z;
 maxSmallString := (0);
 for strLen := 2 to 5 do
    assignType(smallStringType[strLen]);
 maxSmallString := (6);
 new(l2var5z = 7);
 with l2var5z@ do {
    offset := (0);
    typ := integerType;
    f[4].c := chr(3C);
    f[5].s := NIL;
    f[6].i := (7);
 };
 new(uVarPtr);
 with uVarPtr@ do {
    typ := integerType;
    op := op35;
    f[2].q := l2var5z;
 };
 new(uProcPtr);
 with uProcPtr@ do {
    f[3].s := NIL;
    f[5].s := NIL;
    f[7].s := NIL;
    f[8].s := NIL;
    f[10].i := (0);
 };
 temptype := NIL;
 l3var9z := (0);
 for l3var5z := 0 to 28 do
     regSysProc(systemProcNameBase[l3var5z]);
 l3var9z := (0);
 temptype := realType;
 regSysProc(63616264C(*"    SQRT"*));
 regSysProc(635156C(*"     SIN"*));
 regSysProc(435763C(*"     COS"*));
 regSysProc(416243644156C(*"  ARCTAN"*));
 regSysProc(416243635156C(*"  ARCSIN"*));
 regSysProc(5456C(*"      LN"*));
 regSysProc(457060C(*"     EXP"*));
 regSysProc(414263C(*"     ABS"*));
 temptype := integerType;
 regSysProc(6462655643C(*"   TRUNC"*));
 temptype := booleanType;
 regSysProc(574444C(*"     ODD"*));
 temptype := integerType;
 regSysProc(576244C(*"     ORD"*));
 temptype := charType;
 regSysProc(435062C(*"     CHR"*));
 regSysProc(63654343C(*"    SUCC"*));
 regSysProc(60624544C(*"    PRED"*));
 temptype := booleanType;
 regSysProc(455746C(*"     EOF"*));
 temptype := pointerType;
 regSysProc(624546C(*"     REF"*));
 temptype := booleanType;
 regSysProc(45575456C(*"    EOLN"*));
 temptype := integerType;
 regSysProc(636162C(*"     SQR"*));
 regSysProc(6257655644C(*"   ROUND"*));
 regSysProc(43416244C(*"    CARD"*));
 regSysProc(5551564554C(*"   MINEL"*));
 temptype := pointerType;
 regSysProc(606462C(*"     PTR"*));
 l3var11z.i := (30);
 l3var11z.m := ((l3var11z.m * halfWord) + [24,27,28,29]);
 new(programObj);
 curVal.i := 576564606564C(*"  OUTPUT"*);
 l3var3z := curVal;
 curVal.i := 5156606564C(*"   INPUT"*);
 l3var4z := curVal;
 curVal.i := 5657606257476241C(*"NOPROGRA"*);
 l3var2z := curVal;
 test1(PROGRAMSY, (skipToSet + [IDENT,LPAREN]));
 symTabPos := 00074004B;
 with programObj@ do {
    if (SY = IDENT) then {
       curVal := curIdent;
       id := ;
       f[10].i := (0);
       symTab[74000B] := makeNameWithStars(true);
    } else {
       id.i := (400000000000000C);
       error(errNoIdent);
       skip((skipToSet + [LPAREN]));
    };
 };
 if (curIdent <> l3var2z) then {
    entryPtTableBase[1] := symTab[74000B];
    entryPtTableBase[3].i := 6062574762415500C(*"PROGRAM "*);
    entryPtTableBase[2].i := (2000000000000000C);
    entryPtTableBase[4].i := (2000000000000000C);
    entryPtCnt := (5);
    CHILD@.i := (4247400103074002C);
    put(CHILD);
    moduleOffset := 00040001B;
 } else {
    entryPtCnt := (1);
    moduleOffset := 00040000B;
 };
 programObj@.f[7].s := NIL;
 programObj@.f[11].i := (0C);
 objBufIdx := (1);
 temptype := integerType;
 defineRange(temptype, (1), (6));
 alfaType@.range := temptype;
 int93z := (0);
 inSymbol;
 test1(LPAREN, (skipToSet + [IDENT]));
 outputObjFile;
 outputFile := NIL;
 inputFile := NIL;
 externFileList := NIL;
 new(l3var7z.q);
 lineStartOffset := moduleOffset;
 with l3var7z.q@ do {
     id := l3var3z;
     offset := (0);
     typ := textType;
     f[4].c := chr(3C);
     f[5].s := NIL;
 };
 curVal.i := 1257656460656412C(*"*OUTPUT*"*);
 l3var7z.s@.f[6].i := allocExtSymbol(l3var11z);
 addToHashTab(l3var7z.q);
 l3var5z := (1);
 while SY = IDENT do {
     l3var8z := (0);
     curVal := curIdent;
     l3var1z := makeNameWithStars(false);
     if (curIdent = l3var4z) then {
        new(inputFile);
        with inputFile@ do {
           id := curIdent;
           offset := (0);
           typ := textType;
           f[4].k := kindPtr;
           f[5].s := NIL;
        };
        curVal := l3var1z;
        inputFile@.f[6].i := allocExtSymbol(l3var11z);
        addToHashTab(inputFile);
        l3var8z := lineCnt;
     } else if (curIdent = l3var3z) then {
        outputFile := l3var7z.q;
        l3var8z := lineCnt;
     }; (* 21745 *)
     curExternFile := externFileList;
     while (curExternFile <> NIL) do {
        if (curExternFile@.id = curIdent) then {
           curExternFile := NIL;
           error(errIdentAlreadyDefined);
        } else {
           curExternFile := curExternFile@.next;
        };
     }; (* 21760 *)
     new(curExternFile, 5);
     with curExternFile@ do {
        id := curIdent;
        next := externFileList;
        f[4].i := l3var8z;
        offset := l3var1z.i;
     };
     if (l3var8z <> (0)) then {
        if (curIdent = l3var3z) then {
           glob157z := curExternFile;
        } else {
           glob158z := curExternFile;
        }
     };
     externFileList := curExternFile;
     l3var6z := l3var5z;
     l3var5z := (l3var5z + (1));
     inSymbol;
     if (charClass = MUL) then {
        l3var6z := (l3var6z + (64));
        inSymbol;
     };
     if (SY = INTCONST) then {
        l3var6z := 1000B * curToken.i + l3var6z;
        if (octalMode = chr(0C)) and
           ((1) < curToken.i) and
           (curToken.i < (127)) then {
           l3var6z := (l3var6z + (128));
        } else if (octalMode = chr(1C)) and
           (01000000B < curToken.i) and
           (curToken.i < (6400001743671743C)) then {
           l3var6z := (l3var6z + (256));
        } else {
           error(76); (* errWrongNumberForExternalFile *)
        };
        inSymbol;
     } else {
        l3var6z := (512);
     };
     curExternFile@.f[3].i := l3var6z;
     if (SY = COMMA) then
        inSymbol;
 }; (* 22042 *)
 checkSymAndRead(RPAREN);
 checkSymAndRead(SEMICOLON);
 if (outputFile = NIL) then {
    error(77); (* errNoOutput *)
    outputFile := l3var7z.q;
 };
 l3var6z := (40);
 repeat
    programme(l3var6z, programObj);
 until (SY = PERIOD);
 if (CH <> 'D') then {
    int92z := (0);
    int93z := ;
 } else {
    set147z := halfWord;
    dataCheck := false;
    statement;
 };
 readToPos80;
 curVal.i := l3var6z;
 symTab[74003B].m := (helperNameBase[25].m + [24,27,28,29]) +
                     (curVal.m * halfWord);
}; (* initScalars *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure makeExtFile;
{
 new(l2var10z);
 with l2var10z@ do {
    f[0].s := ptr(ord(curExternFile));
    f[3] := l2var6z;
    f[2].e := curExpr;
 };
 curExpr := l2var10z;
}; (* makeExtFile *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseParameters;
var l3var1z: word;
    l3var2z: @identrec;
    l3var3z: @identrec; l3var4z: word;
    l3var5z, l3var6z: integer;
    l3var7z: symbol; l3var8z: boolean; l3var9z: @types;
{
    int92z := (0);
    l3var5z := (0);
    int93z := (0);
    inSymbol;
    l3var2z := NIL;
    if not (SY IN [IDENT,VARSY,FUNCSY,PROCSY]) then
        errAndSkip( errBadSymbol, (skipToSet + [IDENT,RPAREN]) );
    int92z := (1);
    while (SY IN [IDENT,VARSY,FUNCSY,PROCSY]) do {
    l3var7z := SY;
    if (SY = IDENT) then
        l3var4z.c := chr(3C)
    else if (SY = VARSY) then
        l3var4z.c := chr(4C)
    else {
        l3var4z.c := chr(2C);
        (q) exit q; (* workaround *)
    };
    l3var3z := NIL;
    if (SY = PROCSY) then
        l3var9z := NIL
    else
        l3var9z := integerType;
    l3var6z := (0);
    if (SY <> IDENT) then {
        int93z := (0);
        inSymbol;
    };
    repeat if (SY = IDENT) then {
        if (bool100z) then
            error( errIdentAlreadyDefined );
        l3var6z := (l3var6z + (1));
        new(l3var1z.q, 7);
        with l3var1z.q@ do {
            id := curIdent;
            offset := curFrameRegTemplate;
            f[4] := l3var4z;
            next := symHashTabBase[bucket];
            f[3].s := NIL;
            f[5].q := l2var5z;
            f[6].i := l2var18z;
        };
        symHashTabBase[bucket] := l3var1z.q;
        l2var18z := (l2var18z + (1));
        if (l3var2z = NIL) then 
            l2var5z@.f[7] := l3var1z
        else
            l3var2z@.f[5] := l3var1z;
        l3var2z := l3var1z.q;
        if (l3var3z = NIL) then
            l3var3z := l3var1z.q;
        inSymbol;
    } else
        errAndSkip( errNoIdent, skipToSet + [RPAREN,COMMA,COLON]);
    l3var8z := (SY <> COMMA);
    if not l3var8z then {
        int93z := (0);
        inSymbol;
    };
    until l3var8z;
    if (l3var7z <> PROCSY) then {
        checkSymAndRead( COLON );
        parseTypeRef(l3var9z, (skipToSet + [IDENT,RPAREN]) );
        if (l3var7z <> VARSY) then { 
            if (isFileType( l3var9z)) then
            error(5) (*errSimpleTypeReq *)
            else if (l3var9z@.size <> (1)) then
                 l3var5z := l3var6z * l3var9z@.size + l3var5z;
        };
        if (l3var3z <> NIL) then
            while (l3var3z <> l2var5z) do with l3var3z@ do {
                f[3].t := l3var9z;
                l3var3z := f[5].q;
            };
    };

    if (SY = SEMICOLON) then {
        int93z := (0);
        inSymbol;
        if not (SY IN (skipToSet + [IDENT,VARSY,FUNCSY,PROCSY])) then
            errAndSkip( errBadSymbol, (skipToSet + [IDENT,RPAREN]) );
    };
    };
    (* 22276 *) if (l3var5z <> (0)) then {
        l2var5z@.f[11].m := (l2var5z@.f[11].m + [23]);
        l3var6z := l2var18z;
        l2var18z := (l2var18z + l3var5z);
        l3var2z := l2var5z@.f[7].q;
        (* 22306 *) while (l3var2z <> l2var5z) do {
            if (l3var2z@.f[4].c = chr(3C)) then {
                l3var5z := l3var2z@.f[3].s@.f[0].i;
                if (l3var5z <> (1)) then {
                    l3var2z@.f[6].i := l3var6z;
                    l3var6z := (l3var6z + l3var5z);
                }
            };
            l3var2z := l3var2z@.f[5].q;
        };
    };
    (* 22322 *) checkSymAndRead (RPAREN);
}; (* parseParameters *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure exitScope(var l3arg1z: array [0..127] of @identrec);
{
 for l2var19z := 0 to 127 do {
    l2var6z.q := l3arg1z[l2var19z];
    while (l2var6z.q <> NIL) and
          (l2var6z.q >= l2var3z.q) do
          l2var6z.q := l2var6z.q@.next;
    l3arg1z[l2var19z] := l2var6z.q;
 };
}; (* exitScope *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
{ (* programme *)
    l2var20z := l2arg1z;
    if (l2var20z = (0)) then {
        inSymbol;
        initScalars;
        exit;
    };
    l2var1z.m := [];
    l2var9z := false;
    l2var11z.i := (0);
    strLabList := NIL;
    lineNesting := (lineNesting + (1));
    l2var16z := numLabList;
    repeat
    if (SY = LABELSY) then {
        (*22367*) repeat
            inSymbol;
            if (SY <> INTCONST) then {
                requiredSymErr( INTCONST );
                goto 22421;
            };
            l2var15z := numLabList;
            while (l2var15z <> l2var16z) do {
                if (l2var15z@.id <> curToken) then {
                    l2var15z := l2var15z@.next;
                } else {
                    int97z := l2var15z@.line;
                    error(17); (* errLblAlreadyDefinedInLine *)
                    goto 22420;
                }
            };
            new(l2var15z);
            with l2var15z@ do {
                id := curToken;
                frame := curFrameRegTemplate;
                offset := (0);
                line := lineCnt;
                defined := false;
                next := numLabList;
            };
            numLabList := l2var15z;
22420:      inSymbol;
22421:      if not (SY IN [COMMA,SEMICOLON]) then
                errAndSkip(1, skipToSet + [COMMA,SEMICOLON]);
        until SY <> COMMA;
        if SY = SEMICOLON then
            inSymbol;
    }; (* 22432 *)
    if (SY = CONSTSY) then {
        parseDecls(0);
        while  (SY = IDENT) do {
            if (bool100z) then
                error(errIdentAlreadyDefined);
            new(l2var6z.s=7);
            l2var6z.s@ := [curIdent, curFrameRegTemplate,
                           symHashTabBase[bucket], , true, NIL];
            symHashTabBase[bucket] := l2var6z.q;
            inSymbol;
            if (charClass <> EQOP) then
                error(errBadSymbol)
            else
                inSymbol;
            with l2var6z.s@ do
                parseLiteral(f[3].t, f[6], true);
            if (l2var6z.s@.f[3].t = NIL) then {
                error(errNoConstant);
                l2var6z.s@.f[3].t := integerType;
                l2var6z.s@.f[6].i := (1);
            } else
                inSymbol;
            if (SY = SEMICOLON) then {
                int93z := (0);
                inSymbol;
                if not (SY IN (skipToSet + [IDENT])) then {
                    errAndSkip(errBadSymbol, skipToSet + [IDENT]);
                }
            } else {
                requiredSymErr(SEMICOLON);
            }
        }
    }; (* 22511 *) 
    objBufIdx := (1);
    if (SY = TYPESY) then {
        l2var9z := true;
        typelist := NIL;
        parseDecls(0);
        while SY = IDENT do {
            if bool100z then
                error(errIdentAlreadyDefined);
            l2var19z := bucket;
            l2var12z := curIdent;
            inSymbol;
            if (charClass <> EQOP) then
                error( errBadSymbol )
            else
                inSymbol;
            parseTypeRef(l2var13z, skipToSet + [SEMICOLON]);
            curIdent := l2var12z;
            if (F2751(l2var5z)) then {
                l2var14z.t := l2var5z@.f[3].t;
                if (l2var14z.t@.base = booleanType) then {
                    if (l2var13z@.k <> kindPtr) then {
                        parseDecls(1);
                        error(78); (* errPredefinedAsPointer *)
                    };
                    l2var14z.t@.base := l2var13z@.base;
                } else {
                    l2var14z.s@.f[3].t := l2var13z;
                    l2var5z@.f[3].t := l2var13z;
                };
                P2672(typelist, l2var5z);
            } else {
                new(l2var5z=5);
                with l2var5z@ do {
                    id := l2var12z;
                    offset := curFrameRegTemplate;
                    f[3].t := l2var13z;
                    f[4].m := [];
                }
            }; (* 22574 *)
            l2var5z@.next := symHashTabBase[l2var19z];
            symHashTabBase[l2var19z] := l2var5z;
            int93z := 0;
            checkSymAndRead(SEMICOLON);
        }; (* 22602 *)
        while (typelist <> NIL) do {
            l2var12z := typelist@.id;
            l2var5z := typelist;
            parseDecls(1);
            error(79); (* errNotFullyDefined *)
            typelist := typelist@.next;
        }
    }; (* TYPESY -> 22612 *)
    l2var9z := false;
    curExpr := NIL;
    if (SY = VARSY) then {
        parseDecls(0);
        (*22617*) repeat
            l2var6z.s := NIL;
            (*22620*) repeat 
            if (SY = IDENT) then {
                new(l2var5z=7);
                if (bool100z) then
                    error( errIdentAlreadyDefined );
                with l2var5z@ do {
                    id := curIdent;
                    offset := curFrameRegTemplate;
                    next := symHashTabBase[bucket];
                    f[4].c := chr(3C);
                    f[5].s := NIL;
                };
                symHashTabBase[bucket] := l2var5z;
                inSymbol;
                if (l2var6z.s = NIL) then
                    l2var6z.q := l2var5z
                else
                    l2var4z.s@.f[5].q := l2var5z;
                l2var4z.q := l2var5z;
            } else
                error(errNoIdent);
            if not (SY IN [COMMA,COLON]) then
                errAndSkip(1, skipToSet + [IDENT,COMMA]);
            l2var8z := SY <> COMMA;
            if not l2var8z then {
                int93z := (0);
                inSymbol;
            };
            (* 22663 -> 22620 *) until l2var8z;
            checkSymAndRead(COLON);
            parseTypeRef(l2var13z, skipToSet + [IDENT,SEMICOLON]);
            l2var22z := l2var13z@.size;
            while l2var6z.s <> NIL do with l2var6z.q@ do {
                l2var5z := f[5].q;
                typ := l2var13z;
                f[5].s := NIL;
                l2var8z := true;
                if (curProcNesting = (1)) then {
                    curExternFile := externFileList;
                    l2var12z := id;
                    curVal.i := l2var22z;
                    glob144z.m := curVal.m * halfWord + [24,27,28,29];
                    while l2var8z and (curExternFile <> NIL) do {
                        if (curExternFile@.id = l2var12z) then { 
                            l2var8z := false;
                            if (curExternFile@.f[4].i = 0) then {
                                curVal.i := curExternFile@.offset;
                                l2var6z.s@.f[6].i := allocExtSymbol(glob144z);
                                curExternFile@.f[4].i := lineCnt;
                            }
                        } else {
                            curExternFile := curExternFile@.next;
                        }
                    }
                }; (* 22731 *)
                if (l2var8z) then {
                    l2var6z.s@.f[6].i := l2var20z;
                    if (PASINFOR.listMode = 3) then {
                        write('VARIABLE ':25);
                        printTextWord(l2var6z.s@.f[0]);
                        writeln(' OFFSET (', curProcNesting:0, ') ',
                                l2var20z:5 oct, 'B. WORDS=',
                                l2var22z:5 oct, 'B');
                    };
                    l2var20z := (l2var20z + l2var22z);
                    curExternFile := NIL;
                }; (*22764*)
                if isFileType(l2var13z) then
                   makeExtFile;
                l2var6z.q := l2var5z;
            }; (* 22771 *)
            int93z := (0);
            checkSymAndRead( SEMICOLON );
            if (SY <> IDENT) and not (SY IN skipToSet) then
                errAndSkip(errBadSymbol, skipToSet + [IDENT]);
        (* 23001 -> 22617 *) until SY <> IDENT;
    }; (* VARSY -> 23003 *)
    if (curProcNesting = 1) then {
        l2var6z.q := outputFile;
        curExternFile := glob157z;
        makeExtFile;
        if (inputFile <> NIL) then {
            l2var6z.q := inputFile;
            curExternFile := glob158z;
            makeExtFile;
        }
    };
    if (curExpr <> NIL) then {
        l2var11z.i := moduleOffset;
        formOperator(gen14);
    } else 
        l2var11z.i := (0);
    if (curProcNesting = (1)) then {
        curExternFile := externFileList;
        while (curExternFile <> NIL) do {
            if (curExternFile@.f[4].i = (0)) then {
                error(80); (* errUndefinedExternFile *)
                printTextWord( curExternFile@.id);
                writeLN;
            };
            curExternFile := curExternFile@.next;
        }
    }; (*23035*)
    outputObjFile;
    while (SY = PROCSY) or (SY = FUNCSY) do {
        l2var8z := SY = PROCSY;
        if (curFrameRegTemplate = (7)) then {
            error(81); (* errProcNestingTooDeep *)
        };
        int93z := (0);
        inSymbol;
        if (SY <> IDENT) then {
            error( errNoIdent );
            l2var5z := uProcPtr;
            l2var7z := false;
        } else {
            if (bool100z) then with hashTravPtr@ do {
                if (f[4].c = chr(2C)) and
                   (f[5].s = NIL) and
                   (f[8].s <> NIL) and
                   ((typ = NIL) = l2var8z) then {
                    l2var7z := true;
                } else {
                    l2var7z := false;
                    error( errIdentAlreadyDefined );
                    printErrMsg(82); (* errPrevDeclWasNotForward *)
                };
            } else 
                l2var7z := false;
        }; (* 23103 *)
        if not l2var7z then {
            new(l2var5z);
            with l2var5z@ do {
                id := curIdent;
                offset := curFrameRegTemplate;
                next := symHashTabBase[bucket];
                typ := NIL;
                symHashTabBase[bucket] := l2var5z;
                f[4].c := chr(2C);
                f[5].s := NIL;
                f[6].i := (0);
                f[7].s := NIL;
                f[8].s := NIL;
                if (declExternal) then 
                   f[11].i := (7777740200000000C)
                else
                   f[11].i := (7777740000000000C);
                f[10].i := (0);
                curFrameRegTemplate := (curFrameRegTemplate + frameRegTemplate);
                if l2var8z then
                    l2var18z := (3)
                else
                    l2var18z := (4);
            };
            curProcNesting := (curProcNesting + (1));
            inSymbol;
            if ((6) < curProcNesting) then
                error(81); (* errProcNestingTooDeep *)
            if not (SY IN [LPAREN,SEMICOLON,COLON]) then
                errAndSkip(errBadSymbol, skipToSet + [LPAREN,SEMICOLON,COLON]);
            if (SY = LPAREN) then
                parseParameters;
            if not l2var8z then {
                if (SY <> COLON) then
                    errAndSkip(106 (*:*), skipToSet + [SEMICOLON])
                else {
                    inSymbol;
                    parseTypeRef(l2var5z@.typ, skipToSet + [SEMICOLON]);
                    if (l2var5z@.typ@.size <> (1)) then
                       error( errTypeMustNotBeFile );
                }
            };
        } else (*23167*) {
            with hashTravPtr@ do {
                l2var18z := f[9].i;
                curFrameRegTemplate := (curFrameRegTemplate + indexreg[1]);
                curProcNesting := (curProcNesting + (1));
                if (l2var1z.q = hashTravPtr) then {
                    l2var1z := f[8];
                } else {
                    l2var5z := l2var1z.q;
                    while (hashTravPtr <> l2var5z) do {
                        l2var6z.q := l2var5z;
                        l2var5z := l2var5z@.f[8].q;
                    };
                    l2var6z.q@.f[8] := hashTravPtr@.f[8];
                }
            };
            hashTravPtr@.f[8].s := NIL;
            l2var5z := hashTravPtr@.f[7].q;
            if (l2var5z <> NIL) then {
                while (l2var5z <> hashTravPtr) do {
                    addToHashTab(l2var5z);
                    l2var5z := l2var5z@.f[5].q;
                }
            };
            l2var5z := hashTravPtr;
            setup(l2var3z.s);
            inSymbol;
        }; (* 23224 *)
        checkSymAndRead( SEMICOLON );
        with l2var5z@ do if (curIdent = litForward) then {
            if (l2var7z) then
                error(83); (* errRepeatedPredefinition *)
            f[9].i := l2var18z;
            f[8] := l2var1z;
            l2var1z.q := l2var5z;
        } else (* 23237 *) if (curIdent = litExternal) or
            (curIdent = litFortran) then {
            if (curIdent = litExternal) then {
                curVal.i := (1000000000C);
            } else if (checkFortran) then {
                curVal.i := (440000000C);
                checkFortran := false;
            } else {
                curVal.i := (400000000C);
                (q) exit q; (* workaround *)
            };
            l2var5z@.f[11].m := l2var5z@.f[11].m + curVal.m;
        } else (* 23257 *) {
             repeat 
                 setup(l2var3z.s);
                 programme(l2var18z, l2var5z);
                 if not (SY IN [FUNCSY,PROCSY,BEGINSY]) then
                     errAndSkip( errBadSymbol, skipToSet );
             until SY IN [FUNCSY,PROCSY,BEGINSY];             
             rollup(l2var3z.s);
             exitScope(symHashTabBase);
             exitScope(typeHashTabBase);
             goto 23301;
        }; (* 23277 *)
        inSymbol;
        checkSymAndRead( SEMICOLON );
23301:  l2var6z := l2var5z@.f[7];
        if (l2var6z.q <> NIL) then {
            while (l2var6z.q <> l2var5z) do {
                l2var3z.s := NIL;
                P2672(l2var3z.q, l2var6z.q);
                l2var6z := l2var6z.s@.f[5];
            }
        }; (* 23314 *)
        curFrameRegTemplate := (curFrameRegTemplate - indexreg[1]);
        curProcNesting := (curProcNesting - (1));
    }; (* 23320 *)
    if (SY <> BEGINSY) and
        (not allowCompat or not (SY IN blockBegSys)) then 
        errAndSkip(84 (* errErrorInDeclarations *), skipToSet );        
    until SY in statBegSys;
    if (l2var1z.c <> chr(0C)) then {
        error(85); (* errNotFullyDefinedProcedures *)
        while (l2var1z.c <> chr(0C)) do {
            printTextWord( l2var1z.s@.f[0] );
            l2var1z := l2var1z.s@.f[8];
        };
        writeLN;
    };
    defineRoutine;
    while (numLabList <> l2var16z) do {
        if not (numLabList@.defined) then {
            write(' ', numLabList@.id.i:0, ':');
            l2var8z := false;
        };
        numLabList := numLabList@.next;
    };
    if not l2var8z then {
        printTextWord(l2arg2z@.id);
        error(90); (* errLblDefinitionInBlock *)
    };
    l2arg1z := l2var21z;
(* 23364 *)}; (* programme *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initTables;
var l2var1z, l2var2z: integer; l2var3z, l2var4z, l2var5z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initInsnTemplates;
var l3var1z: insn; l3var2z: operator;
{
    for l3var1z := ATX to JADDM do
        insnTemp[l3var1z] := ord(l3var1z) * 10000B;
    insnTemp[UTC] := 00500000B;
    l2var2z := 02200000B;
    for l3var1z := WTC to succ(VJM) do {
        insnTemp[l3var1z] := l2var2z;
        l2var2z := (l2var2z + 00100000B);
    };
    for l2var1z to 15 do 
        indexreg[l2var1z] := l2var1z * frameRegTemplate;
    int51z := insnTemp[VJM];
    for l3var2z := MUL to badop33 do {
        opFlags[l3var2z] := opf0;
        opToInsn[l3var2z] := (0);
        if (l3var2z IN [MUL, RDIVOP, PLUSOP, MINUSOP]) then {
            opToMode[l3var2z] := (3);
        } else if (l3var2z IN [IDIVOP, IMODOP]) then {
            opToMode[l3var2z] := (2);
        } else if (l3var2z IN [IMULOP, INTPLUS, INTMINUS, badop27]) then {
            opToMode[l3var2z] := (1);
        } else if (l3var2z IN [IDIVROP,badop30,badop31]) then {
            opToMode[l3var2z] := (4);
        } else
            opToMode[l3var2z] := (0);
    };
    opToInsn[MUL] :=    insnTemp[AMULX];
    opToInsn[RDIVOP] := insnTemp[ADIVX];
    opToInsn[IDIVOP] := (17); (* P/DI *)
    opToInsn[IMODOP] := (11); (* P/MD *)
    opToInsn[PLUSOP] := insnTemp[ADD];
    opToInsn[MINUSOP] := insnTemp[SUB];
    opToInsn[IMULOP] := insnTemp[AMULX];
    opToInsn[SETAND] := insnTemp[AAX];
    opToInsn[SETXOR] := insnTemp[AEX];
    opToInsn[SETOR] := insnTemp[AOX];
    opToInsn[INTPLUS] := insnTemp[ADD];
    opToInsn[INTMINUS] := insnTemp[SUB];
    opToInsn[IDIVROP] := (67); (* P/IS *)
    opToInsn[badop27] := (22); (* P/II unused, undefined *)
    opToInsn[badop30] := (23); (* P/RR *)
    opToInsn[badop31] := (24); (* P/RI *)
    opToInsn[MKRANGE] := (61); (* P/PI *)
    opToInsn[XORALLONES] := insnTemp[AAX];
    opFlags[AMPERS] := opf2;
    opFlags[IDIVOP] := opf4;
    opFlags[OROP] := opf3;
    opFlags[IMULOP] := opf6;
    opFlags[IMODOP] := opf5;
    opFlags[badop27] := opf1;
    opFlags[badop30] := opf1;
    opFlags[badop31] := opf1;
    opFlags[MKRANGE] := opf1;
    opFlags[IDIVROP] := opf1;
    opFlags[badop33] := opf7;
    opFlags[XORALLONES] := opf8;
    for l2var2z := 0 to 6 do {
        funcInsn[l2var2z] := (00500000B + l2var2z);
    }
(* 23516 *)}; (* initInsnTemplates *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regKeywords;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regResWord(l4arg1z: integer);
var kw: @kword; l4var2z: word;
{
 curVal.i := l4arg1z;
 curVal.m := curVal.m * hashMask.m;
 mapai(curVal.a, curVal.i);
 l4var2z.i := l4arg1z;
 new(kw);
 with kw@ do {
    w := l4var2z;
    sym := SY;
    op := charClass;
    next := kwordHashTabBase[curVal.i];
 };
 kwordHashTabBase[curVal.i] := kw;
 if (charClass = NOOP) then {
    SY := succ(SY);
 } else {
   charClass := succ(charClass);
 }
}; (* regResWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* regKeywords *)
 SY := MULOP;
 charClass := AMPERS;
 regResWord(415644C(*"     AND"*));
 regResWord(445166C(*"     DIV"*));
 regResWord(555744C(*"     MOD"*));
 SY := GTSY; (* reused as NILSY *)
 charClass := NOOP;
 regResWord(565154C(*"     NIL"*));
 SY := ADDOP;
 charClass := OROP;
 regResWord(5762C(*"      OR"*));
 SY := RELOP;
 charClass := INOP;
 regResWord(5156C(*"      IN"*));
 SY := NOTSY;
 charClass := NOOP;
 regResWord(565764C(*"     NOT"*));
 SY := LABELSY;
 charClass := NOOP;
 for l2var1z := 0 to 29 do
     regResWord(resWordNameBase[l2var1z]);
}; (* regKeywords *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initArrays;
var l3var1z, l3var2z: word;
{
 FcstCnt := (0);
 FcstCount := (0);
 for l2var1z := 3 to 6 do {
    l3var2z.i := (l2var1z - (2));
    for l2var2z to l3var2z.i do
        frameRestore[l2var1z][l2var2z].i := 0;
 };
 for l2var1z to 99 do
    helperMapBase[l2var1z] := (0);
}; (* initArrays *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initSets;
{
 skipToSet := blockBegSys + statBegSys - [CASESY];
 bigSkipSet := skipToSet + statEndSys;
}; (* initSets *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* initTables *)
 initArrays;
 initInsnTemplates;
 initSets;
 unpack(pasinfor.a3@, iso2text, '_052'); (* '*' *)
 rewrite(CHILD);
 for l2var2z to 10 do
    put(CHILD);
 for l2var1z := 0 to 127 do {
     symHashTabBase[l2var1z] := NIL;
     typeHashTabBase[l2var1z] := ;
     kwordHashTabBase[l2var1z] := ;
 };
 regKeywords;
 numLabList := NIL;
 totalErrors := (0);
 heapCallsCnt := (0);
 putLeft := true;
 bool102z := true;
 curFrameRegTemplate := frameRegTemplate;
 curProcNesting := (1);
}; (* initTables *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure finalize;
var l2var1z, l2var2z, l2var3z: integer;
    sizes: array[1..10] of word;
{
 sizes[1].i := (1C);
 sizes[2].c := chr(symTabPos - 00074000B - 1);
 sizes[5].c := chr(longSymCnt);
 sizes[6].c := chr(moduleOffset - 00040000B);
 sizes[8].c := chr(FcstCnt);
 sizes[3].i := (0C);
 sizes[4] := ;
 sizes[7] := ;
 sizes[9].c := chr(int92z);
 sizes[10].c := chr(int93z);
 curVal.i := (moduleOffset - 00040000B);
 symTab[74001B].m := [24,29] + curVal.m - intZero;
 reset(FCST);
 while not eof(FCST) do {
 write(CHILD, FCST@);
 get(FCST);
 };
 curVal.i := (symTabPos - 00070000B) * 100000000B;
 for l2var2z to longSymCnt do {
     l2var1z := longSymTabBase[l2var2z];
     symTab[l2var1z].m := (symTab[l2var1z].m + (curVal.m * [9:23]));
     curVal.i := (curVal.i + 100000000B);
};
symTabPos := (symTabPos - (1));
 for l2var2z := 00074000B to symTabPos do
    write(CHILD, symTab[l2var2z]);
 for l2var2z to longSymCnt do
     write(CHILD, longSymsBase[l2var2z]);
 if (allowCompat) then {
    write((lineCnt - 1):6, ' LINES STRUCTURE ');
    for l2var1z to 10 do
        write(ord(sizes[l2var1z].c):0, ' ');
    writeln;
 };
 entryPtTableBase[entryPtCnt].i := (0C);
 pasinfor.entryptr@ := entryPtTableBase;
 pasinfor.sizes := sizes;
}; (* finalize *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initOptions;
{
    pasinfor.startOffset := pasinfor.startOffset-16384;
    commentModeCH := ' ';
    lineNesting := 0;
    maxLineLen := 72;
    CH := ' ';
    linePos := 0;
    prevErrPos := 0;
    errsInLine := 0;
    lineCnt := 1;
    checkFortran := false;
    bool110z := false;
    int93z := 1;
    int92z := 1;
    moduleOffset := 16384;
    lineStartOffset := ;
    int94z := 1;
    bool47z := false;
    dataCheck := ;
    heapSize := 100;
    bool49z := true;
    atEOL := false;
    curVal.m := pasinfor.flags;
    besm(ASN64-39); besm(ASN64+45);
    optSflags := ;
    doPMD := not (42 in curVal.m);
    checkTypes := true;
    fixMult := true;
    fuzzReals := true;
    pseudoZ := ;
    checkBounds := not (44 in curVal.m);
    declExternal := false;
    errors := false;
    allowCompat := false;
    litExternal.i := 4570644562564154C;
    litForward.i := 46576267416244C;
    litFortran.i := 46576264624156C;
    fileBufSize := 1;
    charEncoding := 2;
    chain := NIL;
    litOct.i := 574364C;
    longSymCnt := 0;
    pasinfor.errors@ := true;
    extSymAdornment := 0;
    symTabCnt := 0;
}; (* initOptions *)
%
{ (* main *)
    if PASINFOR.listMode <> 0 then
        writeln(boilerplate);
    initOptions;
    curInsnTemplate.i := 0;
    initTables;
    programme(curInsnTemplate.i, hashTravPtr);
    if errors then {
9999:   writeln(' IN ', (lineCnt-1):0, ' LINES ',
            totalErrors:0, ' ERRORS');
    } else {
        finalize;
        PASINFOR.errors@ := false;
    }
}
.data
    frameRegTemplate := 04000000B;
    constRegTemplate := 40000000B;
    disNormTemplate :=  00370007B;
    blockBegSys := [LABELSY, CONSTSY, TYPESY, VARSY, FUNCSY, PROCSY, BEGINSY];
    statBegSys :=  [BEGINSY, IFSY, CASESY, REPEATSY, WHILESY, FORSY, WITHSY,
                    GOTOSY, SELECTSY];
    O77777 := (77777C);
    intZero := (0);
    glob138z := (63000000C);
    glob139z := (43000000C);
    halfWord := (77777777C);
    hashMask := 203407C;
    statEndSys := [SEMICOLON, ENDSY, ELSESY, UNTILSY];
    lvalOpSet := [op34, op35, op36, op37, op41, op42, op43];
    resWordNameBase :=
        5441424554C             (*"   LABEL"*),
        4357566364C             (*"   CONST"*),
        64716045C               (*"    TYPE"*),
        664162C                 (*"     VAR"*),
        4665564364515756C       (*"FUNCTION"*),
        6062574345446562C       (*"PROCEDUR"*),
        634564C                 (*"     SET"*),
        604143534544C           (*"  PACKED"*),
        4162624171C             (*"   ARRAY"*),
        624543576244C           (*"  RECORD"*),
        46515445C               (*"    FILE"*),
        4245475156C             (*"   BEGIN"*),
        5146C                   (*"      IF"*),
        43416345C               (*"    CASE"*),
        624560454164C           (*"  REPEAT"*),
        6750515445C             (*"   WHILE"*),
        465762C                 (*"     FOR"*),
        67516450C               (*"    WITH"*),
        47576457C               (*"    GOTO"*),
        455644C                 (*"     END"*),
        45546345C               (*"    ELSE"*),
        6556645154C             (*"   UNTIL"*),
        5746C                   (*"      OF"*),
        4457C                   (*"      DO"*),
        6457C                   (*"      TO"*),
        445767566457C           (*"  DOWNTO"*),
        64504556C               (*"    THEN"*),
        634554454364C           (*"  SELECT"*),
        60625747624155C         (*" PROGRAM"*),
        576450456263C           (*"  OTHERS"*);
%
    charSymTabBase := NOSY:128;
    chrClassTabBase := NOOP:128;
    charSymTabBase['0'] := INTCONST:10;
    chrClassTabBase['0'] := ALNUM:10;
    charSymTabBase['A'] := IDENT:26;
    chrClassTabBase['A'] := ALNUM:26;
    charSymTabBase['ะฎ'] := IDENT:31;
    chrClassTabBase['ะฎ'] := ALNUM:31;
    funcInsn[fnABSR] := 00070000B;
    funcInsn[fnTRUNC] := 04040011B;
    funcInsn[fnODD] := 04110010B;
    funcInsn[fnORD] := 04150011B;
    funcInsn[fnCHR] := 04110014B;
    funcInsn[fnSUCC] := 04130010B;
    funcInsn[fnPRED] := 04050010B;
    funcInsn[fnSQRR] := macro + mcSQRR;
    funcInsn[fnROUND] := macro + mcROUND;
    funcInsn[fnCARD] := macro + mcCARD;
    funcInsn[fnMINEL] := macro + mcMINEL;
    funcInsn[fnPTR] := 04110014B;
    funcInsn[fnABSI] := 00070000B;
    funcInsn[fnSQRI] := macro + mcSQRI;
    glob334z[5] := 25C, 26C;
    glob334z[3] := 23C, 24C;
    glob327z := 17C, 20C;
    glob332z := 21C, 22C;
    charSymTabBase[chr(27)] := CHARCONST;
    charSymTabBase[''''] := CHARCONST;
    charSymTabBase['_'] := REALCONST;
    charSymTabBase['<'] := LTSY;
    charSymTabBase['>'] := GTSY;
    chrClassTabBase['+'] := PLUSOP;
    chrClassTabBase['-'] := MINUSOP;
    chrClassTabBase['*'] := MUL;
    chrClassTabBase['/'] := RDIVOP;
    chrClassTabBase['='] := EQOP;
    chrClassTabBase['&'] := AMPERS;
    chrClassTabBase['รท'] := IDIVOP;
    chrClassTabBase['โจ'] := OROP;
    chrClassTabBase['>'] := GTOP;
    chrClassTabBase['<'] := LTOP;
    chrClassTabBase['#'] := NEOP;
    chrClassTabBase['='] := EQOP;
    chrClassTabBase['ร'] := MUL;
    chrClassTabBase['โค'] := LEOP;
    chrClassTabBase['โฅ'] := GEOP;
    charSymTabBase['โค'] := RELOP;
    charSymTabBase['โฅ'] := RELOP;
    charSymTabBase['+'] := ADDOP;
    charSymTabBase['-'] := ADDOP;
    charSymTabBase['โจ'] := ADDOP;
    charSymTabBase['*'] := MULOP;
    charSymTabBase['/'] := MULOP;
    charSymTabBase['&'] := MULOP;
    charSymTabBase['ร'] := MULOP;
    charSymTabBase[','] := COMMA;
    charSymTabBase['.'] := PERIOD;
    charSymTabBase[chr(22)] := ARROW;
    charSymTabBase['@'] := ARROW;
    charSymTabBase['^'] := ARROW;
    charSymTabBase['('] := LPAREN;
    charSymTabBase[')'] := RPAREN;
    charSymTabBase[';'] := SEMICOLON;
    charSymTabBase['['] := LBRACK;
    charSymTabBase[']'] := RBRACK;
    charSymTabBase['#'] := RELOP;
    charSymTabBase['='] := RELOP;
    charSymTabBase[':'] := COLON;
    charSymTabBase['รท'] := MULOP;
    charSymTabBase['~'] := NOTSY;
    helperNameBase :=
        6017210000000000C      (*"P/1     "*),
        6017220000000000C      (*"P/2     "*),
        6017230000000000C      (*"P/3     "*),
        6017240000000000C      (*"P/4     "*),
        6017250000000000C      (*"P/5     "*),
        6017260000000000C      (*"P/6     "*),
        6017434100000000C      (*"P/CA    "*),
        6017455700000000C      (*"P/EO    "*),
        6017636300000000C      (*"P/SS    "*),
(*10*)  6017455400000000C      (*"P/EL    "*),
        6017554400000000C      (*"P/MD    "*),
        6017555100000000C      (*"P/MI    "*),
        6017604100000000C      (*"P/PA    "*),
        6017655600000000C      (*"P/UN    "*),
        6017436000000000C      (*"P/CP    "*),
        6017414200000000C      (*"P/AB    "*),
        6017445100000000C      (*"P/DI    "*),
        6017624300000000C      (*"P/RC    "*),
        6017454100000000C      (*"P/EA    "*),
(*20*)  6017564100000000C      (*"P/NA    "*),
        6017424100000000C      (*"P/BA    "*),
        6017515100000000C      (*"P/II    "*),
        6017626200000000C      (*"P/RR    "*),
        6017625100000000C      (*"P/RI    "*),
        6017214400000000C      (*"P/1D    "*),
        6017474400000000C      (*"P/GD    "*),
        6017450000000000C      (*"P/E     "*),
        6017454600000000C      (*"P/EF    "*),
        6017604600000000C      (*"P/PF    "*),
(*30*)  6017474600000000C      (*"P/GF    "*),
        6017644600000000C      (*"P/TF    "*),
        6017624600000000C      (*"P/RF    "*),
        6017566700000000C      (*"P/NW    "*),
        6017446300000000C      (*"P/DS    "*),
        6017506400000000C      (*"P/HT    "*),
        6017675100000000C      (*"P/WI    "*),
        6017676200000000C      (*"P/WR    "*),
        6017674300000000C      (*"P/WC    "*),
        6017412600000000C      (*"P/A6    "*),
(*40*)  6017412700000000C      (*"P/A7    "*),
        6017677000000000C      (*"P/WX    "*),
        6017675700000000C      (*"P/WO    "*),
        6017436700000000C      (*"P/CW    "*),
        6017264100000000C      (*"P/6A    "*),
        6017274100000000C      (*"P/7A    "*),
        6017675400000000C      (*"P/WL    "*),
        6017624451000000C      (*"P/RDI   "*),
        6017624462000000C      (*"P/RDR   "*),
        6017624443000000C      (*"P/RDC   "*),
(*50*)  6017624126000000C      (*"P/RA6   "*),
        6017624127000000C      (*"P/RA7   "*),
        6017627000000000C      (*"P/RX    "*),
        6017625400000000C      (*"P/RL    "*),
        6017675754560000C      (*"P/WOLN  "*),
        6017625154560000C      (*"P/RILN  "*),
        6017626200000000C      (*"P/RR    "*),
        6017434500000000C      (*"P/CE    "*),
        6017646200000000C      (*"P/TR    "*),
        6017546600000000C      (*"P/LV    "*),
(*60*)  6017724155000000C      (*"P/ZAM   "*),
        6017605100000000C      (*"P/PI    "*),
        6017426000000000C      (*"P/BP    "*),
        6017422600000000C      (*"P/B6    "*),
        6017604200000000C      (*"P/PB    "*),
        6017422700000000C      (*"P/B7    "*),
        6017515600000000C      (*"P/IN    "*),
        6017516300000000C      (*"P/IS    "*),
        6017444100000000C      (*"P/DA    "*),
        6017435700000000C      (*"P/CO    "*),
(*70*)  6017516400000000C      (*"P/IT    "*),
        6017435300000000C      (*"P/CK    "*),
        6017534300000000C      (*"P/KC    "*),
        6017545647604162C      (*"P/LNGPAR"*),
        6017544441620000C      (*"P/LDAR  "*),
        6017544441625156C      (*"P/LDARIN"*),
        6017202043000000C      (*"P/00C   "*),
        6017636441620000C      (*"P/STAR  "*),
        6017605544634564C      (*"P/PMDSET"*),
        6017435100000000C      (*"P/CI    "*),
(*80*)  6041514200000000C      (*"PAIB    "*),
        6017674100000000C      (*"P/WA    "*),
        6361626412000000C      (*"SQRT*   "*),
        6351561200000000C      (*"SIN*    "*),
        4357631200000000C      (*"COS*    "*),
        4162436441561200C      (*"ARCTAN* "*),
        4162436351561200C      (*"ARCSIN* "*),
        5456120000000000C      (*"LN*     "*),
        4570601200000000C      (*"EXP*    "*),
        6017456100000000C      (*"P/EQ    "*),
(*90*)  6017624100000000C      (*"P/RA    "*),
        6017474500000000C      (*"P/GE    "*),
        6017554600000000C      (*"P/MF    "*),
        6017465500000000C      (*"P/FM    "*),
        6017565600000000C      (*"P/NN    "*),
        6017634300000000C      (*"P/SC    "*),
        6017444400000000C      (*"P/DD    "*),
        6017624500000000C      (*"P/RE    "*);
    systemProcNameBase :=
        606564C                (*"     PUT"*),
        474564C                (*"     GET"*),
        62456762516445C        (*" REWRITE"*),
        6245634564C            (*"   RESET"*),
        564567C                (*"     NEW"*),
        44516360576345C        (*" DISPOSE"*),
        50415464C              (*"    HALT"*),
        63645760C              (*"    STOP"*),
        6345646560C            (*"   SETUP"*),
        625754546560C          (*"  ROLLUP"*),
        6762516445C            (*"   WRITE"*),
        67625164455456C        (*" WRITELN"*),
        62454144C              (*"    READ"*),
        624541445456C          (*"  READLN"*),
        45705164C              (*"    EXIT"*),
        4445426547C            (*"   DEBUG"*),
        42456355C              (*"    BESM"*),
        5541605141C            (*"   MAPIA"*),
        5541604151C            (*"   MAPAI"*),
        604353C                (*"     PCK"*),
        6556604353C            (*"   UNPCK"*),
        60414353C              (*"    PACK"*),
        655660414353C          (*"  UNPACK"*),
        5760455644C            (*"   OPEND"*),
        44455444C              (*"    DELD"*),
        56456744C              (*"    NEWD"*),
        60656444C              (*"    PUTD"*),
        47456444C              (*"    GETD"*),
        55574444C              (*"    MODD"*),
        46515644C              (*"    FIND"*);
end
*to perso:670000
*end file
``````
ะะะะะะฆ
