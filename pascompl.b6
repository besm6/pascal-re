user 419900 ะทั5^
dis 67(1234-wr)^
EEB1A3
*name
*call ficmemory
*pascal
(*=p-,t-,s8,u-,y+,l0*)
program pascompl(output, child, pasinput, pasinfor);
%
label 9999;
%
const
    boilerplate = ' PASCAL COMPILER 15.0 (15.02.82)';
%
    ATX  = 0;  STX = 1;  OP002 = 2;  XTS   = 3;  ADD = 4;  SUB   = 5;
    RSUB = 6;  AMX = 7;  XTA   = 8;  AAX   = 9;  AEX = 10; ARX   = 11;
    AVX  = 12; AOX = 13; ADIVX = 14; AMULX = 15; APX = 16; AUX   = 17;
    ACX  = 18; ANX = 19; EADD  = 20; ESUB  = 21; ASX = 22; XTR   = 23;
    RTE  = 24; YTA = 25; EADDI = 28; ESUBI = 29; ASN = 30; NTR   = 31;
    ATI  = 32; STI = 33; ITA   = 34; ITS   = 35; MTJ = 36; JADDM = 37;
    UTC  = 38; WTC = 39; VTM   = 40; UTM   = 41; UZA = 42; U1A   = 43;
    UJ   = 44; VJM = 45;
%
    fnSQRT = 0;   fnSIN = 1;   fnCOS = 2;   fnATAN = 3;   fnASIN = 4;
    fnLN = 5;     fnEXP = 6;   fnABSR = 7;  fnTRUNC = 8;  fnODD = 9;
    fnORD = 10;   fnCHR = 11;  fnSUCC = 12; fnPRED = 13;  fnEOF = 14;
    fnREF = 15;   fnEOLN = 16; fnSQRR = 17; fnROUND = 18; fnCARD = 19;
    fnMINEL = 20; fnPTR = 21;  fnABSI = 22; fnSQRI = 23;
%
    S4 = 1;
    S5 = 2;
    S6 = 3;
    NoPtrCheck = 4;
%
    DebugCode  = 45;
    DebugPrint = 46;
    DebugEntry = 47;
%
    ASN64 = 360100B;
%
type
    symbol = (
(*0B*)  IDENT,      INTCONST,   REALCONST,  CHARCONST,
        LTSY,       GTSY,       NOTSY,      LPAREN,
(*10B*) LBRACK,     MULOP,      ADDOP,      RELOP,
        RPAREN,     RBRACK,     COMMA,      SEMICOLON,
(*20B*) PERIOD,     ARROW,      COLON,      BECOMES,
        LABELSY,    CONSTSY,    TYPESY,     VARSY,
(*30B*) FUNCSY,     PROCSY,     SETSY,      PACKEDSY,
        ARRAYSY,    RECORDSY,   FILESY,     BEGINSY,
(*40B*) IFSY,       CASESY,     REPEATSY,   WHILESY,
        FORSY,      WITHSY,     GOTOSY,     ENDSY,
(*50B*) ELSESY,     UNTILSY,    OFSY,       DOSY,
        TOSY,       DOWNTOSY,   THENSY,     SELECTSY,
(*60B*) PROGRAMSY,  OTHERSY,    NOSY );
%
setofsys = set of ident .. selectsy;
%
operator = (
    MUL,        RDIVOP,     AMPERS,     IDIVOP,     IMODOP,
    PLUSOP,     MINUSOP,    OROP,       NEOP,       EQOP,
    LTOP,       GEOP,       GTOP,       LEOP,       INOP,
    IMULOP,     IDIVROP,    SETAND,     SETXOR,     SETOR,
    XORALLONES, FIXEDPLUS,  FIXEDMINUS, badop27,    badop30,
    badop31,    badop32,    badop33,    op34,       op35,
    op36,       op37,       op40,       op41,       op42,
    op43,       op44,       ALNUM,      op46,       op47,
    op50,       op51,       NOTOP,      INEGOP,     RNEGOP,
    op55,       NOOP
);
%
dummy = (ii, rr, bb, aa, pp, cc, ss, mm, yy, oo, qq);
%
word = record case dummy of
    ii: (i: integer);
    rr: (r: real);
    bb: (b: boolean);
    aa: (a: alfa);
    pp: (p: @word);
    ss: (s: @struc);
    cc: (c: char);
    oo: (o: operator);
    yy: (y: symbol);
    qq: (q: @bigstruc);
    mm: (m: set of 0..47)
    end;
%
struc     = record f:array[0..10] of word end;
%
bigstruc  = record f:array[0..100] of word end;
%
charmap   = packed array ['_000'..'_176'] of char;
%
fourwords = array[0..3] of word;
%
var (* total size 4791 words *)
%
(*40*)      octalMode: char;
(*41-46*)   bigSkipSet, statEndSys, blockBegSys, statBegSys,
            skipToSet, lvalOpSet: setofsys;
(*47-49*)   bool47z, bool48z, bool49z: boolean;
(*50*)      inStringLit: boolean;
(*51*)      glob51z: word;
(*52*)      jumpTarget: word;
(*53*)      glob53z: word;
(*54*)      charClass: operator;
(*55-56*)   SY, glob56z: symbol;
(*57*)      glob57z: word;
(*58*)      FcstCnt: integer;
(*59*)      symTabPos: integer;
(*60*)      entryPtCnt: integer;
(*61*)      fileBufSize: integer;
(*62-63*)   glob62z, glob63z: @struc;
(*64*)      curInsnTemplate: word;
(*65*)      maxLineLen: integer;
(*66*)      linePos: integer;
(*67*)      prevErrPos: integer;
(*68*)      errsInLine: integer;
(*69*)      moduleOffset: integer;
(*70*)      lineStartOffset: integer;
(*71*)      curFrameRegTemplate: integer;
(*72*)      curProcNesting: integer;
(*73*)      totalErrors: integer;
(*74*)      lineCnt: integer;
(*75*)      bucket: integer;
(*76*)      glob76z: integer;
(*77*)      heapCallsCnt: integer;
(*78*)      heapSize: integer;
(*79*)      arithMode: integer;
(*80*)      stmtName: alfa;
(*81*)      keywordHashPtr: @struc;
(*82*)      curVarKind: word;
(*83*)      curExternFile: word;
(*84*)      commentModeCH: char;
(*85*)      glob85z: word;
(*86*)      CH: char;
(*87-88*)   glob87z, glob88z: word;
(*89*)      lineNesting: integer;
(*90*)      FcstCountTo500: integer;
(*91*)      objBufIdx: integer;
(*92-94*)   glob92z, glob93z, glob94z: integer;
(*95*)      glob95z: word;
(*96*)      charEncoding: integer;
(*97*)      glob97z: integer;
(*98*)      atEOL: boolean;
(*99*)      checkTypes: boolean;
(*100-102*) bool100z, bool101z, bool102z: boolean;
(*103*)     errors: boolean;
(*104*)     declExternal: boolean;
(*105*)     bool105z: boolean;
(*106*)     doPMD: boolean;
(*107*)     checkBounds: boolean;
(*108*)     fuzzReals: boolean;
(*109*)     fixMult: boolean;
(*110*)     glob110z: boolean;
(*111*)     pseudoZ: boolean;
(*112*)     allowCompat: boolean;
(*113*)     checkFortran: boolean;
(*114*)     outputFile: @word;
(*115*)     inputFile: @word;
(*116*)     programObj: word;
(*117*)     hashTravPtr: @struc;
(*118*)     uProcPtr: @word;
(*119*)     externFileList: @word;
(*120-121*) glob120z, glob121z: @struc;
(*122*)     pointerType: @struc;
(*123*)     setType: @struc;
(*124*)     booleanType: @struc;
(*125*)     textType: @struc;
(*126*)     integerType: @struc;
(*127*)     realType: @struc;
(*128*)     charType: @struc;
(*129*)     alfaType: @struc;
(*130*)     arg1Type: @struc;
(*131*)     arg2Type: @struc;
(*132-133*) glob132z, glob133z: @word;
(*134*)     curToken: word;
(*135*)     curVal: word;
(*136*)     O77777: word;
(*137*)     intZero: set of 0..47;
(*138-139*) glob138z, glob139z: word;
(*140*)     halfWord: word;
(*141*)     isLeftInsn: word;
(*142*)     hashMask: word;
(*143-146*) curIdent, glob144z, glob145z, glob146z: word;
(*147-148*) glob147z, glob148z: word;
(*149*)     optSflags: word;
(*150*)     litOct: word;
(*151*)     litExternal: word;
(*152*)     litForward: word;
(*153*)     litFortran: word;
(*154*)     uVarPtr: @word;
(*155*)     curExpr: @struc;
(*156*)     insnList: @struc;
(*157-158*) glob157z, glob158z: word;
(*159*)     someTypeArrayBase: integer;
(*160*)     extSymAdornment: integer;
(*161-165*) dummy5: array [2..6] of @struc;
(*166*)     symTabCnt: integer;
(*167-246*) symtabarray: array [1..80] of word;
(*247-326*) symtbidx: array [1..80] of integer;
(*327-339*) dummy6: array [327..339] of word;
(*340-369*) entryPtTableBase: array [0..29] of word;
(*370-397*) frameRestore: array [0..6] of fourwords;
(*398-412*) int398ar: array [0..14] of integer;
            glob413z: integer;
(*414-450*) int414ar: array [0..36] of integer;
(*451-487*) glob451z: array [0..36] of integer;
(*488-524*) glob488z: array [0..36] of integer;
(*525-548*) funcInsn: array [0..23] of integer;
(*549-594*) insnTemp: array [0..45] of integer;
(*595*)     glob595z: word;
(*596*)     frameRegTemplate: integer;
(*597*)     constRegTemplate: word;
(*598*)     disNormTemplate: integer;
(*599-728*) lineBufBase: array [1..130] of char;
(*729*)     errMapBase: array [0..9] of integer;
(*739*)     chrClassTabBase: array ['_000'..'_177'] of operator;
(*867*)     kwordHashTabBase: array [0..127] of @struc;
(*995*)     charSymTabBase: array ['_000'..'_177'] of symbol;
(*1123*)    symHashTabBase: array [0..127] of @struc;
(*1251*)    typeHashTabBase: array [0..127] of @struc;
(*1378*)    helperMapBase: array [1..99] of integer;
(*1477*)    helperNameBase: array [1..99] of word;
(*1577-
  2409*)    symTab: array [74000B..75500B] of word;
(*2410*)    systemProcNameBase: array [1..30] of word;
(*2440*)    resWordNameBase: array [1..30] of word;
(*2470*)    longSymCnt: integer;
(*2471*)    longSymTabBase: array [1..90] of integer;
(*2560*)    longSymsBase: array [1..90] of word;
(*2651*)    constValsTabBase: array [1..500] of word;
(*3151*)    constNumTabBase: array [1..500] of integer;
(*3651*)    objBufBase: array [1..1024] of word;
(*4675*)    psInfrCopy: array ['_052'..'_177'] of char;
(*4761*)    fcst: file of word; (* last *)
            pasinput: text;
            child: file of word;
            pasinfor: record

(*0*)    listMode: integer;
(*1*)    errors: @boolean;
(*2*)    dummy2: integer;
(*3*)    startOffset: integer;
(*4-6*)  a0,a1,a4: @charmap;
(*7-18*) dummy3: array[7..18] of integer;
end;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(l2arg1z, l2arg2z: word);
var
    l2var1z, l2var2z, l2var3z, l2var4z, l2var5z,
    l2var6z, l2var7z, l2var8z, l2var9z, l2var10z,
    l2var11z, l2var12z, l2var13z, l2var14z, l2var15z,
    l2var16z, l2var17z, l2var18z, l2var19z: word;
%
    l2var20z, l2var21z, l2var22z: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno:integer);
type
    errtxt = packed array [0..100] of 0..63;
var
    errptr: @errtxt;
    errtext: array [0..100] of 0..63;
    i: integer;
    c: char;
%
    function pasmitxt(errno: integer): @errtxt;
        fortran;
%
    function pasisoxt(txtchar: 0..63): char;
        fortran;
%
{ (* PrintErrMsg *)
    write(' ');
    if errno >= 200 then
        write('system=', errno:0)
    else {
        if (errno > 88) then
            printErrMsg(86)
        else if errno in [16..18, 20] then {
            if errno = 20 then
                errno := ord(sy = ident)*2 + 1
            else
                write(curToken.i:0,' ');
        } else; (*workaround*)
%
        errptr := pasmitxt(errno);
        unpack(errptr@, errtext, 0);
(loop)  for i:=0 to 100 do {
            c := pasisoxt(errtext[i]);
            if c = '*' then
                exit loop;
            write(c);
        };
        write(' ');
        if errno in [17, 22] then
            if errno = 17 then
                write(glob97z:0)
            else
                write(stmtName);
    };
    if errno <> 86 then
        writeln;
}; (* PrintErrMsg *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val: word);
%
    procedure PASTPR(val: word);
        external;
%
{ (* printTextWord *)
    write(' ');
    PASTPR(val)
}; (* printTextWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              assignType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignType(var res:struc);
var l3var1z:@struc;
{
if someTypeArrayBase >= glob76z then
	res.f[0].s := dummy5[glob76z]
else {
new(l3var1z=7); (* XTA =7; ATI 14 instead of 14, VTM, 7 *)
new(res.f[0].p=8);
with l3var1z@ do {
f[0].i := 1;
f[4].i := 0;
f[1].i := 12;
f[2].c := chr(2);
f[3].s := integerType;
f[5].i := 1;
f[6].i := glob76z;
};
with res.f[0].s@ do {
f[0].i := (glob76z + 5) div 6;
if f[0].i = 1 then
	f[1].i := glob76z * 8
else
	f[1].i := 0;
f[2].c := chr(5);
f[3].s := charType;
f[4].s := l3var1z;
f[5].c := chr(1);
f[6].i := 6;
f[7].i := 8;
}
}
}; (* assignType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(l3arg1z:@struc);
{
curVal.m := l3arg1z@.f[0].m * hashMask.m;
mapai(curval.a, curval.i);
l3arg1z@.f[2].s :=symHashTabBase[curval.i];
symHashTabBase[curval.i] := l3arg1z;
}; (* addToHashTab *)
procedure error(errno: integer); forward;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(l3arg1z:set of 0..47);
{
objBufBase[objBufIdx].m := l3arg1z;
moduleOffset := moduleOffset + 1;
if objBufIdx = 1024 then {
	error(49);
	objBufIdx := 1
} else objBufIdx := objBufIdx + 1;
}; (* storeObjWord *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(l3arg1z: integer);
var l3var1z, l3var2z, l3var3z, l3var4z: word;
l3var5z: integer;
{
l3var1z.i := l3arg1z;
l3var2z.m := l3var1z.m * [0,1,3,24..32];
if l3var2z.i = insnTemp[VJM] then {
   if glob95z = l3var2z then exit;
   if bool101z and (glob95z.i = 1) then {
      l3var5z := objBufIdx - 1;
      if objBufBase[l3var5z].m * [0..8] = [0,1,3..5,8] then {
         glob95z := l3var2z;
         l3var3z.m := l3var1z.m * [33..47];
         besm(360050B);
         l3var3z:=;
         l3var4z.m := objBufBase[l3var5z].m * [9..23];
         besm(360130B);
         l3var4z :=;
         objBufBase[l3var5z].m := [0,1,3,4,6,28,29] +
         l3var3z.m + l3var4z.m;
         exit;
      }
   }
};
glob95z := l3var2z;
if (bool101z) then {
    isLeftInsn.m := l3var1z.m * halfWord.m;
    besm(360050B);
    isLeftInsn :=;
    bool101z := false
} else {
    bool101z := true;
    storeObjWord(isLeftInsn.m + (l3var1z.m * halfWord.m))
}
}; (* form1Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: integer);
{
    form1Insn( i1 );
    form1Insn( i2 );
}; (* form2Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: integer);
{
    form2Insn(i1, i2);
    form1Insn(i3);
}; (* form3Insn *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
{
    if arithMode <> 1 then {
        form1Insn(disNormTemplate);
        arithMode := 1;
    }
}; (* disableNorm *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus:integer;
{
   if bool101z then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
}; (* getObjBufIdxPlus *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJumpOnCond(var l3arg1z:integer);
var l3var1z:integer; l3var2z: boolean;
{
 if glob95z.i <> insnTemplateBase[VJM] then {
 l3var1z := getObjBufIdxPlus;
 l3var2z := bool101z;
 form1Insn(glob51z.i + l3arg1z);
 if bool101z = l3var2z then
     l3var1z := l3var1z - 1;
 l3arg1z := l3var1z;
 }
}; (* formJumpOnCond *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formLabel;
{
 if not bool101z then
    form1Insn( insnTemplateBase[WTC] );
 glob95z.i := 0;
}; (* formLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formInsnAndLabel(l3arg1z:integer);
{
 form1Insn( l3arg1z);
 formLabel;
 glob95z.i := 1;
}; (* formInsnAndLabel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(l3arg1z: set of 0..47);
{
 symTab[symTabPos].m := l3arg1z;
 if symTabPos = 75500B then {
    error( 50 );
    symTabPos := 74000B;
 } else
    symTabPos := symTabPos + 1;
}; (* putToSymTab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z:word):integer;
var l3var1z:word; l3var2z:integer;
{
 allocExtSymbol := symTabPos;
 if (curVal.m * halfWord.m <> []) then {
 for l3var2z to longSymCnt do
   if (curVal = longSymsBase[l3var2z]) then {
     allocExtSymbol := longSymTabBase[l3var2z];
     exit
   };
 longSymCnt := longSymCnt + 1;
 if (longSymCnt >= 90) then {
     error( 51 );
     longSymCnt := 1;
 };
 longSymTabBase[longSymCnt] := symTabPos;
 longSymsBase[longSymCnt] := curVal;
 l3arg1z.m := l3arg1z.m + [25];
 } else
     l3arg1z.m := l3arg1z.m + curVal.m;
 putToSymTab( l3arg1z.m );
}; (* allocExtSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z:integer):integer;
{
 if (helperMapBase[l3arg1z] = 0) then {
     curVal := helperNameBase[l3arg1z];
     helperMapBase[l3arg1z] := allocExtSymbol( glob139z );
 };
 getHelperProc := helperMapBase[l3arg1z] + 67100000B;
}; (*getHelperProc *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
{
write(FCST, curVal);
FcstCnt := FcstCnt + 1;
}; (* toFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addSomethingToFCST:integer;
var l3var1z,l3var2z, l3var3z:integer;
{
 l3var1z := 1;
 if (FcstCountTo500 = 0) then {
     addSomethingToFCST := FcstCnt;
     FcstCountTo500 := 1;
     constValsTabBase[1] := curVal;
     constNumTabBase[1] := FcstCnt;
     toFCST;
 } else {
     l3var2z := FcstCountTo500;
     repeat
       l3var3z := (l3var1z + l3var2z) div 2;
       if (curVal = constValsTabBase[l3var3z]) then {
           addSomethingToFCST := constNumTabBase[l3var3z];
           exit
       };
       if curval.a < constValsTabBase[l3var3z].a then
           l3var2z := l3var3z - 1
       else
           l3var1z := l3var3z + 1
     until l3var2z < l3var1z;
     addSomethingToFCST := FcstCnt;
     if FcstCountTo500 <> 500 then {
         if curval.a < constValsTabBase[l3var3z].a then
             l3var2z := l3var3z
         else
             l3var2z := l3var3z + 1;
         for l3var3z := FcstCountTo500 downto l3var2z do {
             l3var1z := l3var3z + 1;
             constValsTabBase[l3var1z] := constValsTabBase[l3var3z];
             constNumTabBase[l3var1z] := constNumTabBase[l3var3z];
         };
         FcstCountTo500 := FcstCountTo500 + 1;
         constValsTabBase[l3var2z] := curVal;
         constNumTabBase[l3var2z] := FcstCnt;
     };
     toFCST;
 }
}; (* addSomethingToFCST *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtabForAbsolute(l3arg1z:set of 0..47):integer;
var l3var1z, l3var2z,l3var3z:integer;l3var4z:word;
{
    l3var1z := 1;
    l3var4z.m := l3arg1z;
    if symTabCnt = 0 then {
        allocSymtabForAbsolute := symTabPos;
        symTabCnt := 1;
        symTabArray[1].m := l3arg1z;
        symtbidx[1] := symTabPos;
    } else {
        l3var2z := symTabCnt;
        repeat
            l3var3z := (l3var1z + l3var2z) div 2;
            if (l3var4z = symTabArray[l3var3z]) then {
                allocSymtabForAbsolute := symtbidx[l3var3z];
                exit
            };
            if  l3var4z.a < symTabArray[l3var3z].a then
                 l3var2z := l3var3z - 1
            else
                 l3var1z := l3var3z + 1;
        until l3var2z < l3var1z;
        allocSymtabForAbsolute := symTabPos;
        if symTabCnt <> 80 then {
           if l3var4z.a < symTabArray[l3var3z].a then
              l3var2z := l3var3z
           else
              l3var2z := l3var3z + 1;
           for l3var3z := symTabCnt downto l3var2z do {
              l3var1z := l3var3z + 1;
              symTabArray[l3var1z] := symTabArray[l3var3z];
              symtbidx[l3var1z] := symtbidx[l3var3z];
           };
           symTabCnt := symTabCnt + 1;
           symTabArray[l3var2z] := l3var4z;
           symtbidx[l3var2z] := symTabPos;
        }
    };
    putToSymTab(l3var4z.m);
}; (* allocSymtabForAbsolute *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset:integer;
var l3var1z:word;
{
getFCSToffset := addSomethingToFCST;
l3var1z :=;
if (l3var1z.i < 2048) then { }
else if (l3var1z.i >= 4096) then
    error(204)
else {
    getFCSToffset := allocSymtabForAbsolute(l3var1z.m + [24]) - 28672;
    exit
}
}; (* getFCSToffset *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(l3arg1z:word):integer;
{
 curVal := l3arg1z;
 curVal.m := curVal.m * [7..47];
 nrOfBits := 48-minel(curval.m);
}; (* nrOfBits *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePacked(l3arg1z: @struc; l3arg2z, l3arg3z: word);
var l3var1z:@struc;dummyloc:word;
{
 new(l3var1z=7);
 with l3var1z@ do {
 f[0].i := 1;
 f[1].i := 48;
 f[3] := l3arg1z@.f[0];
 f[4].i := 0;
 f[2].c := chr(2);
 curVal := l3arg2z;
 curVal.m := curVal.m + intZero;
 f[5] := curVal;
 curVal := l3arg3z;
 curVal.m := curVal.m + intZero;
 f[6] := curVal;
 if (f[5].i >= 0) then
    f[1].i := nrOfBits( curVal );
 l3arg1z@.f[0].s := l3var1z
 }
}; (* definePacked *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(l3arg1z:integer):integer;
{
 curVal.i := l3arg1z;
 curVal.m := curVal.m * [0,1,3,33..47];
 if (16384 >= curVal.i) then
     getValueOrAllocSymtab := curVal.i
 else
     getValueOrAllocSymtab :=
     allocSymtabForAbsolute((curVal.m + [24]) * halfWord.m);
}; (* getValueOrAllocSymtab *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(l3arg1z, l3arg2z: integer);
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z:word;
l3var5z:integer; l3var6z: word;
{
if l3arg1z = 0 then {
    formLabel;
    curVal.i := moduleOffset;
1:  l3var1z.m := curval.m * [33..47];
    curVal := curVal;
    besm(360050B);
    l3var3z:=;
    while l3arg2z <> 0 do {
        if 4096 < l3arg2z then {
            l3var4z.b := true;
            l3arg2z := l3arg2z - 4096;
        } else l3var4z.b := false;
        l3var2z := objBufBase[l3arg2z];
        if l3var4z.b then {
            curVal.m := l3var2z.m * [9..23];
            besm(360130B);
            curVal :=;
            curVal.m := curVal.m + intZero;
            l3var2z.m := l3var2z.m * [0..8,24..47] + l3var3z.m
        } else {
            curVal.m := intZero + l3var2z.m * [33..47];
            l3var2z.m := l3var2z.m * [0..32] + l3var1z.m;
        };
        objBufBase[l3arg2z] := l3var2z;
        l3arg2z := curVal.i;
    };
    exit;
} else if l3arg1z = 2 then {
    form1Insn(72400000B + curVal.i);
    if curVal.i = 30721 then
        form1Insn(72500000B + FcstCnt);
    form3Insn(139278, insnTemp[ASN] + l3arg2z, 34150001B);
    form1Insn(34000001B);
    exit;
} else if (l3arg1z = 1) or (l3arg1z < -2) then {
    l3arg2z := l3arg2z - curVal.i;
    l3var6z.i := getFCSToffset;
    if l3arg1z = 1 then
        l3var5z := getHelperProc(68) + (-64200000B)
    else
        l3var5z := -l3arg1z;
    curVal.i := l3arg2z;
    l3arg2z := getFCSToffset;
    form3Insn(74000001B, 40050000B + l3var6z.i, l3var5z);
    form3Insn( 40060000B + l3arg2z, l3var5z, 74100001B);
    exit;
} else if l3arg1z = -1 then {
    form1Insn(72400000B + lineCnt);
    formInsnAndLabel(getHelperProc(l3arg2z));
    exit;
};
curVal.i := l3arg1z;
goto 1;
}; (* P0715 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var dummy:array[1..14] of integer;
    l3var15z, l3var16z, l3var17z, l3var18z,
    l3var19z, l3var20z:integer;
procedure OBPROG(var start, fin: word); external;
{
l3var18z := pasinfor.listMode;
if (l3var18z <> 0) or (errsInLine <> 0) then
{
    write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
          lineCnt:5, lineNesting:3, commentModeCH);
    l3var19z := 13;
    if (S4 in optSflags.m)
       and (maxLineLen = 72)
       and (linePos >= 80) then {
       for l3var15z := 73 to 80 do write(lineBufBase[l3var15z]);
       write(' ');
       linePos := 73;
       l3var19z := 22;
    }; (* 1106 *)
    repeat linePos := linePos-1
    until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
    for l3var15z to linePos do {
        output@ := lineBufBase[l3var15z];
        put(output);
    };
    writeln;
    if errsInLine <> 0 then {
        write('*****':l3var19z, ' ':errMapBase[0], '0');
        l3var20z := errsInLine - 1;
        for l3var15z to l3var20z do {
            l3var16z := errMapBase[l3var15z];
            l3var17z := errMapBase[l3var15z-1];
            if l3var16z <> l3var17z then {
                if l3var17z + 1 <> l3var16z then
                    write(' ':(l3var16z-l3var17z-1));
                write(chr(l3var15z + 48));
            }
        };
        writeln;
        errsInLine := 0;
        prevErrPos := 0;
    }
}; (* 1160 *)
if (l3var18z = 2) and (moduleOffset <> lineStartOffset) then {
    OBPROG(objBufBase[objBufIdx - moduleOffset + lineStartOffset],
           objBufBase[objBufIdx-1]);
}; (* 1174 *)
lineStartOffset := moduleOffset;
linePos := 0;
lineCnt := lineCnt + 1;
if eof (pasinput) then {
error(52);
goto 9999;
}
}; (* endOfLine *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(sym:symbol);
{
if linePos <> prevErrPos then
    error(ord(sym) + 88);
}; (* requiredSymErr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
{
while linePos < 81 do {
    linePos := linePos + 1;
    lineBufBase[linePos] := PASINPUT@;
    if linePos <> 81 then get(PASINPUT);
 };
 endOfLine
}; (* readToPos80 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol;
label 1473, 1, 2, 2175, 2233, 2320, 2334;
var l3var1z:array[0..130] of char;
l3var132z,l3var133z:integer;l3var134z:boolean;
l3var135z:@struc;
l3var136z, l3var137z:real;
l3var138z: char;
numstr:array [1..16]of word;
l3vars2:array [155..159]of word;
l3var160z,l3var161z:integer;
l3var162z:word;
chord:integer; l3var164z: integer;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
{
  repeat
    atEOL := eoln(PASINPUT);
    CH := PASINPUT@;
    get(PASINPUT);
    linePos := linePos + 1;
    lineBufBase[linePos] := CH;
  until (maxLineLen >= linePos) or atEOL;
}; (* nextCH *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment; label 1; (*workaround*)
var l4var1z, l4var2z: boolean; l4var3z: char;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var l5arg1z:integer; l5arg2z: integer);
{
    nextCH;
    l5arg1z := 0;
    while ('9' >= CH) and (CH >= '0') do {
        l5arg1z := 10 * l5arg1z + ord(CH) - ord('0');
        nextCH;
        l4var1z := false;
    };
    if l5arg2z < l5arg1z then l4var1z := true;
}; (* readOptVal *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var l5arg1z:boolean);
{
    nextCH;
    if (CH = '-') or (CH = '+') then {
        l5arg1z := CH = '+';
        l4var1z := false;
    };
    nextCH
}; (* readOptFlag *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* parseComment *)
    nextCH;
    if CH = '=' then {
        repeat nextCH;
        l4var1z := true;
        case CH of
        'D': {
             readOptVal(curVal.i, 15);
             optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
             };
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': {
             readOptFlag(l4var2z);
             if l4var2z then maxLineLen := 72 else maxLineLen := 120;
             };
        'S': {
             readOptVal(curVal.i, 9);
             if curVal.i = 3 then lineCnt := 1
             else if curVal.i in [4..9] then
                 optSflags.m := optSflags.m + [curVal.i-3]
             else {
                 extSymAdornment := curVal.i;
                 goto 1
             }; 1:; };
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        };
        if l4var1z then error(54);
        until CH <> ',';
    }; (* 1446 *)
    repeat while CH <> '*' do {
        l4var3z := commentModeCH;
        commentModeCH := '*';
        if atEOL then endOfLine;
        nextCH;
        commentModeCH := l4var3z;
    }; nextCH until CH = ')';
    nextCH;
}; (* parseComment *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (again) { (* inSymbol *)
    if inStringLit then {
        error(52);
        readToPos80;
        goto 9999;
    };
    1473: while (CH = ' ') and not atEOL do nextCH;
    if '_200' < CH then {
        lineBufBase[linePos] := ' ';
        chord := ord(CH);
        for l2var22z := 130 to chord do {
            linePos := linePos + 1;
            lineBufBase[linePos] := ' ';
        };
        nextCH;
        goto 1473;
    };
    if atEOL then {
        endOfLine;
        nextCH;
        if CH = '%' then while not atEOL do nextCH;
        goto 1473;
    };
    hashTravPtr := NIL;
    SY := charSymTabBase[CH];
    charClass := chrClassTabBase[CH];
    (lexer) if SY <> NOSY then {
    case SY of
        IDENT: { 1:
            curToken.m := [];
            l3var132z := 1;
            repeat
                curVal.c := psInfrCopy[CH];
                nextCH;
                if 8 >= l3var132z then {
                    l3var132z := l3var132z + 1;
                    curToken := curToken;
                    besm(360072B);
                    curToken:=;
                    curToken.m := curToken.m + curVal.m;
                };
            until chrClassTabBase[CH] <> ALNUM;
            curVal.m := curToken.m * hashMask.m;
            mapAI(curVal.a, bucket);
            curIdent := curToken;
            keywordHashPtr := kwordHashTabBase[bucket];
            while keywordHashPtr <> NIL do {
                if keywordHashPtr@.f[0] = curToken then {
                    SY := keywordHashPtr@.f[1].y;
                    charClass := keywordHashPtr@.f[2].o;
                    exit lexer;
                };
                keywordHashPtr := keywordHashPtr@.f[3].s;
                besm(2200000B);(*workaround*)
            };
            bool100z := false;
            SY := IDENT;
            case glob93z of
            0: {
               hashTravPtr := symHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                  if hashTravPtr@.f[1].i = curFrameRegTemplate then
                  {
                      if hashTravPtr@.f[0] <> curIdent then
                         hashTravPtr := hashTravPtr@.f[2].s
                      else {
                         bool100z := true;
                         exit lexer;
                      }
                  } else exit lexer;
               };
            };
            1: { 2:
                hashTravPtr := symHashTabBase[bucket];
                while hashTravPtr <> NIL do {
                    if hashTravPtr@.f[0] <> curIdent then
                      hashTravPtr := hashTravPtr@.f[2].s
                    else
                      exit lexer;
                };
            };
            2: {
                if glob63z = NIL then goto 2;
                glob62z := glob63z;
                l3var135z := typeHashTabBase[bucket];
                if l3var135z <> NIL then {
                  while glob62z <> NIL do {
                    l3var162z := glob62z@.f[3].p@;
                    hashTravPtr := l3var135z;
                    while hashTravPtr <> NIL do {
                        if (hashTravPtr@.f[0] = curIdent)
                        and (hashTravPtr@.f[6] = l3var162z) then
                            exit lexer;
                        hashTravPtr := hashTravPtr@.f[2].s;
                        besm(2200000B);
                    };
                    glob62z := glob62z@.f[2].s;
                  };
                }; goto 2; besm(3041704B); (* workaround *)
            };
            3: {
               hashTravPtr := typeHashTabBase[bucket];
               while hashTravPtr <> NIL do {
                   with hashTravPtr@ do {
                       if (f[0] = curIdent) and
                          (glob121z = f[6].s) then exit lexer;
                       hashTravPtr := f[2].s;
                   }
               }
            };
            end;
        }; (* IDENT *)
        REALCONST: {
            nextCH;
            if charSymTabBase[CH] = IDENT then goto 1;
            if CH = '(' then SY := BEGINSY
            else if CH = ')' then SY := ENDSY
            else { SY := NOSY; exit };
            nextCH;
        }; (* REALCONST *)
        INTCONST: { (*=m-*)
            SY := INTCONST;
            l3var132z := 0;
            repeat
                l3var132z := l3var132z + 1;
                if (16 >= l3var132z) then
                    numstr[l3var132z].i := ord(CH)-ord('0')
                else {
                    error (55);
                    l3var132z := 1;
                };
                nextCH;
            until charSymTabBase[CH] <> INTCONST;
            (octdec) { if CH = 'B' then octalMode := chr(1)
            else if CH = 'C' then octalMode := chr(3)
            else if CH = 'T' then octalMode := chr(2)
            else { octalMode := chr(0); exit octdec; };
            nextCH;
            curToken.c := chr(0);
            for l3var133z to l3var132z do {
                if 7 < numstr[l3var133z].i then
                    error(20);
                curToken := curToken;
                besm(360075B);
                curToken:=;
                curToken.m := numstr[l3var133z].m * [45..47] +
                curToken.m;
            };
            if octalMode = chr(1) then {
                if curToken.m * [0..6] <> [] then {
                    error(43);
                    curToken.i := 1;
                } else curToken.m := curToken.m + intZero;
            } else if octalMode = chr(2) then {
                l3var164z := 16 - l3var132z;
                for l3var161z to l3var164z do {
                    curToken := curToken;
                    besm(360075B);
                    curToken :=;
                };
            } else; (* workaround *)
            exit lexer;
            }; (* octdec *)
            curToken.i := 0;
            for l3var133z to l3var132z do {
                if 109951162777 >= curToken.i then
                    curToken.i := 10 * curToken.i +
                        numstr[l3var133z].i
                else {
                    error(43);
                    curToken.i := 1;
                };
            };
            l3var161z := 0;
            if CH = '.' then {
                nextCH;
                if CH = '.' then { CH := ':'; exit lexer };
                curToken.r := curToken.i;
                SY := REALCONST;
                if charSymTabBase[CH] <> INTCONST then
                    error (56)
                else repeat
                    curToken.r := 10.0*curToken.r + ord(CH)-48;
                    l3var161z := l3var161z-1;
                    nextCH;
                    until charSymTabBase[CH] <> INTCONST;
            }; (*2062*)
            if CH = 'E' then {
                if l3var161z = 0 then {
                    curToken.r := curToken.i;
                    SY := REALCONST;
                };
                l3var134z := false;
                nextCH;
                if CH = '+' then nextCH else
                if CH = '-' then { l3var134z := true; nextCH }
                else; (* workaround *)
                l3var160z := 0;
                if charSymTabBase[CH] <> INTCONST then
                    error(57)
                else repeat
                    l3var160z := 10 * l3var160z + ord(CH) - 48;
                    nextCH
                until charSymTabBase[CH] <> INTCONST;
                if l3var134z then l3var161z := l3var161z-l3var160z
                else l3var161z := l3var161z+l3var160z;
            }; (* 2122 *)
            if l3var161z <> 0 then {
                l3var137z := 1.0;
                l3var134z := l3var161z < 0;
                l3var161z := abs(l3var161z);
                l3var136z := 10.0;
                if 18 < l3var161z then {
                    l3var161z := 1;
                    error(58);
                };
                repeat
                  if odd(l3var161) then
                    l3var137z := l3var137z * l3var136z;
                  l3var161z := l3var161z div 2;
                  if l3var161z <> 0 then
                     l3var136z := l3var136z*l3var136z;
                until l3var161z = 0;
                if l3var134z then curToken.r := curToken.r / l3var137z
                   else curToken.r := curToken.r * l3var137z;
            };
            exit lexer
        }; (* INTCONST *) (*=m+*)
        CHARCONST: {
            (loop) { for l3var133z := 6 to 130 do {
                nextCH;
                if charSymTabBase[CH] = CHARCONST then {
                    nextCH;
                    if charSymTabBase[CH] <> CHARCONST then
                        exit loop
                    else
                        goto 2233;
                };
                if atEOL then {
                    2175: error(59);
                    exit loop
                } else
                if ((CH = chr(35B)) or (charSymTabBase[CH] = REALCONST))
                   and (charSymTabBase[PASINPUT@] = INTCONST) then {
                    l3var160z := 0;
                    for l3var132z to 3 do {
                        nextCH;
                        if '7' < CH then error(60);
                        l3var160z := 8*l3var160z + ord(CH) - 48;
                    };
                    if 255 < l3var160z then error(60);
                    l3var1z[l3var133z] := chr(l3var160z);
                } else 2233: with PASINFOR do {
                    if charEncoding = 3 then {
                        if (ch < '*') or ('_176' < CH) then
                            l3var138z := chr(0)
                        else {
                            l3var138z := psInfrCopy[CH];
                            besm(3042246B); (*workaround*)
                            }
                    } else if '_176' < CH then {
                        l3var138z := CH;
                    } else if charEncoding = 0 then {
                        l3var138z := a0@[CH];
                    } else if charEncoding = 1 then {
                        l3var138z := a1@[CH];
                    } else if charEncoding = 4 then {
                        l3var138z := a4@[CH];
                    } else {
                        l3var138z := CH;
                        (q) exit q (*workaround*)
                    };
                    l3var1z[l3var133z] := l3var138z;
                };
            }; goto 2175 };
            glob76z := l3var133z - 6;
            if glob76z = 0 then {
               error(61); glob76z := 1; goto 2320 }
            else if glob76z = 1 then {
                SY := CHARCONST;
                l3var132z := 1;
                curToken.c := chr(0);
                unpck(l3var1z[0], curToken.a);
                pck(l3var1z[l3var132z], curToken.a);
                exit lexer;
            } else 2320: {
               curVal.a := '      ';
               SY := LTSY;
               unpck(l3var1z[l3var133z], curVal.a);
               pck(l3var1z[6], curToken.a);
               curVal :=;
               if 6 >= glob76z then exit lexer else {
                   curToken.i := FcstCnt;
                   l3var132z := 6;
                   2334: {
                     toFCST;
                     l3var132z := l3var132z + 6;
                     if l3var133z < l3var132z then exit lexer;
                     pck(l3var1z[l3var132z], curVal.a);
                     goto 2334;
                   }
               }
            };
%            goto 2334; (* doesn't help here as a workaround *)
        }; (* CHARCONST *)
        LTSY: {
            SY := RELOP;
            nextCH;
            if CH = '>' then { charClass := NEOP; nextCH }
            else if CH = '=' then { charClass := LEOP; nextCH }
        }; (* LTOP *)
        GTSY: {
            SY := RELOP;
            nextCH;
            if CH = '=' then { charClass := GEOP; nextCH }
        }; (* GTOP *)
        LPAREN: {
            nextCH;
            if CH = '*' then { parseComment; goto 1473 }
        };
        COLON: {
            nextCH;
            if CH = '=' then {
                nextCH; SY := BECOMES; charClass := NOOP
            }
        };
        NOTSY, LBRACK, MULOP, ADDOP, RELOP, RPAREN, RBRACK,
        COMMA, SEMICOLON, ARROW: {
            nextCH;
        };
        PERIOD: {
            nextCH;
            if CH = '.' then {
                nextCH;
                SY := COLON;
                charClass := NOOP
            } else {
                if glob56z = ENDSY then inStringLit := true;
            }
        };
    end (* case *)
    } else { (* 2444 *)
        nextCH;
    };
    glob56z := SY;
    if not pseudoZ and not (DebugCode in optSflags.m) then {
        commentModeCH := '=';
        goto again;
    };
    commentModeCH := ' ';
    glob93z := glob92z;
} }; (* inSymbol *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skipToEnd;
var l4var1z:symbol;
{
   l4var1z := SY;
   while (l4var1z <> ENDSY) or (SY <> PERIOD) do {
       l4var1z := SY;
       inSymbol
   };
   if CH = 'D' then while SY <> ENDSY do inSymbol;
   goto 9999;
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* error *)
    errors := true;
    glob110z :=;
    if ((linePos <> prevErrPos) and (9 >= errsInLine))
    or (errno = 52) then {
        write(' '); totalErrors := totalErrors + 1;
        errMapBase[errsInLine] := linePos;
        errsInLine := errsInLine + 1;
        prevErrPos := linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if 60 < totalErrors then {
            writeln; endOfLine;
            printErrMsg(53);
            skipToEnd
        }
    }
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skip(toset:setofsys);
{
while not (SY IN toset) do inSymbol;
}; (* skip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure test1(sym:symbol; toset: setofsys);
{
   if (SY <> sym) then {
     requiredSymErr( sym );
     skip( toset )
   } else inSymbol;
}; (* test1 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure errAndSkip(errno:integer; toset:setofsys);
{
   error( errno );  skip( toset )
}; (* errAndSkip *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLiteral(var l3arg1z:struc; var l3arg2z:word;
    l3arg3z:boolean);
label 99;
var l3var1z:operator;
{
 l3arg2z := curToken;
 if (GTSY < SY) then {
     if l3arg3z and (charClass IN [PLUSOP,MINUSOP]) then {
        l3var1z := charClass;
        inSymbol;
        parseLiteral( l3arg1z, l3arg2z, false );
        if (l3arg1z.f[0].s <> integerType) then {
           error( 62 );
           l3arg1z.f[0].s := integerType;
           l3arg2z.i := 1;
        } else {
           if (l3var1z = MINUSOP) then l3arg2z.i := -l3arg2z.i;
        };
    } else 99: {
       l3arg1z.f[0].p := NIL;
       error( 6 );
    }
  } else  case SY of
 IDENT: {
 if (hashTravPtr = NIL) or
    (hashTravPtr@.f[4].y <> INTCONST) then goto 99;
  l3arg1z.f[0] := hashTravPtr@.f[3];
  l3arg2z := hashTravPtr@.f[6];
  };
INTCONST:
 l3arg1z.f[0].s := integerType;
 REALCONST:
 l3arg1z.f[0].s := realType;
 CHARCONST:
 l3arg1z.f[0].s := charType;
 LTSY:
     assignType( l3arg1z );
 GTSY: {
     l3arg1z.f[0].s := pointerType;
     l3arg2z.p := NIL;
 };
 end (* case *)
}; (* parseLiteral *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P2672(var l3arg1z: struc; l3arg2z: @struc);
var l3var1z: boolean; l3var2z: integer;
l3var3z,l3var4z:@struc;
{
 if l3arg1z.f[0].p = NIL then {
 curVal.m := l3arg2z@.f[0].m * hashMask.m;
 mapAI(curVal.a, l3var2z);
 l3var1z := true;
 l3arg1z.f[0].s := symHashTabBase[l3var2z];
 } else {
 l3var1z := false;
 };
 if (l3arg1z.f[0].s = l3arg2z) then {
   if (l3var1z) then {
     symHashTabBase[l3var2z] :=
         symHashTabBase[l3var2z]@.f[2].s;
   } else {
     l3arg1z.f[0] := l3arg2z@.f[2];
   };
 } else {
   l3var3z := l3arg1z.f[0].s;
   while (l3var3z <> l3arg2z) do {
     l3var4z := l3var3z;
     if (l3var3z <> NIL) then {
        l3var3z := l3var3z@.f[2].s;
     } else {
        exit
     }
   };
   l3var4z@.f[2] := l3arg2z@.f[2];
 }
}; (* P2672 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr:@struc):boolean;
{ isFileType := (typtr@.f[2].c = chr(7)) or
    (typtr@.f[2].c = chr(6)) and
    typtr@.f[5].b;
}; (* isFileType *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F2751(var l3arg1z:struc):boolean;
{
 if (l2var2z.s <> NIL) then {
  l3arg1z.f[0].s := l2var2z.s;
  while (l3arg1z.f[0].s <> NIL) do {
    if (l3arg1z.f[0].p@ = curIdent) then {
        F2751 := true;
        exit
    };
    l3arg1z.f[0] := l3arg1z.f[0].s@.f[2];
    besm(2200000B); (* workaround *)
  }
 };
 F2751 := false;
}; (* F2751 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkSymAndRead(sym: symbol);
{
 if (SY <> sym) then requiredSymErr( sym )
 else inSymbol
}; (* checkSymAndRead *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function typeCheck(l3arg1z, l3arg2z: @struc):boolean;
label 1;
var l3var1z, l3var2z, l3var3z, l3var4z, l3var5z,
    l3var6z, l3var7z, l3var8z, l3var9z, l3var10z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure allocWithTypeCheck;
{
 new(l3var4z.p=3);
 with l3var4z.s@ do {
     f[0].p := glob133z;
     f[1] := l3var5z;
     f[2] := l3var6z;
 };
 glob133z := l3var4z.p;
 typeCheck :=  typeCheck    ( l3var5z.s, l3var6z.s );
 }; (* allocWithTypeCheck *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3020(l4arg1z, l4arg2z: @struc):boolean;
var l4var1z: boolean;
{
 l4var1z := (l4arg1z = NIL) or (l4arg2z = NIL);
 if (l4var1z) then {
     F3020 := l4arg1z = l4arg2z;
 } else {
 F3020 := typeCheck(l4arg1z@.f[3].s, l4arg2z@.f[3].s) and
          F3020(l4arg1z@.f[5].s, l4arg2z@.f[5].s);
 };
 }; (* F3020 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* typeCheck *)
 bool105z := false;
 if (l3arg1z@.f[2].c = chr(2)) then {
 glob120z := l3arg1z@.f[3].s;
 } else {
 glob120z := l3arg1z;
 };
 if not checkTypes or (l3arg1z = l3arg2z) then
    1: typeCheck := true
 else with l3arg1z@ do {
 l3var2z := f[2];
 l3var3z := l3arg2z@.f[2];
 if (l3var2z = l3var3z) then {
 case l3var2z.c of
  '_000':;
  '_001': {
  (chain) if (l3arg1z@.f[4] = l3arg2z@.f[4]) then {
     l3var7z := l3arg1z@.f[3];
     l3var8z := l3arg2z@.f[3];
     while (l3var7z.p <> NIL) and (l3var8z.p <> NIL) do {
         if (l3var7z.s@.f[0] <> l3var8z.s@.f[0]) then
             exit chain;
         l3var7z := l3var7z.s@.f[5];
         l3var8z := l3var8z.s@.f[5];
     };
     if (l3var7z.p = NIL) and (l3var8z.p = NIL) then goto 1;
  }
 };
 '_002': {
  l3var1z.b := (l3arg1z@.f[3] = l3arg2z@.f[3]);
 glob120z := l3arg1z@.f[3].s;
 bool105z := (l3arg1z@.f[5] <> l3arg2z@.f[5]) or
             (l3arg1z@.f[6] <> l3arg2z@.f[6]);
 typeCheck := l3var1z.b;
 exit
 };
 '_003': {
     if (l3arg1z = pointerType) or (l3arg2z = pointerType) then
         goto 1;
     l3var5z := l3arg1z@.f[3];
     l3var6z := l3arg2z@.f[3];
     if (glob133z <> NIL) then {
         l3var4z.p := glob133z;
         while (l3var4z.p <> NIL) do with l3var4z.s@ do {
             if (f[1] = l3var5z) and
                (f[2] = l3var6z) or
                (f[2] = l3var5z) and
                (f[1] = l3var6z) then goto 1;
             l3var4z := f[0];
         };
         allocWithTypeCheck;
     } else {
         setup(l3arg1z);
         allocWithTypeCheck;
         glob133z := NIL;
         rollup(l3arg1z);
         exit
     }
 };
 '_004': goto 1;
 '_005': {
     with l3arg1z@.f[4].s@ do l3var9z.i := f[6].i - f[5].i;
     with l3arg2z@.f[4].s@ do l3var10z.i := f[6].i - f[5].i;

 if typeCheck( l3arg1z@.f[3].s, l3arg2z@.f[3].s) and
    (l3var9z = l3var10z) and
    (l3arg1z@.f[5] = l3arg2z@.f[5]) and not bool105z then {
       if l3arg1z@.f[5].b then {
           if (l3arg1z@.f[7] = l3arg2z@.f[7]) then goto 1
       } else goto 1
 }

 };
 '_007': {
    if typeCheck( l3arg1z@.f[3].s, l3arg2z@.f[3].s ) then
        goto 1;
 };
 '_006': {
     if F3020( l3arg1z@.f[4].s, l3arg2z@.f[4].s ) then
         goto 1;
 }
 end (* case *)
 } else {
     if (l3var2z.c = chr(2)) then {
         bool105z := true;
         glob120z := l3arg2z;
         if (l3arg1z@.f[3].s = l3arg2z) then goto 1;
     } else if (l3var3z.c = chr(2)) and
               (l3arg1z = l3arg2z@.f[3].s) then goto 1;

     };
     typeCheck := false;
 }
}; (* typeCheck *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3307(l3arg1z: @struc):integer;
var l3var1z:integer; l3var2z:@struc;
{
 l3var2z := l3arg1z@.f[7].s;
 l3var1z := 0;
 if (l3var2z <> NIL) then while (l3var2z <> l3arg1z) do {
     l3var1z := l3var1z + 1;
     l3var2z := l3var2z@.f[5].s;
 };
 F3307 := l3var1z;
 }; (* F3307 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeNameWithStars(l3arg1z:boolean):word;
var l3var1z: boolean;
{
 l3var1z := not l3arg1z and (extSymAdornment = 0);

 if curVal.m * [0..5] = [] then {
     curVal := curVal; besm(360072B); curVal := ;
     if l3var1z or (extSymAdornment = 1) then
         curVal.m := curVal.m + [44,46];
     while curVal.m * [0..11] = [] do {
         curVal := curVal; besm(360072B); curVal := ;
     };

     if curVal.m * [0..5] = [] then {
         if l3var1z then
             curVal.m := [2,4] + curVal.m
         else {
           curVal := curVal; besm(360072B); curVal := ;
        }
     }
 };
 makeNameWithStars := curVal;
 }; (* makeNameWithStars *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formOperator(l3arg1z: word);
var l3var1z, l3var2z: word;
l3var3z, l3var4z, l3var5z,
l3var6z, l3var7z, l3var8z, l3var9z, l3var10z,
l3var11z: word; l3var12z: @struc; l3var13z, l3var14z:word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  genOneOp;
label 3556;
var l4var1z:integer;
l4var2z,l4var3z,l4var4z:integer;l4var5z:word;
l4var6z, l4var7z, l4var8z: @struc;  l4var9z: integer;
insnBuf: array[1..200] of word;
l4var210z:word; l4var211z:word; l4var212z: @struc;
l4var213z: boolean;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3363;
{
 if l4var213z then
    form1Insn    ( insnTemp[XTA] )
 else
    form1Insn    (04100010B )
 }; (* P3363 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  addInsnToBuf(l5arg1z:integer);
{
 insnBuf[l4var1z].i := l5arg1z;
 l4var1z := l4var1z + 1;
 }; (* addInsnToBuf *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure add2InsnsToBuf(l5arg1z, l5arg2z: integer);
{
 insnBuf[l4var1z].i := l5arg1z;
 insnBuf[l4var1z+1].i := l5arg2z;
 l4var1z := l4var1z + 2;
}; (* add2InsnsToBuf *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3413:boolean;
{
 l4var7z := l4var6z;
 while l4var7z <> NIL do {
     if (l4var7z@.f[1].i = l4var210z.i) then {
         F3413 := true;
         while (l4var7z@.f[2].i = 100000000B) do {
             l4var7z := ptr(l4var7z@.f[3].i);
         };
         exit
     } else {
         l4var7z := l4var7z@.f[0].s;
     }
 };
 F3413 := false;
}; (* F3413 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3436(l5arg1z:integer);
{
 if not F3413 then {
     new(l4var7z=4);
     l4var7z@.f[0].s := l4var6z;
     l4var7z@.f[1].i := l4var210z.i;
     l4var7z@.f[2].i := 0;
     l4var7z@.f[3].i := 0;
     l4var6z := l4var7z;
 };
 addInsnToBuf( (100000000B + l5arg1z) + ord(l4var7z) )
 }; (* P3436 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genOneOp *)
    if insnList = NIL then exit;
    glob145z.m := glob145z.m + insnList@.f[3].m;
    l4var212z := insnList@.f[1].s;
    l4var9z := 370007B;
    l4var1z := 1;
    if l4var212z = NIL then exit;
    l4var6z := NIL;
    while l4var212z <> NIL do {
        l4var211z.i := l4var212z@.f[2].i;
        l4var4z := l4var211z.i - 100000000B;
        l4var210z.i := l4var212z@.f[3].i;
        case l4var212z@.f[1].i of
        0:;
        1: if arithMode <> 1 then {
               addInsnToBuf(370007B);
               arithMode := 1
           };
        2: arithMode := 1;
        3: if arithMode <> 2 then {
              addInsnToBuf(insnTemp[NTR]);
              arithMode := 2;
           };
        4: arithMode := 2;
        end; (* case *)
        l4var212z := l4var212z@.f[0].s;
        if l4var4z >= 0 then {
            case l4var4z of
            23: add2InsnsToBuf(00220000B, 04120011B);
            21: goto 3556;
            0: P3436(insnTemp[U1A]);
            1: P3436(insnTemp[UJ]);
            2: {
                l4var211z.i := l4var210z.i mod 4096;
                l4var210z.i := l4var210z.i div 4096;
                P3436(insnTemp[VJM]);
                l4var210z.i := l4var211z.i;
                3556:
                    if F3413 then
                        addInsnToBuf(ord(l4var7z) + 200000000B)
                    else error(206);
            };
            3: {
                 l4var211z.i := l4var210z.i mod 4096;
                 l4var210z.i := l4var210z.i div 4096;
                 l4var213z :=  F3413;
                 l4var8z := l4var7z;
                 l4var210z.i := l4var211z.i;
                 l4var213z := l4var213z & F3413;
                 if l4var213z then with l4var7z@ do {
                     f[2].i := 100000000B;
                     f[3].i := ord(l4var8z);
                 } else error(207);
             };
            20: addInsnToBuf(300000000B + l4var210z.i);
            4: {
             if insnBuf[l4var1z-1].m * [21:23,28:35] = []  then
                 insnBuf[l4var1z-1].m := insnBuf[l4var1z-1].m + [35]
             else
                 addInsnToBuf(74100000B)
            };
            5: (blk) {
                if l4var212z <> NIL then {
                   l4var211z := l4var212z@.f[2];
                   if l4var211z.m * [21:23,28:35] = [32] then {
                       l4var212z@.f[2].i :=
                        l4var211z.i - insnTemp[XTA] + insnTemp[XTS];
                        exit blk
                    }
                };
                addInsnToBuf(74000000B);
           };
           6: add2InsnsToBuf(400016B, 72200000B );
           7: addInsnToBuf( getHelperProc(12)); (* P/MI *)
           8: add2InsnsToBuf(76300000B, 02500000B+
                             int398ar[l4var210z.i]);
           9: add2InsnsToBuf(400016B, 70450000B + l4var210z.i);
           10:add2InsnsToBuf(04110010B, 04120011B);
           11:{addInsnToBuf(04040023B);(*round*)
                add2InsnsToBuf(370007B, 04040011B)};
           12:add2InsnsToBuf(74000000B,74170000B);(*sqr*)
           13:{add2InsnsToBuf(74000000B, 04120012B);(*sqrint*)
                add2InsnsToBuf(74170000B, 0310100B)};
           14:add2InsnsToBuf(int398ar[l4var210z.i] + 02400000B,
                              0420000B + l4var210z.i);
           15:add2InsnsToBuf(04230011B, 04050021B); (* minel *)
           16:add2InsnsToBuf(insnTemp[XTA], 74000000B + l4var210z.i);
           17:{addInsnToBuf( 0030000B);
                add2InsnsToBuf(74000001B, 76500000B + l4var210z.i)};
           18:add2InsnsToBuf(52400000B,getHelperProc(65)); (*P/B7*)
           19:{addInsnToBuf(72400000B);
                add2InsnsToBuf(74100000B, 70000000B)};
           22:{add2InsnsToBuf(72400000B, 70100000B);
                curVal.i := 40077777C;
                add2InsnsToBuf(allocSymtabForAbsolute(curVal.m)+74030000B,
                               40110000B + l4var210z.i);
                add2InsnsToBuf(74120000B, 70000000B)};
            end; (* case *)
        } else { (* 4003 *)
            if 28 in l4var211z.m then {
              addInsnToBuf(getValueOrAllocSymtab(l4var210z.i)+l4var211z.i);
            } else {
              curval.i := l4var210z.i mod 32768;
              if curVal.i < 2048 then
                  addInsnToBuf(l4var211z.i + l4var210z.i)
              else (stmt) if (curVal.i >= 28672) or (curVal.i < 4096) then {
                 addInsnToBuf(
                   allocSymtabForAbsolute((curVal.m + [24])*halfWord.m)
                              + l4var211z.i - 28672);
              } else {
                 add2InsnsToBuf(getValueOrAllocSymtab(curVal.i)
                                + insnTemp[WTC], l4var211z.i );
                 exit stmt; (*workaround*)
              }
            }
        }
    }; (* 4037 *)
    l4var1z := l4var1z-1;
    for l4var4z := l4var1z downto 1 do {
        l4var210z := insnBuf[l4var4z];
        if (l4var210z.i = insnTemp[NTR]) or
           (l4var210z.i = 370007B) then {
            l4var3z := l4var4z - 1;
            l4var213z := false;
            (loop) while l4var3z >= 1 do {
                l4var211z.m := insnBuf[l4var3z].m * [28:32];
                if (l4var211z.m # [28,31])and(l4var211z.m # [28,31,32])
                then exit loop else l4var3z := l4var3z-1;
            };
            l4var3z := l4var3z + 1;
            if (l4var3z <> l4var4z) then {
                for l4var2z := l4var4z-1 downto l4var3z do {
                    insnBuf[l4var2z+1] := insnBuf[l4var2z]
                };
            };
            insnBuf[l4var3z] := l4var210z;
        }; (* 4103 *)
    };
    for l4var4z to l4var1z do (iter) {
        l4var210z := insnBuf[l4var4z];
        l4var211z.m := l4var210z.m * [0,1,3,23:32];
        if l4var211z.i = 74000000B then {
            l4var2z := l4var4z + 1;
            while l4var1z + 1 <> l4var2z do {
                curVal.m := insnBuf[l4var2z].m * [0,1,3,23,28:35];
                l4var211z.m := curVal.m * [0,1,3,23,28:32];
                if curVal.i = insnTemp[XTA] then {
                   insnBuf[l4var2z].m :=
                       insnBuf[l4var2z].m mod [32,34,35];
                   exit iter;
                } else if curVal.i = insnTemp[ITA] then {
                    insnBuf[l4var2z].m := insnBuf[l4var2z].m + [35];
                    exit iter;
                } else if (curVal.i = insnTemp[NTR]) or
                    (l4var211z.i = insnTemp[WTC]) or
                    (l4var211z.i = insnTemp[VTM]) or
                    (l4var211z.i = insnTemp[UTM]) then
                        l4var2z := l4var2z + 1
                    else
                        l4var2z := l4var1z + 1;

            };
        }; (* 4150 *)
        if l4var210z.i = insnTemp[WTC] then exit iter;
        if l4var210z.i < 100000000B then {
             form1Insn( l4var210z.i );
             l4var211z.m := l4var210z.m * [28:32];
              if (l4var211z.m = [28,29,32]) or
              (l4var211z.m = [30,32]) then {
                  formLabel;
                  glob95z.i := 1;
              };
              exit iter;
        };
        if (l4var210z.i >= 300000000B) then {
            l4var210z.i := l4var210z.i - 300000000B;
             if l4var210z.i >= 4096 then {
                 l4var213z := true;
                 l4var210z.i := l4var210z.i - 4096;
             } else {
                 l4var213z := false;
             };
             if (l4var210z.i = 0) then
                 form1Insn(insnTemp[U1A] + moduleOffset + 2);
             P3363;
             form1Insn(insnTemp[VJM] + 2 + moduleOffset);
             formLabel;
 if (l4var210z.i <> 0) then {
     if (not F3413) then error(211);
     P0715(0, l4var7z@.f[2].i);
 };
 l4var213z := not l4var213z;
 P3363;
 formLabel;
 exit iter
     }; (* 4230 *)
 if (l4var210z.i >= 200000000B) then {
    l4var7z := ptr(l4var210z.i - 200000000B);
    P0715(0, l4var7z@.f[2].i );
    l4var7z@.f[3].i := moduleOffset;
  } else {
 l4var210z.i := l4var210z.i - 100000000B;
 curVal.m := l4var210z.m * [0,1,3,28:32];
 glob51z := curVal;
 curVal.m := [0,1,3,33:47] * l4var210z.m;
 l4var7z := ptr(curVal.i);
 formJumpOnCond(l4var7z@.f[2].i );
 glob51z.i := insnTemp[VJM];
 exit iter
}
    }; (* loop *)
    insnList := NIL;

 while (l4var6z <> NIL) do {
    with l4var6z@ do
    if (f[3].i = 0) then {
    jumpTarget := f[2];
    exit;
 } else
   l4var6z := f[0].s;
 };
 glob146z.m := glob146z.m - glob145z.m;
}; (* genOneOp *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToInsnList(l4arg1z:integer);
var l4var1z:@struc;
{
 new(l4var1z=4);
 with l4var1z@ do {
     f[0].s := NIL; f[1].i := 0;
     f[2].i := l4arg1z; f[3].i := 0;
 };
 with insnList@ do {
     if f[0].s = NIL then f[1].s := l4var1z
     else f[0].s@.f[0].s := l4var1z;
     f[0].s := l4var1z
 }
}; (* addToInsnList *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addInsnAndModify(l4arg1z,l4arg2z:integer);
{
 addToInsnList(l4arg1z);
 insnlist@.f[0].s@.f[3].i := l4arg2z
}; (* addInsnAndModify *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addxToInsnList(l4arg1z: integer);
var l4var1z:@struc;
{
 new(l4var1z=4);
 with l4var1z@ do {
 f[0] := insnList@.f[1];
 f[1].i := 0;
 f[2].i := l4arg1z;
 f[3].i := 0;
 };
 if (insnList@.f[1].s = NIL) then {
     insnList@.f[0].s := l4var1z;
 };
 insnList@.f[1].s := l4var1z;
}; (* addxToInsnList *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4343;
label 4545,4602;
var l4var1z,l4var2z,l4var3z,l4var4z,l4var5z,
l4var6z,l4var7z,l4var8z,l4var9z:word;
{
l4var4z := insnList@.f[2];
with insnList@ do {
 case f[4].c of
 '_000':{
     curVal := f[5];
     if (l4var4z.s@.f[0].i = 1) then
         curVal.i := getFCSToffset;
     addToInsnList(constRegTemplate.i + curInsnTemplate.i + curVal.i);
 };
 '_001':{
     l4var1z := insnList@.f[7];
     l4var2z := insnList@.f[5];
     l4var3z := insnList@.f[6];
     if (15 < l4var1z.i) then { } else {
       if (l4var1z.i = 15) then {
              addToInsnList(100000006B );
       } else {
          l4var1z.i := int398ar[insnList@.f[7].i];
          if (l4var2z.i = 0) and (insnList@.f[8].c = '_000') then {
             addInsnAndModify(l4var1z.i+curInsnTemplate.i, l4var3z.i);
             goto 4602;
          } else {
             addToInsnList(l4var1z.i + insnTemp[WTC]);
             (q) exit q (* workaround *)
          }
       }
     };
     l4var6z := insnList@.f[8];
     if l4var6z.c = '_000' then {
         addInsnAndModify(l4var2z.i + curInsnTemplate.i, l4var3z.i);
     } else {
         l4var5z := l4var4z.s@.f[2];
         if (l4var5z.c < '_004') or
         (l4var5z.c = '_006') and (s6 in optSflags.m) then {
         l4var7z.b := true;
         l4var8z.b :=  typeCheck( l4var4z.s, integerType );
         } else {
            l4var7z.b := false;
            l4var8z.b := false;
         };
         if l4var6z.c = '_001' then {
            if (l4var3z <> l4var2z) or
               (l4var1z.i <> 18) or
               (l4var2z.i <> 0) then
               addInsnAndModify(l4var2z.i + insnTemp[XTA], l4var3z.i);
            l4var3z := insnList@.f[10];
            l4var2z := insnList@.f[9];
            l4var9z.b := true;
            l4var1z.i := (l4var3z.i + l4var2z.i);
            if l4var7z.b then {
                if (30 < l4var3z.i) then {
               addToInsnList( 360020B + l4var3z.i );
               addToInsnList( insnTemp[YTA] );
               if (l4var1z.i = 48) then l4var9z.b := false;
             } else {
              if (l4var3z.i <> 0) then
                 addToInsnList( ASN64 + l4var3z.i);
             }; (* 4477 *)
             if l4var9z.b then {
             curVal.m := [(48 - l4var2z.i)..47];
             addToInsnList(40110000B + getFCSToffset);
             }
        } else { (* 4511 *)
          if (l4var1z.i <> 48) then
              addToInsnList(360020B + l4var1z.i);
          curVal.m := [0..(l4var2z.i-1)];
          addToInsnList(40110000B + getFCSToffset);
        }; (* 4525 *)
        if l4var8z.b then addToInsnList(04120011B);
        } else { (* 4531 *)
            if l4var7z.b then
             l4var1z.i := ord(l4var8z.b)+74
             else l4var1z.i := 56;
             addToInsnList( getHelperProc ( l4var1z.i )  );
             insnList@.f[0].s@.f[1].i := 1;
        }
     };
     goto 4545;
 };
 '_002': { 4545:
     if bool49z and (l4var4z.s = booleanType) and
     (16 in insnList@.f[3].m) then addToInsnList(04120010B);
 };
 '_003': { (* 4555 *)
 if bool49z then
  addInsnAndModify (100000024B,
     ord(16 in insnList@.f[3].m)*10000B+insnList@.f[5].i);
 };
 end; (* case *) 4602:
}; (* with*)
with insnList@ do {
 f[4].c := '_002';
 f[3].m := f[3].m + [0];
};
}; (* P4343 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4606;
{ P4343;
addToInsnList(100000005B)
}; (* P4606 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4621(l4arg1z:integer);
label 4650, 4654;
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z,
l4var6z, l4var7z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4613;
{
 l4var1z := insnList@.f[6];
 l4var1z.i := l4var1z.i mod 32768;
 l4var6z := l4var1z
}; (* P4613 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P4621 *)
with insnList@ do {
 l4var2z := f[7];
 l4var3z.i := insnTemp[UTM];
 l4var7z.i := int398ar[l4arg1z];
 l4var4z := f[5];
 f[3].m := f[3].m + [l4arg1z];
 if (f[4].c = '_000') then {
 curVal := f[5];
 if (f[2].s@.f[0].i = 1) then curVal.i := addSomethingToFCST;
 l4var6z := curVal;
 l4var5z.i := 30721;
 goto 4654;
 } else if (l4var2z.i = 18) then {
     4650: P4613;
     if (l4var4z.i = int398ar[1]) then {
     l4var5z.i := 30723;
     4654: l4var1z.i := 100000000B * l4var5z.i + l4var6z.i;
     l4var6z.i := allocSymtabForAbsolute
     (l4var1z.m * [12:47]);
     addToInsnList(l4var7z.i + l4var3z.i + l4var6z.i);
     } else if (l4var4z.i <> 0) then {
       addInsnAndModify(l4var4z.i + insnTemp[WTC], l4var6z.i );
       addToInsnList(l4var7z.i + l4var3z.i);
     } else {
       addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i );
     }
 } else if (l4var2z.i = 17) then {
     P4613;
     l4var4z := insnList@.f[6];
     l4var5z.i := insnList@.f[0].s@.f[2].i - insnTemp[WTC];
     if (l4var4z.i <> 0) then {
       l4var1z.i := 100000000B * l4var5z.i + l4var4z.i;
       l4var5z.i :=
         allocSymtabForAbsolute(l4var1z.m * [12:47]);
 };
 insnList@.f[0].s@.f[2].i := l4var7z.i + l4var5z.i + l4var3z.i;
 } else  if (l4var2z.i = 16) then {
    P4613;
    if (l4var4z.i <> 0) then
       addToInsnList(l4var4z.i + insnTemp[WTC]);
    addInsnAndModify(l4var7z.i + l4var3z.i, l4var6z.i);
 } else if (l4var2z.i = 15) then {
    addToInsnList(insnTemp[ATI] + l4arg1z );
    l4var3z.i := insnTemp[UZA];
    goto 4650;
 } else {
    addToInsnList(int398ar[l4var2z.i] + insnTemp[WTC]);
    goto 4650;
 }
 }; (* with *)
 insnList@.f[4].c := '_001';
 insnList@.f[7].i := l4arg1z;
 insnList@.f[6].i := 0;
 insnList@.f[5].i := 0;
}; (* P4621 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4755;
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z, l4var6z, l4var7z: word;
{
with insnList@ do l4var1z := f[7];
if (15 < l4var1z.i) then {
 (* nothing? *)
 } else if (l4var1z.i = 15) then {
   addToInsnList( 100000006B )
 } else {
   addToInsnList(int398ar[l4var1z.i] + insnTemp[WTC]);
};
 l4var4z.b := 0 in insnList@.f[3].m;
 l4var6z := insnList@.f[8];
 if (l4var6z.c <> '_000') or l4var4z.b then
     addxToInsnList(100000005B );
 if (l4var6z.c = '_000') then {
 if (l4var4z.b) then {
    addInsnAndModify(insnList@.f[5].i + insnTemp[WTC], insnList@.f[6].i);
    addToInsnList( 100000023B );
 } else {
    addInsnAndModify( insnList@.f[5].i, insnList@.f[6].i );
 }
 } else {
     l4var7z := insnList@.f[2].s@.f[2];
     l4var1z := insnList@.f[2].s@.f[1];
     l4var5z.b := (l4var7z.c < '_004') or
         (l4var7z.c = '_006') and (S6 in optSflags.m);
     if (l4var6z.c = '_001') then {
       l4var2z := insnList@.f[10];
       l4var3z.i := (l4var2z.i + insnList@.f[9].i);
       if l4var5z.b then {
         if (l4var2z.i <> 0) then addxToInsnList(ASN64 - l4var2z.i);
       } else {
         if (l4var3z.i <> 48) then addxToInsnList(360160B - l4var3z.i);
       };
       addInsnAndModify(insnTemp[WTC] + insnList@.f[5].i, insnList@.f[6].i );
       curVal.m := [0..47]-[(48-l4var3z.i)..(47 -l4var2z.i)];
       addInsnAndModify(100000026B, getFCSToffset  );
     }  else {
        if not l4var5z.b then {
          l4var2z.i := (insnList@.f[9].i - l4var1z.i);
          if (l4var2z.i <> 0) then addxToInsnList(ASN64 - l4var2z.i);
          addxToInsnList( insnTemp[YTA] );
          addxToInsnList(ASN64 - l4var1z.i);
        };
        addToInsnList(getHelperProc (77)); (* "P/STAR" *)
        insnList@.f[0].s@.f[1].i := 1;
     }
   }
}; (* P4755 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 procedure P5117(l4arg1z: word);
 {
     addInsnAndModify( curFrameRegTemplate, l2var20z );
     new(curExpr=4);
     with curExpr@ do f[0] := insnList@.f[2];
     genOneOp;
     curExpr@.f[1] := l4arg1z;
     curExpr@.f[2].i := l2var20z;
     l2var20z := l2var20z + 1;
     if (l2var21z < l2var20z) then l2var21z := l2var20z;
 }; (* P5117 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F5142: integer;
var l4var1z:integer; l4var2z:@struc;
{
 l4var1z := 0;
 l4var2z := insnList@.f[1].s;
 while (l4var2z <> NIL) do {
     l4var2z := l4var2z@.f[0].s;
     l4var1z := l4var1z + 1;
 };
  F5142 := l4var1z;
}; (* F5142 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genFullExpr(l4arg1z:@struc);
label 7567, 7760, 10075, 10122;
var l4var1z, l4var2z:word; l4var3z: @struc;
    l4var4z, l4var5z, l4var6z, l4var7z: word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5155;
{
  P4343;
 insnList@.f[4].c := '_001';
 insnList@.f[8].c := '_000';
 insnList@.f[6].i := 0;
 insnList@.f[5].i := 0;
 insnList@.f[7].i := 18;
}; (* P5155 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5170;
label 5220;
var l5var1z, l5var2z:word; l5var3z: boolean;
{
l5var3z := checkBounds and not (NoPtrCheck in optSflags.m)
   and ( l4var6z.c = '_042');
 if not l5var3z and (
  (insnList@.f[8].c = '_000') or
    (insnList@.f[8].c = '_001') and
    (insnList@.f[10].i = 0)) then {
     l5var1z := insnList@.f[7];
     l5var2z := insnList@.f[6];
     if (l5var1z.i = (18)) or (l5var1z.i = (16)) then {
     5220: addInsnAndModify ( (insnList@.f[5].i + insnTemp[VTM]), l5var2z.i );
  } else {
   if (l5var1z.i = (17)) then {
     if (l5var2z.i = (0)) then {
       insnList@.f[0].s@.f[2].i := insnList@.f[0].s@.f[2].i + insnTemp[XTA];
     } else goto 5220;
   } else if (l5var1z.i = (15)) then {
     addToInsnList    ( 100000006B );
     goto 5220;
   } else
   addInsnAndModify    ( (int398ar[l5var1z.i] + insnTemp[VTM]), l5var2z.i );
   }
 } else {
    P5155;
    if (l5var3z) then {
       addToInsnList    ( (72400000B + lineCnt) );
       addToInsnList    (   getHelperProc (7)   (* "P/CA"*)  );
       insnList@.f[0].s@.f[1].i := (1);
    };
    addToInsnList    (100000006B );
 };

 insnList@.f[6].i := (0);
 insnList@.f[5].i := (0);
 insnList@.f[7].i := (16);
}; (* P5170 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5270;
{
 P4606;
 l3var12z := insnList;
 insnList := l4var3z;
 P4343    ;
 addToInsnList    (   getHelperProc    ( l3var4z.i )  );
 insnList@.f[3].m := insnList@.f[3].m + l3var12z@.f[3].m + [11:14];
 l3var12z@.f[0].s@.f[0] := insnList@.f[1];
 insnList@.f[1] := l3var12z@.f[1];
}; (* P5270 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5314;
var l5var1z:boolean; l5var2z: @struc;
{
 l5var1z := 12 in l4var3z@.f[3].m;
 P4621 (12);
 if (l5var1z) then {
 addToInsnList    ( 00420014B );
 addToInsnList    ( 100000005B );
 };
 l5var2z := insnList;
 insnList := l4var3z;
 P4621   ( (14) );
 if (l5var1z) then {
 addToInsnList    ( 100000004B );
 addToInsnList    ( 00400014B );
 };
 l5var2z@.f[3].m := (insnList@.f[3].m + l5var2z@.f[3].m);
 l5var2z@.f[0].s@.f[0] := insnList@.f[1];
 l5var2z@.f[0] := insnList@.f[0];
 insnList := l5var2z;
}; (* P5314 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5354(l5arg1z: @struc);
var l5var1z:integer; l5var2z, l5var3z, l5var4z: word;
{
 l5var1z := l5arg1z@.f[4].i;
 if (l5var1z = (0)) then {
 curVal := l5arg1z@.f[5];
 l5var4z := l5arg1z@.f[6];
 if (l5arg1z@.f[3].s <> integerType) then {
 curVal.m := curVal.m * [7:47];
 l5var4z.m := l5var4z.m * [7:47];
 };
 glob95z.i := (0);
 formInsnAndLabel    ( (03000005B + moduleOffset) );
 l5arg1z@.f[4].i := moduleOffset;
 l5var1z := moduleOffset;
 P0715    ( (1), l5var4z.i );
 formInsnAndLabel    ( 67000000B );
 };
 P4343    ;
 addToInsnList    ( (72400000B + lineCnt) );
 addToInsnList    ( (67100000B + l5var1z) );
 insnList@.f[0].s@.f[1].i := (1);
}; (* P5354 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5420;
{
 if (insnList@.f[4].c = '_000') then {
 insnList@.f[5].b := not insnList@.f[5].b;
 } else {
 insnList@.f[3].m := insnList@.f[3].m mod [16];
 }
}; (* P5420 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5433(l5arg1z:boolean);
label 100, 22, 33;
var l5var1z: integer; l5var2z: @struc;
{
 if not (0 in l4var3z@.f[3].m) then {
    l5var1z := (0);
 } else (stmt) if not (0 in insnList@.f[3].m) then {
    l5var1z := ord(l5arg1z) + 1;
 } else {
    l5var1z := (3);
    exit stmt; (* workaround *)
 };
 case l5var1z of
 0: 100: {
 P4343    ;
 l3var12z := insnList;
 insnList := l4var3z;
 curInsnTemplate := l3var4z;
 P4343    ;
 curInsnTemplate.i := insnTemp[XTA];
 };
 1:
  if (l3var4z.i = insnTemp[SUB]) then {
     l3var4z.i := insnTemp[RSUB];
     goto 22;
 } else goto 33;
2: 22: {
 l3var12z := insnList;
 insnList := l4var3z;
 l4var3z := l3var12z;
 goto 100;
 };
3: 33: {
 P4343    ;
 addToInsnList    ( glob413z + l3var4z.i );
 l5var2z := insnList;
 insnList := l4var3z;
 P4606    ;
 l3var12z := insnList;
 insnList := l5var2z;
 };
end; (* case *)
 insnList@.f[0].s@.f[1].i := (0);
 l3var12z@.f[0].s@.f[0] := insnList@.f[1];
 insnList@.f[1] := l3var12z@.f[1];
 insnList@.f[3].m := insnList@.f[3].m + [0];
}; (* P5433 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5531;
var l5var1z, l5var2z:boolean; l5var3z, l5var4z, l5var5z,
l5var6z, l5var7z:integer; l5var8z: @struc; l5var9z: word;
{
 if (l4var1z.b) then {
     if (l4var4z.b) then  insnList := l4var3z;
 } else if (l4var2z.b) then {
     if (not l4var5z.b) then insnList := l4var3z;
 } else {
 l5var1z := 16 in insnList@.f[3].m;
 l5var2z := 16 in l4var3z@.f[3].m;
 l5var5z := glob94z;
 glob94z := (glob94z + (1));
 bool49z := false;
 l5var6z := ord(l5var1z) + 100000000B;
 l5var7z := ord(l5var2z) + 100000000B;
 if (insnList@.f[4].c = '_003') then {
   l5var3z := insnList@.f[5].i;
 } else {
   l5var3z := (0);
   P4343    ;
 };
 if (l4var3z@.f[4].c = '_003') then {
 l5var4z := l4var3z@.f[5].i;
 } else {
 l5var4z := (0);
 };
 l5var9z.m := (insnList@.f[3].m + l4var3z@.f[3].m);
 if (l5var3z = (0)) then {
   if (l5var4z = (0)) then {
 addInsnAndModify    ( l5var6z, l5var5z );
 l5var8z := insnList;
 insnList := l4var3z;
 P4343    ;
 addInsnAndModify    ( l5var7z, l5var5z );
  } else {
  if (l5var2z) then {
 addInsnAndModify    ( l5var6z, l5var5z );
 l5var8z := insnList;
 insnList := l4var3z;
 addInsnAndModify    (100000002B, 10000B * l5var5z + l5var4z);
  } else {
  addInsnAndModify    ( l5var6z, l5var4z );
 l5var5z := l5var4z;
 l5var8z := insnList;
 insnList := l4var3z;
 } };
  } else {
  if (l5var4z = (0)) then {
 if (l5var1z) then {
 addInsnAndModify    (100000002B, 10000B * l5var5z + l5var3z);
 l5var8z := insnList;
 insnList := l4var3z;
 P4343    ;
 addInsnAndModify    ( l5var7z, l5var5z );
  } else {
  l5var8z := insnList;
 insnList := l4var3z;
 P4343    ;
 addInsnAndModify    ( l5var7z, l5var3z );
 l5var5z := l5var3z;
 };
 } else {
if (l5var1z) then {
 if (l5var2z) then {
 addInsnAndModify    (100000002B, 10000B * l5var5z + l5var3z );
 l5var8z := insnList;
 insnList := l4var3z;
 addInsnAndModify    (100000002B, 10000B * l5var5z + l5var4z );
 } else {
 addInsnAndModify    (100000002B, 10000B * l5var4z + l5var3z );
 l5var8z := insnList;
 insnList := l4var3z;
 l5var5z := l5var4z;
 }
 } else {
 l5var8z := insnList;
 insnList := l4var3z;
 l5var5z := l5var3z;
 if (l5var2z) then
     addInsnAndModify    (100000002B, 10000B * l5var3z + l5var4z )
 else
     addInsnAndModify    (100000003B, 10000B * l5var3z + l5var4z );
 } } };
 insnList@.f[3].m := l5var9z.m - [16];
 l5var8z@.f[0].s@.f[0] := insnList@.f[1];
 insnList@.f[1] := l5var8z@.f[1];
 insnList@.f[4].c := '_003';
 insnList@.f[5].i := l5var5z;
 bool49z := true;
 exit; (* workaround *)
 }
}; (* P5531 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5757;
var l5var1z, l5var2z, l5var3z, l5var4z, l5var5z, l5var6z,
l5var7z, l5var8z: integer;
l5var9z: struc;
l5var20z, l5var21z: @struc; l5var22z, l5var23z:word;
l5var24z:boolean; l5var25z: word; l5var26z, l5var27z: @struc; l5var28z: word;
l5var29z:@struc; l5var30z: array[1..10] of word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function myminel(l6arg1z:set of 0..47):integer;
{
myminel := minel(l6arg1z);
}; (* myminel *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* P5757 *)
 l5var2z := (0);
 l5var29z := l4arg1z;
 while (l5var29z@.f[1].c = '_034') do {
 genFullExpr    ( l5var29z@.f[3].s );
 l5var2z := (l5var2z + (1));
 l5var30z[l5var2z].s := insnList;
 l5var29z := l5var29z@.f[2].s;
 };
 genFullExpr    ( l5var29z );
 l5var21z := insnList;
 l5var9z := insnList@;
 l5var20z := ref(l5var9z);
 l5var22z := glob147z;
 for l5var3z to l5var2z do
    l5var22z.m := l5var22z.m - l5var30z[l5var3z].s@.f[3].m;

 for l5var3z := l5var2z downto 1 do {
     l5var26z := l5var9z.f[2].s@.f[3].s;
     l5var27z := l5var9z.f[2].s@.f[4].s;
     l5var25z := l5var9z.f[2].s@.f[5];
     l5var7z := l5var27z@.f[5].i;
     l5var8z := l5var26z@.f[0].i;
     if not l5var25z.b then
       l5var9z.f[6].i := l5var9z.f[6].i - l5var8z * l5var7z;
     insnList := l5var30z[l5var3z].s;
     l5var28z := insnList@.f[4];
     if (l5var28z.c = '_000') then {
         curVal := insnList@.f[5];
         curVal.m := curVal.m +  intZero;
         if (curVal.i < l5var7z) or
            (l5var27z@.f[6].i < curVal.i) then error    ( 29 );
        if (l5var25z.b) then {
         l5var4z := (curVal.i - l5var7z);
         l5var5z := l5var9z.f[2].s@.f[6].i;
         l5var9z.f[3].m := l5var9z.f[3].m + [0];
         l5var9z.f[6].i := l5var4z DIV l5var5z + l5var9z.f[6].i;
         l5var6z := (l5var5z-1-l5var4z MOD l5var5z) * l5var9z.f[2].s@.f[7].i;
         case l5var9z.f[8].c of
         '_000': l5var9z.f[10].i := l5var6z;
         '_001': l5var9z.f[10].i := l5var9z.f[10].i + l5var6z +
                 l5var9z.f[2].s@.f[1].i - 48;
         '_002':  error    ( 28 );
        end; (* case *)
        l5var9z.f[9] := l5var9z.f[2].s@.f[7];
        l5var9z.f[8].b := true;
        } (* 6116 *) else {
           l5var9z.f[6].i := curVal.i  * l5var26z@.f[0].i + l5var9z.f[6].i;
        }
    } else { (* 6123*)
         if (checkBounds) then {
             l5var24z := typeCheck( l5var27z, insnList@.f[2].s) ;
             if (bool105z) then P5354( l5var27z );
         };
         if (l5var8z <> (1)) then {
             P4343    ;
             if (l5var27z@.f[3].s = integerType) then {
                l5var4z := 00310100B;
             } else {
                l5var4z := 00310030B;
             };
             addToInsnList ( l5var9z.f[2].s@.f[6].i );
             insnList@.f[0].s@.f[1].i := (1);
             if (l5var7z >= (0)) then addToInsnList    ( l5var4z )
             else  addToInsnList    ( 100000007B );
        };
        if (l5var28z.c = '_003') or
           (l5var28z.c = '_001') and
           (insnList@.f[8].c <> '_000') then  P4343    ;
        l5var23z.m := (l5var9z.f[3].m + insnList@.f[3].m);
        if (not l5var25z.b) then {
            if (l5var9z.f[7].i = (18)) then {
               if (insnList@.f[4].c = '_002') then {
                  l5var9z.f[7].i := (15);
               } else { (* 6200*)
                  l5var9z.f[7].i := (16);
                   curInsnTemplate.i := insnTemp[VTM];
                   P4343    ;
                   curInsnTemplate.i := insnTemp[XTA];
               }; (* 6205 *)
               l5var9z.f[0] := insnList@.f[0];
               l5var9z.f[1] := insnList@.f[1];
            } else { (* 6211 *)
                if (l5var9z.f[7].i >= (15)) then {
                 l5var1z :=   myminel( l5var22z.m ) ;
                 if ((0) >= l5var1z) then {
                    l5var1z :=   myminel(glob147z.m - l5var9z.f[3].m) ;
                    if ((0) >= l5var1z) then l5var1z := (9);
                 };
                  l3var12z := insnList;
                  insnList := l5var20z;
                  l5var23z.m := l5var23z.m + [l5var1z];
                    if (l5var9z.f[7].i = (15)) then {
                        addToInsnList(insnTemp[ATI] + l5var1z);
                    } else {
                        addToInsnList(int398ar[l5var1z] + insnTemp[UTM]);
                    };
                    l5var9z.f[7].i := l5var1z;
                    l5var9z.f[3].m := l5var9z.f[3].m + [l5var1z];
                    insnList := l3var12z;
              } else {
                   l5var1z := l5var9z.f[7].i;
              }; (* 6251 *)
              if (l5var1z IN insnList@.f[3].m) then {
                  P4606;
                 insnList@.f[0].s@.f[0] := l5var9z.f[1];
                 l5var9z.f[1] := insnList@.f[1];
                 insnList := l5var20z;
                 addInsnAndModify(100000010B, l5var1z );
              } else {
               if (insnList@.f[4].c = '_002') then {
                 addInsnAndModify(100000011B, l5var1z );
               } else {
                  curInsnTemplate.i := insnTemp[VTM];
                  P4343    ;
                  curInsnTemplate.i := insnTemp[XTA];
                  addToInsnList(int398ar[l5var1z] + insnTemp[UZA]);
               };
                l5var9z.f[0].s@.f[0] := insnList@.f[1];
                l5var9z.f[0] := insnList@.f[0];
             }
            }; (* 6305 *)
        } else { (* 6306 *)
            if (l5var9z.f[8].c = '_000') then {
                P4343    ;
                if (l5var7z <> (0)) then {
                   curVal.i := ((0) - l5var7z);
                   if (not typeCheck( insnList@.f[2].s, integerType )) then
                    curVal.m := curVal.m - intZero;
                   addToInsnList ( 40040000B + getFCSToffset );
                   insnList@.f[0].s@.f[1].i := (1);
               };
               l5var24z := 0 in l5var9z.f[3].m;
               if (l5var24z) then addToInsnList(100000005B );
               l3var12z := insnList;
               insnList := l5var20z;
               P4621    ( (14) );
               if (l5var24z) then addToInsnList (100000004B );
               l5var23z.m := l5var23z.m + [0,10,11,13,14];
               l5var9z.f[8].c := '_002';
               l5var9z.f[6].i := (0);
               l5var9z.f[5].i := (0);
               l5var9z.f[9] := l5var9z.f[2].s@.f[7];
               curVal := l5var9z.f[9];
               if (curVal.i = (24)) then curVal.i := (7);
               curVal := curVal;besm(360050B);curVal:=;
               addToInsnList(allocSymtabForAbsolute
                  (helperNameBase[76].m + curVal.m)  + 56400000B);
               l5var9z.f[7].i := (16);
               l5var9z.f[10].i := (0);
               l3var12z@.f[0].s@.f[0] := l5var9z.f[1];
               l5var9z.f[1] := l3var12z@.f[1];
            } else {
                error (28);
            }
        }; (* 6403 *)
        l5var9z.f[3] := l5var23z;
    };
    l5var9z.f[2].s := l5var26z;
 }; (* 6406 *)
 insnList := l5var21z;
 insnList@ := l5var9z;
}; (* P5757 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P6470; label 7007;
var l5var1z, l5var2z, l5var3z, l5var4z, l5var5z,
l5var6z, l5var7z, l5var8z, l5var9z, l5var10z,
l5var11z, l5var12z, l5var13z, l5var14z, l5var15z,
l5var16z, l5var17z, l5var18z, l5var19z, l5var20z,
l5var21z, l5var22z:word;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocGlobalObject(l6arg1z:@bigstruc):integer;
{
 if (l6arg1z@.f[10].i = (0)) then {
 if (l6arg1z@.f[11].m * [20,21] <> []) then {
 curVal := l6arg1z@.f[0];
 curVal := makeNameWithStars    (true) ;
 l6arg1z@.f[10].i :=   allocExtSymbol    ( glob139z ) ;
 } else {
 l6arg1z@.f[10].i := symTabPos;
 putToSymTab    ([]);
 } };
 allocGlobalObject := l6arg1z@.f[10].i;
}; (* allocGlobalObject *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P6443(l6arg1z:boolean);
{
 if not (debugEntry in optSflags.m) then exit;
 curVal := l5var5z.s@.f[0];
 addToInsnList(52400000B + addSomethingToFCST );
 if (l6arg1z) then addToInsnList( (56400000B + lineCnt) );
 addToInsnList(getHelperProc(ord(l6arg1z) * 22 + 57)  ); (* P/CE *)
}; (* P6443 *)
{ (* P6470 *)
 l5var1z := l4arg1z@.f[2];
 l5var5z := l4arg1z@.f[3];
 l5var7z.b := (l5var5z.s@.f[3].s = NIL);
 l5var9z.b := (l5var5z.s@.f[5].s = NIL);
 if (l5var7z.b) then l5var13z.i := (3) else l5var13z.i := (4);
 l5var12z := l5var5z.q@.f[11];
 l5var10z.b := (21 in l5var12z.m);
 l5var11z.b := (24 in l5var12z.m);
 if (l5var9z.b) then {
 l5var14z.i :=   F3307    ( l5var5z.s ) ;
 l5var6z := l5var5z.s@.f[7];
} else {
  l5var13z.i := (l5var13z.i + (2));
};
 new(insnList);
 insnList@.f[1].s := NIL;
 insnList@.f[0].s := NIL;
 insnList@.f[2] := l5var5z.s@.f[3];
 insnList@.f[3].m := (l5var5z.q@.f[11].m + [7:15]) * [0:8,10:15];
 insnList@.f[4].c := '_002';
 if (l5var10z.b) then {
   l5var8z.b := not l5var7z.b;
   if (checkFortran) then {
     addToInsnList(getHelperProc( 92 )  ); (* "P/MF" *)
   }
 } else {
   l5var8z.b := true;
   if (not l5var9z.b) and (l5var1z.s <> NIL)
     or (l5var9z.b) and (l5var14z.i >= (2)) then {
      addToInsnList ( (76500000B + l5var13z.i) );
   };
 };
 l5var14z.i := (0);
 (loop) while l5var1z.s <> NIL do { (* 6574 *)
   l5var2z := l5var1z.s@.f[3];
   l5var1z := l5var1z.s@.f[2];
   l5var21z := l5var2z.s@.f[1];
   l5var14z.i := (l5var14z.i + (1));
   l5var20z.s := insnList;
   if (l5var21z.c = '_046') or (l5var21z.c = '_047') then {
     l5var4z := l5var2z.s@.f[3];
     new(insnList);
     insnList@.f[1].s := NIL;
     insnList@.f[0].s := NIL;
     insnList@.f[3].m := [];
     glob145z.m := glob145z.m + l5var4z.q@.f[11].m;
     if (l5var4z.s@.f[5].s <> NIL) then {
       addToInsnList (l5var4z.s@.f[1].i + insnTemp[XTA] + l5var4z.s@.f[6].i);
       if (l5var10z.b) then addToInsnList(getHelperProc(19)); (* "P/EA" *)
     } else (a) { (* 6636 *)
       if (l5var4z.s@.f[6].i = (0)) then {
         if (l5var10z.b) and (21 in l5var4z.q@.f[11].m) then {
           addToInsnList(allocGlobalObject(l5var4z.q)  + 72400000B);
           addToInsnList( 00420016B );
           exit a;
         } else { (* 6651 *)
           l5var16z.i := (0);
           formJumpOnCond (l5var16z.i);
           formLabel    ;
           l5var4z.s@.f[6].i := moduleOffset;
           l5var3z := l5var4z.s@.f[7];
           l5var15z.i := ord(l5var4z.s@.f[3].s <> NIL);
           l5var17z.i :=   F3307 ( l5var4z.s ) ;
           form3Insn(52400004B + moduleOffset, 46400000B + l5var15z.i,
                     42474001B );
           formInsnAndLabel(getHelperProc(62)); (* "P/BP" *)
           l5var15z.i := l5var17z.i + 2 + l5var15z.i;
           form1Insn (74100000B + l5var15z.i);
           if ((1) < l5var17z.i) then
             form1Insn(76500000B + l5var15z.i)
           else
             form1Insn(0);
           form2Insn(getHelperProc(63(*P/B6*)) + 6437777777300000C,
                     allocGlobalObject(l5var4z.q) + 03000000B);
           if (l5var3z.s <> NIL) then {
             repeat
               l5var22z := l5var3z.s@.f[4];
               if (l5var22z.c = '_002') and
                  (l5var3z.s@.f[3].s <> NIL) then
                 l5var22z.c := '_001';
               form2Insn (0, ord(l5var22z.c) );
               l5var3z := l5var3z.s@.f[5];
             until (l5var4z = l5var3z);
           }; (* 6745 *)
           storeObjWord([]);
           P0715(0, l5var16z.i);
         }
       }; (* 6752 *)
        addToInsnList    ( (72400000B + l5var4z.q@.f[6].i) );
        if  21 in l5var4z.q@.f[11].m then
         addToInsnList    ( 00420016B )
        else
         addToInsnList( getHelperProc ( 64 )); (* "P/PB" *)
     }; (* 6765 *)
     if (l5var21z.c = '_046') then
         l5var22z.c := '_002' else
         l5var22z.c := '_001';
    } else { (* 6772 *)
       genFullExpr    ( l5var2z.s );
       if (insnList@.f[4].c = '_001') then
         l5var22z.c := '_004'
       else
         l5var22z.c := '_003';
   }; (* 7001 *)
   if not (not l5var9z.b or (l5var22z.c <> '_004') or
          (l5var6z.s@.f[4].c <> '_003')) then
     l5var22z.c := '_003';

   7007: if (l5var22z.c = '_004') or (l5var11z.b) then {
     P4621(14);
     addToInsnList    ( 00420016B );
   } else if (l5var22z.c = '_003') then {
     if (insnList@.f[2].s@.f[0].i <> (1)) then {
        l5var22z.c := '_004';
        goto 7007; (* a structural label doesn't work *)
     } else {
        P4343;
        (q) exit q (* workaround *)
     }
   }; (* 7027 *)
   if not l5var8z.b then  addxToInsnList(100000005B);
   l5var8z.b := false;
   if (l5var20z.s@.f[0].s <> NIL) then {
       l5var20z.s@.f[0].s@.f[0] := insnList@.f[1];
       insnList@.f[1] := l5var20z.s@.f[1];
   };
   insnList@.f[3].m := insnList@.f[3].m + l5var20z.s@.f[3].m;
   if not l5var9z.b then {
      curVal := l5var22z;
      addToInsnList(40030000B +  getFCSToffset);
   };
   if l5var9z.b and not l5var11z.b then l5var6z := l5var6z.s@.f[5];
 }; (* while -> 7061 *)
 P6443 (true);
 if l5var10z.b then {
   addToInsnList    ( 00370002B );
   insnList@.f[0].s@.f[1].i := (4);
 };
 if l5var9z.b then {
     addToInsnList (allocGlobalObject( l5var5z.q )  + 67100000B);
     if (20 in l5var5z.q@.f[11].m) then {
        l5var17z.i := (1);
     } else {
        l5var17z.i := l5var5z.q@.f[1].i div 4000000B;
     } (* 7102 *)
 } else { (* 7103 *)
   l5var15z.i := (0);
   if (l5var14z.i = (0)) then {
      l5var17z.i := (l5var13z.i + (1));
   } else {
     l5var17z.i := -(2 * l5var14z.i + l5var13z.i);
     l5var15z.i := (1);
   }; (* 7115 *)
   addInsnAndModify(100000020B + l5var15z.i,
                    getValueOrAllocSymtab(l5var17z.i));
   addToInsnList(l5var5z.s@.f[1].i + insnTemp[WTC] + l5var5z.s@.f[6].i);
   addToInsnList(100000022B);
   l5var17z.i := (1);
 }; (* 7132 *)
 insnList@.f[0].s@.f[1].i := (2);
 if (curProcNesting <> l5var17z.i) then {
   if not l5var10z.b then {
   if ((l5var17z.i + (1)) = curProcNesting) then {
    addToInsnList    ( (34440000B + curProcNesting) );
   } else {
    l5var15z := frameRestore[curProcNesting][l5var17z.i];
    if (l5var15z.i = (0)) then {
      curVal.i := 6017T; (* P/ *)
      l5var19z.i := (curProcNesting + (16));
      besm(360042B);
      l5var19z := ;
      l5var18z.i := (l5var17z.i + (16));
      besm(360050B);
      l5var18z := ;
      curVal.m := curVal.m + l5var19z.m + l5var18z.m;
      l5var15z.i :=   allocExtSymbol    ( glob139z ) ;
      frameRestore[curProcNesting][l5var17z.i] := l5var15z;
   };
   addToInsnList    ( (67100000B + l5var15z.i) );
 }}}; (* 7176 *)
 if not l5var9z.b or ([20,21] * l5var12z.m <> []) then {
     addToInsnList    ( 42474001B );
 };
 glob145z.m := (glob145z.m + l5var12z.m) * [1:15];
 P6443(false);
 if l5var10z.b then {
    if (not checkFortran) then
        addToInsnList (00370007B )
    else
       addToInsnList (getHelperProc(93));    (* "P/FM" *)
    insnList@.f[0].s@.f[1].i := (2);
 } else {
   if not l5var7z.b then addToInsnList(74100000B + l5var13z.i - (1));
 }; (* 7226 *)
 if not l5var7z.b then {
 insnList@.f[2] := l5var5z.s@.f[3];
 insnList@.f[3].m := insnList@.f[3].m + [0];
 insnList@.f[4].c := '_002';
 glob146z.m := glob146z.m - l5var12z.m;
 }
(* 7237 *) }; (* P6470 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure startInsnList(l5arg1z:char);
{
 new(insnList);
 insnList@.f[0].s := NIL;
 insnList@.f[1].s := NIL;
 insnList@.f[2] := l4arg1z@.f[0];
 insnList@.f[3].m := [];
 insnList@.f[4].c := l5arg1z;
 if (l5arg1z = '_000') then {
 insnList@.f[5] := l4arg1z@.f[2];
 insnList@.f[7] := l4arg1z@.f[3];
 } else {
 insnList@.f[8].c := '_000';
 insnList@.f[7].i := (18);
 insnList@.f[5].i := curFrameRegTemplate;
 insnList@.f[6] := l4arg1z@.f[2];
 }
}; (* startInsnList *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P7272;
var l5var1z:integer;
{
 l5var1z := insnList@.f[2].s@.f[0].i;
 if (l5var1z = (1)) then {
 l3var12z := insnList;
 insnList := l4var3z;
 P4343    ;
 genOneOp    ;
 insnList := l3var12z;
 P4755    ;
 genOneOp    ;
 } else {
 P5314;
 genOneOp    ;
 l5var1z := (l5var1z - (1));
  formInsnAndLabel    ( getValueOrAllocSymtab(-l5var1z) + 66400000B );
 l4var7z.i := moduleOffset;
 form2Insn    ( (72200000B + l5var1z), 64100000B );
 form3Insn    ( (62200000B + l5var1z), 64000000B, (67700000B + l4var7z.i) );
 glob145z.m := glob145z.m + [12:14];
 }
}; (* P7272 *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genConstDiv;
function PASDIV(r:real):word;external;
{
 curVal := PASDIV(1/l4var5z.i) ;
 addToInsnList    (40170000B + getFCSToffset);
}; (* genConstDiv *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genEqComp;
label 7475, 7504, 7514, 7530;
var l5var1z, l5var2z, l5var3z, l5var4z:word;
{
 l3var3z.i := ord(l4var6z.c) - (8);
 l5var1z.b := odd(l3var3z.i);
 if (l3var3z.i = (6)) then {
   if (l4var1z.b) then {
    if (l4var2z.b) then {
      insnList@.f[5].b := (l4var4z.i IN l4var5z.m);
    } else {
      l5var2z.m := [l4var4z.i];
      if (l5var2z.m = []) then {
        insnList@.f[5].b := false;
      } else {
        insnList := l4var3z;
        P4343    ;
        curVal := l5var2z;
         addToInsnList(40110000B + getFCSToffset);
         insnList@.f[5].i := (0);
         insnList@.f[4].c := '_003';
    }}; (* 7412 *)
   } else { (* 7413 *)
     l3var12z := insnList;
     insnList := l4var3z;
     l4var3z := l3var12z;
     l3var4z.i := (66);
     P5270;
     insnList@.f[4].c := '_002';
 }} else { (* 7423 *)
     if l5var1z.b then l3var3z.i := (l3var3z.i - (1));
     l2var13z := insnList@.f[2];
     curVarKind := l2var13z.s@.f[2];
     l5var4z := l2var13z.s@.f[0];
     if (l2var13z.s = realType) then {
       if (fuzzReals) then l4var7z.i := (0) else l4var7z.i := (1);
     } else if (curVarKind.c = '_004') then
        l4var7z.i := (2)
     else if (curVarKind.i IN [1,2]) then
        l4var7z.i := (3)
     else {
        l4var7z.i := (4);
        (a) exit a (* workaround *)
     };
     if (l5var4z.i <> (1)) then {
      P5314;
      addInsnAndModify( 56400000B, ((1) - l5var4z.i) );
      addToInsnList(getHelperProc (89 + l3var3z.i) ); (* P/EQ *)
      insnList@.f[4].c := '_002';
      l5var1z.b := not l5var1z.b;
      } else (* 7471 *) if l3var3z.i = (0) then {
        if (l4var7z.i = (0)) then {
           l3var4z.i := (15);
           7475:
           P5270;
           insnList@.f[4].c := chr(2C);
        } else { (* 7501 *)
           l3var4z.i := insnTemp[AEX];
           P5433(true);
           7504:
           insnList@.f[4].c := chr(3C);
           insnList@.f[5].i := (0);
        };
     } else { (* 7510 *)
       case l4var7z.i of
          (*7511*) 0: { l3var4z.i := 16; goto 7475; };
          (*7513*)1: {
            l5var3z.i := (3);
            7514:
            l3var4z.i := insnTemp[SUB];
            P5433(false);
            insnList@.f[0].s@.f[1] := l5var3z;
            if (l5var3z.i = (3)) then {
             addToInsnList    ( 00370023B );
             insnList@.f[0].s@.f[1].i := (2);
            };
            goto 7504;
          };
          (*7527*)2: {
            l3var4z.i := insnTemp[AAX];
            7530:
            P4343    ;
            addToInsnList    ( 04120024B );
            P5433(true);
            goto 7504;
          };
          (*7536*)3: { l5var3z.i := 1; goto 7514; };
          (*7540*)4: { l3var4z.i := insnTemp[ARX]; goto 7530; };
       end; (* case *)
      }; (* 7554 *)
      insnList@.f[3].m := insnList@.f[3].m - [16];
      if (l5var1z.b) then P5420;
 }; (* 7562 *)
(* 7562 *) }; (* genEqComp *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* genFullExpr *);
   if l4arg1z = NIL then exit;
   7567: l4var6z := l4arg1z@.f[1];
 if (l4var6z.c < chr(34C)) then {
   genFullExpr( l4arg1z@.f[3].s );
   l4var3z := insnList;
   if (l4var6z.c = chr(33C)) then l3var13z.c := chr(0C);
   genFullExpr( l4arg1z@.f[2].s );
   if (l4var6z.c = chr(33C)) then l3var13z.c := chr(1C);
   if (insnList@.f[4].c = chr(0C)) then { 
     l4var1z.c := chr(1C);
     l4var4z := insnList@.f[5];
 } else
    l4var1z.c := chr(0C);
 if (l4var3z@.f[4].c = chr(0C)) then {
    l4var2z.c := chr(1C);
    l4var5z := l4var3z@.f[5];
 } else 
   l4var2z.c := chr(0C);
 if (l4var6z.o IN [NEOP,EQOP,LTOP,GEOP,GTOP,LEOP,INOP]) then {
   genEqComp;
 } else { (* 7625 *)
 if l4var1z.b and l4var2z.b then {
   case l4var6z.o of
   MUL:     l4var4z.r := l4var4z.r * l4var5z.r;
   RDIVOP:  l4var4z.r := l4var4z.r / l4var5z.r;
   AMPERS:  l4var4z.b := l4var4z.b and l4var5z.b;
   IDIVOP:  l4var4z.i := l4var4z.i DIV l4var5z.i; 
   IMODOP:  l4var4z.i := l4var4z.i MOD l4var5z.i;
   PLUSOP:  l4var4z.r := l4var4z.r + l4var5z.r;
   MINUSOP: l4var4z.r := l4var4z.r - l4var5z.r;
   OROP:    l4var4z.b := l4var4z.b or l4var5z.b: 
   IMULOP:  l4var4z.i := l4var4z.i * l4var5z.i;
   SETAND:  l4var4z.m := l4var4z.m * l4var5z.m;
   SETXOR:  l4var4z.m := l4var4z.m MOD l4var5z.m;
   FIXEDPLUS: l4var4z.i := l4var4z.i + l4var5z.i;
   FIXEDMINUS: l4var4z.i := l4var4z.i - l4var5z.i;
   SETOR: l4var4z.m := l4var4z.m + l4var5z.m;
   IDIVROP: l4var4z.r := l4var4z.i / l4var5z.i;
   XORALLONES: goto 10075;
   NEOP,EQOP,LTOP,GEOP,GTOP,LEOP,INOP,
   badop27,badop30,badop31,badop32,badop33: error (200);
   end; (* case 7750 *)
   insnList@.f[5] := l4var4z;
 } else { (*7752*)
   l3var3z.i := glob451z[l4var6z.i];
   l3var6z.i := glob488z[l4var6z.i];
   l3var4z.i := int414ar[l4var6z.i];
   case l3var6z.c of
   '_000': 7760: P5433(l4var6z.i in [0,5,17,21]);
   '_001': P5270;
   '_007': { P7272; exit };
   '_002': { P5531; exit };
   '_003': {
     P5420; l3var12z := insnList; insnList := l4var3z;
     P5420; l4var3z := insnList; insnList := l3var12z;
     P5531; P5420;
     exit
     };
   '_005': if (l4var2z.b) then {
         P4343;
         if card(l4var5z.m) = 4 then {
         curVal.m := [minel(l4var5z.m-intZero)+1..47]; (* TODO + [0,1,3] *)
         addToInsnList(40110000B +getFCSToffset);
         l3var3z.i := (0);
       } else { (* 10016 *)
         addToInsnList(100000005B);
         genConstDiv;
         insnList@.f[0].s@.f[1].i := (1);
         curVal.m := l4var5z.m - [1,3];
         addToInsnList( 40170000B + getFCSToffset );
         addToInsnList( 00310100B );
         addToInsnList( 74060000B );
         l3var3z.i := (1);
       } (* 10036 *)
     } else { (* 10037 *)
        P5270;
     };
   '_004': {
     if l4var2z.b then {
       P4343;
       genConstDiv;
       l3var3z.i := (1);
     } else P5270;
   };
   '_006': {
     if (l4var1z.b) then {
       insnList@.f[5].m := l4var4z.m MOD [1,3];
     } else {
       if (l4var2z.b) then {
         l4var3z@.f[5].m := l4var5z.m MOD [1,3];
       } else {
          P4343;
          addToInsnList( 04120012B );
       }
     };
     P5433(true);
     insnList@.f[0].s@.f[1].i := (1);
     if (fixMult) then  addToInsnList(100000007B )
     else addToInsnList( 00310100B );
   };
   '_010': 10075: {
     l3var12z := insnList;
     insnList := l4var3z;
     l4var3z := l3var12z;
     P4343;
     addToInsnList( 04120024B );
     goto 7760
   }
   end; (* case 10122 *)
   10122: insnList@.f[0].s@.f[1] := l3var3z;
 }
 } } else { (* 10125 *)
 if (chr(43B) >= l4var6z.c) then {
 if (l4var6z.c = chr(35B)) then {
 new(insnList);
 l2var5z := l4arg1z@.f[2];
 with insnList@ do {
 f[0].s := NIL;
 f[1].s := NIL;
 f[3].b := false;
 f[4].b := true;
 f[5] := l2var5z.s@.f[1];
 f[6] := l2var5z.s@.f[6];
 f[8].b := false;
 f[7].i := (18);
 };
 if (l2var5z.s@.f[4].c = chr(4C)) then {
    P5170;
 } else if (l2var5z.s@.f[4].c = chr(2C)) then {
     insnList@.f[6].i := (3);
     insnList@.f[5].i := (insnList@.f[5].i + frameRegTemplate);
   } else if (insnList@.f[6].i >= 74000B) then {
       addToInsnList( insnTemp[WTC] + insnList@.f[6].i );
       insnList@.f[6].i := (0);
       insnList@.f[7].i := (17);
       insnList@.f[5].i := (0);
   }
 } else  (* 10171 *)
   if (l4var6z.c = chr(41C)) then {
     genFullExpr( l4arg1z@.f[2].s );
     l2var5z := l4arg1z@.f[3];
     with insnList@ do {
       f[6].i := f[6].i + l2var5z.s@.f[1].i;
       if (l2var5z.s@.f[7].b) then {
         case f[8].c of
         '_000': f[10] := l2var5z.s@.f[8];
         '_001': {
            f[10].i := f[10].i + l2var5z.s@.f[8].i;
            if not (S6 IN optSflags.m) then
             f[10].i := f[10].i + l2var5z.s@.f[6].s@.f[1].i - 48;
         };
         '_002':if (not l3var13z.b) then
             error    (28 )
             else {
               P5155;
               insnList@.f[10] := l2var5z.s@.f[8];
               }
         end; (* 10235*)
         insnList@.f[9] := l2var5z.s@.f[9];
         insnList@.f[8].b := true;
         insnList@.f[3].m := insnList@.f[3].m + [0];
       }
     };
  } else  (* 10244 *)
     if (l4var6z.c  = chr(34C)) then P5757
     else if (l4var6z.c = chr(42C)) or (l4var6z.c = chr(43C)) then {
   genFullExpr( l4arg1z@.f[2].s );
   P5170;
 } else 
   if (l4var6z.c = chr(36C)) then {
     startInsnList( chr(1) );
 } else 
 if (l4var6z.c = chr(37C)) then {
    startInsnList( chr(1) );
    P5170;
 } else  if (l4var6z.c = chr(40C)) then  startInsnList(chr(0));
  
} else (* 10272 *)
  if (l4var6z.c = chr(45C)) then P6470
  else if (l4var6z.i IN [40,41,42,43,44]) then {
    genFullExpr( l4arg1z@.f[2].s );
    if (insnList@.f[4].c = chr(0C)) then {
     l4var4z := insnList@.f[5];
     case l4var6z.c of
     '_050': {
       l4var5z.m := [0,1,3] + l4var4z.m;
       with l4arg1z@.f[3].s@ do{
       if (l4var5z.i < f[5].i) or
          (f[6].i < l4var5z.i) then error(21);
     }};
     '_051': l4var4z.r := l4var4z.i;
     '_052': l4var4z.b := not l4var4z.b;
     '_054': l4var4z.r := -l4var4z.r;
     '_053': l4var4z.i := -l4var4z.i;
     end; (* case 10345 *)
     insnList@.f[5] := l4var4z;
  } else (* 10347 *) if (l4var6z.c =chr(52C)) then {
     P5420;
  } else {
     P4343;
     if (l4var6z.c = chr(50C)) then {
         if (checkBounds) then P5354(l4arg1z@.f[3].s);
     } else if (l4var6z.c = chr(51C)) then {
         addToInsnList( insnTemp[AVX] );
         l3var3z.i := (3);
         goto 10122;
     } else {
         addToInsnList( 04140017B );
         if (l4var6z.c = chr(54C)) then
             l3var3z.i := (3)
         else
             l3var3z.i := (1);
         goto 10122;
  }}} else (* 10376 *) if (l4var6z.c = chr(55C)) then {
      genFullExpr( l4arg1z@.f[2].s );
      l4var7z := l4arg1z@.f[3];
      if ((100) < l4var7z.i) then {
          P4343;
          addToInsnList(getHelperProc(l4var7z.i - 100));
      } else {
           if (insnList@.f[4].c = chr(0C)) then {
           l4var1z.b := true;
           l4var4z := insnList@.f[5];
         } else
           l4var1z.b := false;
         l4var2z.b := (insnList@.f[2].s = realType);
         if (l4var1z.b) then {
         case l4var7z.i of
         fnSQRT:  l4var4z.r := sqrt(l4var4z.r);
         fnSIN:   l4var4z.r := sin(l4var4z.r);
         fnCOS:   l4var4z.r := cos(l4var4z.r);
         fnATAN:  l4var4z.r := arctan(l4var4z.r);
         fnASIN:  l4var4z.r := arcsin(l4var4z.r);
         fnLN:    l4var4z.r := ln(l4var4z.r);
         fnEXP:   l4var4z.r := exp(l4var4z.r);
         fnABSR:  l4var4z.r := abs(l4var4z.r);
         fnTRUNC: l4var4z.i := trunc(l4var4z.r);
         fnODD:   l4var4z.b := odd(l4var4z.i);
         fnORD:   l4var4z.i := ord(l4var4z.c);
         fnCHR:   l4var4z.c := chr(l4var4z.i);
         fnSUCC:  l4var4z.c := succ(l4var4z.c);
         fnPRED:  l4var4z.c := pred(l4var4z.c);
         fnPTR:   l4var4z.s := ptr(l4var4z.i);
         fnSQRR:  l4var4z.r := l4var4z.r*l4var4z.r;
         fnROUND: l4var4z.i := round(l4var4z.r);
         fnCARD:  l4var4z.i := card(l4var4z.m);
         fnMINEL: l4var4z.i := minel(l4var4z.m);
         fnABSI:  l4var4z.i := abs(l4var4z.i);
         fnSQRI:  l4var4z.i := l4var4z.i*l4var4z.i;
         fnEOF,
         fnREF,
         fnEOLN:  error(201);
         end; (* 10546 *)
         insnList@.f[5] := l4var4z;
         } else 
           (* 10550 *) if (l4var7z.i >= 14) and (16 >= l4var7z.i) then {
            if (l4var7z.i = 15) then { 
               P4621(14);
               addToInsnList( 00420016B );
            } else {
               P4621(12);
               addToInsnList(getHelperProc(l4var7z.i - 6));
            };
            with insnList@ do {
               f[4].c := chr(2C);
               f[3].m := f[3].m + [0];
            }
         } else {
            P4343;
            if (l4var7z.i = (8)) then {
               l3var3z.i := (2);
               addToInsnList(getHelperProc(58)); (*"P/TR"*)
               goto 10122;
            };
            if (l4var7z.i IN [0,1,2,3,4,5,6,9,10,11,12,19,21]) then {
               l3var3z.i := (0);
            } else if (l4var7z.i IN [7,17]) then 
               l3var3z.i := (3)
            else {
               l3var3z.i := (1); (q) exit q (* workaround *)
            };
            addToInsnList( funcInsn[l4var7z.i] );
            goto 10122;
         }
      }
   } else { (* 10621 *)
      if (l4var6z.c = chr(56C)) then {
         curVal := l4arg1z@.f[0];
         if (curVal.i IN glob146z.m) then {
            new(insnList);
            with insnList@ do {
             f[2] := l4arg1z@.f[3].s@.f[0];
             f[0].s := NIL;
             f[1] := ;
             f[3].m := [];
             f[4].c := chr(1C);
             f[7].i := (18);
             f[5].i := int398ar[curVal.i];
             f[6].i := (0);
             f[8].b := false;
         }
      } else {
         curVal.i := (14);
         l4arg1z@.f[0] := curVal;
         l4arg1z := l4arg1z@.f[3].s;
         goto 7567;
      };
      exit
   } else 
    error    ( (220) );
   }
}; (* 10654 *)
insnList@.f[2] := l4arg1z@.f[0];
(* 10656 *) }; (* genFullExpr *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formFileInit;
var l4var1z, l4var2z, l4var3z, l4var4z, l4var5z:word;
{
 if (S5 IN optSflags.m) then {
    formInsnAndLabel( 67000000B );
 } else {
    form2Insn    ( 00430015B, 74000000B );
    while (curExpr <> NIL) do {
       l4var1z.s := ptr(ord(curExpr@.f[0].s));
       l4var3z := curExpr@.f[3];
       l4var4z := l4var3z.s@.f[6];
       l4var2z := l4var3z.s@.f[3].s@.f[3];
       l4var5z := l4var3z.s@.f[3].s@.f[4];
       if (l4var4z.i < 00074000B) then {
          form1Insn(getValueOrAllocSymtab(l4var4z.i)+ insnTemp[WTC]+ 34000000B);
          l4var4z.i := (0);
       };
       form3Insn(62400000B + l4var4z.i, 52400000B + fileBufSize,
                 46400000B + l4var5z.i);
       form1Insn(56400000B + l4var2z.s@.f[0].i);
       if (l4var1z.s = NIL) then {
          form1Insn(insnTemp[XTA]);
       } else {
          curVal := l4var1z.s@.f[3];
          if (curVal.i =  (512)) then
             curVal := l4var1z.s@.f[1];
          form1Insn(40100000B + getFCSToffset);
       };
       formInsnAndLabel(getHelperProc(69)); (*"P/CO"*)
       curVal := l4var3z.s@.f[0];
       form2Insn(40100000B+getFCSToffset, 60000032B);
       if (l4var5z.i <> (0)) and typeCheck(l4var2z.s, integerType) then
          form2Insn    ( 04100011B, 60000031B );
       curExpr := curExpr@.f[2].s;
    };
    form1Insn(getHelperProc(70)(*"P/IT"*) + (-64100000B) );
    formLabel    ;
 }
}; (* formFileInit *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ (* formOperator *)
}; (* formOperator *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
{ (* programme *)
};
%
procedure initOptions;
{
    pasinfor.startOffset := pasinfor.startOffset-16384;
    commentModeCH := ' ';
    lineNesting := 0;
    maxLineLen := 72;
    CH := ' ';
    linePos := 0;
    prevErrPos := 0;
    errsInLine := 0;
    lineCnt := 1;
    checkFortran := false;
    glob110z := false;
    glob93z := 1;
    glob92z := 1;
    moduleOffset := 16384;
    lineStartOffset := ;
    glob94z := 1;
    bool47z := false;
    inStringLit := ;
    heapSize := 100;
    bool49z := true;
    atEOL := false;
    curVal.i := pasinfor.dummy3[18];
    besm(360031B); besm(360155B);
    optSflags := ;
    doPMD := not (42 in curVal.m);
    checkTypes := true;
    fixMult := true;
    fuzzReals := true;
    pseudoZ := ;
    checkBounds := not (44 in curVal.m);
    declExternal := false;
    errors := false;
    allowCompat := false;
    litExternal.i := 4570644562564154C;
    litForward.i := 46576267416244C;
    litFortran.i := 46576264624156C;
    fileBufSize := 1;
    charEncoding := 2;
    glob133z := NIL;
    litOct.i := 574364C;
    longSymCnt := 0;
    pasinfor.errors@ := true;
    extSymAdornment := 0;
    symTabCnt := 0;
}; (* initOptions *)
%
{ (* main *)
    if PASINFOR.listMode <> 0 then
        writeln(boilerplate);
    initOptions;
    if errors then {
9999:   writeln(' IN ', (lineCnt-1):0, ' LINES ',
            totalErrors:0, ' ERRORS');
    } else {
        PASINFOR.errors@ := false;
    }
}
.data
    hashMask := 203407C
end
*to perso:670000
*end file
``````
ะะะะะะฆ
